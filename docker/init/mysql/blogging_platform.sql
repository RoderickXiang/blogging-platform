-- MySQL dump 10.13  Distrib 8.0.19, for Win64 (x86_64)
--
-- Host: 127.0.0.1    Database: blogging_platform
-- ------------------------------------------------------
-- Server version	8.0.19

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!50503 SET NAMES utf8mb4 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Current Database: `blogging_platform`
--

/*!40000 DROP DATABASE IF EXISTS `blogging_platform`*/;

CREATE DATABASE /*!32312 IF NOT EXISTS*/ `blogging_platform` /*!40100 DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci */ /*!80016 DEFAULT ENCRYPTION='N' */;

USE `blogging_platform`;

--
-- Table structure for table `blog_article`
--

DROP TABLE IF EXISTS `blog_article`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `blog_article` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `title` char(50) NOT NULL COMMENT '文章标题',
  `content` longtext COMMENT '文章内容',
  `views` int NOT NULL DEFAULT '0' COMMENT '文章的点击量',
  `author_uid` char(50) DEFAULT NULL COMMENT '作者的uid',
  `author_name` char(100) DEFAULT NULL COMMENT '作者名',
  `category` json DEFAULT NULL COMMENT '使用json存储分类 {category_id : category_name}',
  `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `modified_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '修改时间',
  `is_deleted` int NOT NULL DEFAULT '0' COMMENT '逻辑删除',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=155 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT='文章';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `blog_article`
--

/*!40000 ALTER TABLE `blog_article` DISABLE KEYS */;
INSERT INTO `blog_article` VALUES (2,'第一篇文章',NULL,14,'d7885613210d4274bbb00834965b7155','RoderickXiang','{\"1\": \"Java\", \"2\": \"MySql\"}','2020-11-17 19:49:06','2020-11-17 19:49:06',0),(3,'第一次放数据库','### 清除缓存\r\n```\r\ngit rm -r --cached .\r\ngit add .\r\ngit commit\r\n```\r\n### 查看分支\r\n```\r\ngit branch -a   查看所有的分支\r\ngit branch 查看现在所在分支\r\n```\r\n### 建立分支\r\n```\r\ngit checkout -b newbranch   创建本地分支并切换到新创建的分支\r\ngit chechout branch 切换分支\r\ngit push origin HEAD -u 将新的分支推到远程仓库\r\n```\r\n### 合并分支\r\n```\r\ngit checkout 接收修改的分支\r\ngit merge 分支名\r\n```\r\n### 推送分支\r\n```\r\ngit push 远程主机名 本地分支名:远程分支名\r\ngit push origin --delete master    删除指定的远程分支\r\n```\r\n',11,'d7885613210d4274bbb00834965b7155','RoderickXiang','{\"1\": \"Java\"}','2020-11-24 17:26:05','2020-11-24 17:26:05',0),(4,'HHHH','dfgdfgdfgdfg',7,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2020-11-24 19:42:40','2020-11-24 19:42:40',0),(5,'CentOS开机启动项','## 系统级别\n类似于ssh的服务\n```shell\nsystemctl list-unit-files   查看所有服务列表\nsystemctl list-unit-files |grep sshd    查找特定的服务状态\n```\n\n## 其它\n```shell\nchkconfig --list    查看其他服务开机是否启动\nchkconfig nginx on  设置为开机启动\n```\n\n## 添加服务脚本\n```shell\ncd /etc/init.d/ 服务脚本位置\nchmod 777 /etc/init.d/nginx 修改权限\nchkconfig --add /etc/init.d/nginx 添加到服务列表\n```',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2020-07-23 23:06:00','2020-11-29 11:45:11',0),(6,'FastDFS','## 简述\n分布式文件存储系统\n环境准备：https://github.com/happyfish100/fastdfs/wiki\n\n## 配置\n### tracker配置\nbase_path=/home/dfs  # 存储日志和数据的根目录\n\n## 关闭防火墙\n```\nsystemctl status firewalld.service   查看防火墙状态\nsystemctl stop firewalld.service   关闭防火墙\n```\n## 启动tracker服务\n```shell\nservice fdfs_trackerd start   启动服务\nps -ef|grep fdfs    查看服务是否在运行\nchkconfig fdfs_trackerd on  设置开机自启动\nchkconfig --list    查看非系统开机自启动项\n```\n\n## 启动storage服务\n```shell \nservice fdfs_storaged start 启动\nchkconfig fdfs_storaged on  设置开机自启动',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2020-07-23 23:24:29','2020-11-29 11:45:11',0),(7,'FastDFS的安装','# 1.Linux下使用FastDFS\n\n**本教程所有操作均在CentOS 6.x环境下进行。**\n\n将课前资料中的所需文件，上传到/usr/local/leyou目录下：\n\n![1528196363110](assets/1528196363110.png)\n\n  \n\n## 1.1.单节点FastDFS\n\n整个安装过程非常复杂，很容易出错，建议进行多次备份。\n\n我们这里不打算安装多台虚拟机，因此会把tracker和storage都安装在一起。\n\n \n\n### 1.1.1.安装gcc\n\nGCC用来对C语言代码进行编译运行，使用yum命令安装：\n\n```shell\nyum -y install gcc\n```\n\n后面会用到解压命令（unzip），所以这里可以用yum把unzip 也装一下\n\n```shell\nyum install -y unzip zip\n```\n\n \n\n### 1.1.2.安装libevent\n\n```shell\nyum -y install libevent\n```\n\n \n\n### 1.1.3.安装libfastcommon-master\n\n```shell\n解压刚刚上传的libfastcommon-master.zip\nunzip libfastcommon-master.zip\n\n进入解压完成的目录\ncd libfastcommon-master\n\n编译并且安装：\n./make.sh \n./make.sh install\n```\n\n \n\n### 1.1.4.安装fastdfs\n\n```shell\ntar -zxvf FastDFS_v5.08.tar.gz\n\ncd FastDFS\n\n./make.sh \n\n./make.sh install\n```\n\n \n\n如果安装成功，会看到/etc/init.d/下看到提供的脚本文件：\n\n```shell\nll /etc/init.d/ | grep fdfs\n```\n\n![1528189386508](assets/1528189386508.png)\n\n- `fdfs_trackerd` 是tracker启动脚本\n- `fdfs_storaged` 是storage启动脚本\n\n\n\n能够在 /etc/fdfs/ 目录下看到默认的配置文件模板：\n\n```shell\nll /etc/fdfs/\n```\n\n![1528189443696](assets/1528189443696.png)\n\n- `tarcker.conf.sample` 是tracker的配置文件模板\n- `storage.conf.sample` 是storage的配置文件模板\n- `client.conf.sample` 是客户端的配置文件模板\n\n\n\n### 1.1.5.配置并启动tracker服务\n\nFastDFS的tracker和storage在刚刚的安装过程中，都已经被安装了，因此我们安装这两种角色的方式是一样的。不同的是，两种需要不同的配置文件。\n\n我们要启动tracker，就修改刚刚看到的`tarcker.conf`，并且启动`fdfs_trackerd`脚本即可。\n\n1）首先将模板文件复制\n\n```shell\ncp /etc/fdfs/tracker.conf.sample /etc/fdfs/tracker.conf\n```\n\n \n\n2）修改复制后的配置文件：\n\n```shell\nvim /etc/fdfs/tracker.conf \n```\n\n\\# 修改的内容如下：\n\n```shell\nbase_path=/leyou/tracker                 # 存储日志和数据的根目录\n```\n\n\n\n3）新建目录：     \n\n```shell\nmkdir -p /leyou/tracker\n```\n\n \n\n注意：关闭防火墙：\n\n```shell\nchkconfig iptables off\n```\n\n \n\n4）启动和停止\n\n启动tracker服务器:     `/etc/init.d/fdfs_trackerd start`\n\n停止tracker服务器:     `/etc/init.d/fdfs_trackerd stop`\n\n不过安装过程中，fdfs已经被设置为系统服务，我们可以采用熟悉的服务启动方式：\n\n```shell\nservice fdfs_trackerd start # 启动fdfs_trackerd服务，停止用stop\n```\n\n\n\n检查FastDFS Tracker Server是否启动成功：\n\n```shell\nps -ef | grep fdfs_trackerd\n```\n\n\n\n设置tracker服务开机启动:\n\n```shell\nchkconfig fdfs_trackerd on\n```\n\n \n\n### 1.1.6.配置并启动storage服务\n\n1）首先将模板文件复制\n\n```shell\ncp /etc/fdfs/storage.conf.sample /etc/fdfs/storage.conf\n```\n\n \n\n2）修改复制后的配置文件：\n\n```shell\nvim /etc/fdfs/storage.conf\n```\n\n\\# 修改的内容如下: \n\n```shell\nbase_path=/leyou/storage                 # 数据和日志文件存储根目录 \n\nstore_path0=/leyou/storage           # 第一个存储目录 \n\ntracker_server=192.168.56.101:22122       #  tracker服务器IP和端口 \n```\n\n\n\n3）新建目录：     \n\n```\nmkdir -p /leyou/storage\n```\n\n \n\n注意关闭防火墙：   `chkconfig iptables off`\n\n \n\n4）启动和停止\n\n启动storage服务器：`/etc/init.d/fdfs_storaged start`\n\n停止storage服务器：`/etc/init.d/fdfs_storaged stop`\n\n推荐使用：\n\n```shell\nservice fdfs_storaged start  # 启动fdfs_storaged服务，停止用stop\n```\n\n\n\n设置storage服务开机启动：\n\n```\nchkconfig fdfs_storaged on\n```\n\n\n\nps -ef | grep fdfs\n\n![1532866185562](assets/1532866185562.png)\n\n\n\n# 2.使用nginx访问FastDFS\n\n## 2.1.为什么需要用Nginx访问？\n\nFastDFS通过Tracker服务器,将文件放在Storage服务器存储，但是同组存储服务器之间需要进入文件复制，有同步延迟的问题。\n\n假设Tracker服务器将文件上传到了192.168.4.125，上传成功后文件ID已经返回给客户端。此时FastDFS存储集群机制会将这个文件同步到同组存储192.168.4.126，在文件还没有复制完成的情况下，客户端如果用这个文件ID在192.168.4.126上取文件,就会出现文件无法访问的错误。\n\n而fastdfs-nginx-module可以重定向文件连接到文件上传时的源服务器取文件,避免客户端由于复制延迟导致的文件无法访问错误\n\n\n\n## 2.2.安装fastdfs-nginx-module\n\n### 2.2.1.解压\n\n```shell\ntar -zxvf fastdfs-nginx-module_v1.16.tar.gz\n```\n\n\n\n### 2.2.2.修改config\n\n1）进入src目录\n\n```shell\ncd fastdfs-nginx-module/src/\n```\n\n \n\n2）编辑config\n\n```shell\nvim config\n```\n\n \n\n使用以下底行命令：\n\n```shell\n:%s+/usr/local/+/usr/+g\n```\n\n将所有的/usr/local替换为 /usr，这个才是正确的目录:\n\n![1528192579209](assets/1528192579209.png)\n\n\n\n### 2.2.3.配置nginx与FastDFS关联配置文件\n\n复制 fastdfs-nginx-module 源码中的配置文件到/etc/fdfs 目录， 并修改\n\n```shell\ncp /usr/local/leyou/fastdfs-nginx-module/src/mod_fastdfs.conf /etc/fdfs/\n\nvi /etc/fdfs/mod_fastdfs.conf\n```\n\n修改以下配置：\n\n```shell\nconnect_timeout=10                       # 客户端访问文件连接超时时长（单位：秒）\n\ntracker_server=192.168.56.101:22122    # tracker服务IP和端口\n\nurl_have_group_name=true                # 访问链接前缀加上组名\n\nstore_path0=/leyou/storage            # 文件存储路径\n```\n\n\n\n复制 FastDFS 的部分配置文件到/etc/fdfs 目录\n\n```shell\ncd /usr/local/leyou/FastDFS/conf/\ncp http.conf mime.types /etc/fdfs/\n```\n\n\n\n## 2.3.安装Nginx的插件\n\n### 2.3.1.如果没有安装过nginx\n\n- 安装nginx的依赖库\n\n\n```shell\nyum -y install gcc pcre pcre-devel zlib zlib-devel openssl openssl-devel\n```\n\n \n\n- 解压安装包\n\n\n```shell\ntar -zxvf nginx-1.10.0.tar.gz\n```\n\n \n\n- 配置nginx安装包，并指定fastdfs-nginx-model\n\n```shell\ncd nginx-1.10.0\n\n./configure --prefix=/opt/nginx --sbin-path=/usr/bin/nginx --add-module=/usr/local/leyou/fastdfs-nginx-module/src\n```\n\n**注意**：在执行./configure配置nginx参数的时候，需要将fastdfs-nginx-moudle源码作为模块编译进去。\n\n\n\n- 编译并安装\n\n```shell\nmake && make install\n```\n\n\n\n### 2.3.2.如果已经安装过nginx\n\n1） 进入nginx目录：\n\n```shell\ncd /usr/local/leyou/nginx-1.10.0/\n```\n\n \n\n2） 配置FastDFS 模块\n\n```shell\n./configure --prefix=/opt/nginx --sbin-path=/usr/bin/nginx --add-module=/usr/local/leyou/fastdfs-nginx-module/src\n```\n\n注意：这次配置时，要添加fastdfs-nginx-moudle模块\n\n \n\n3） 编译，注意，这次不要安装（install）\n\n```shell\nmake\n```\n\n \n\n4） 替换nginx二进制文件:\n\n备份：\n\n```shell\nmv /usr/bin/nginx /usr/bin/nginx-bak\n```\n\n用新编译的nginx启动文件替代原来的：\n\n```shell\ncp objs/nginx /usr/bin/\n```\n\n \n\n \n\n### 2.3.3.启动nginx\n\n配置nginx整合fastdfs-module模块\n\n我们需要修改nginx配置文件，在/opt/nginx/config/nginx.conf文件中：\n\n```shell\nvim  /opt/nginx/conf/nginx.conf\n```\n\n将文件中，原来的`server 80{ ...}` 部分代码替换为如下代码：\n\n```nginx\n    server {\n        listen       80;\n        server_name  image.leyou.com;\n\n    	# 监听域名中带有group的，交给FastDFS模块处理\n        location ~/group([0-9])/ {\n            ngx_fastdfs_module;\n        }\n\n        location / {\n            root   html;\n            index  index.html index.htm;\n        }\n\n        error_page   500 502 503 504  /50x.html;\n        location = /50x.html {\n            root   html;\n        }\n    }\n```\n\n\n\n启动nginx：\n\n```shell\nnginx	# 启动nginx\n\nnginx -s stop	# 停止nginx\n\nnginx -s reload	# 重新载入配置文件\n```\n\n\\# 可通过ps -ef | grep nginx查看nginx是否已启动成功    \n\n![1528194235317](assets/1528194235317.png)\n\n\n\n### 2.3.4.设置nginx开机启动\n\n创建一个开机启动的脚本：\n\n```shell\nvim /etc/init.d/nginx\n```\n\n添加以下内容：\n\n```sh\n#!/bin/sh\n#\n# nginx - this script starts and stops the nginx daemon\n#\n# chkconfig:   - 85 15\n# description:  NGINX is an HTTP(S) server, HTTP(S) reverse \\\n#               proxy and IMAP/POP3 proxy server\n# processname: nginx\n# config:      /etc/nginx/nginx.conf\n# config:      /etc/sysconfig/nginx\n# pidfile:     /var/run/nginx.pid\n\n# Source function library.\n. /etc/rc.d/init.d/functions\n\n# Source networking configuration.\n. /etc/sysconfig/network\n\n# Check that networking is up.\n[ \"$NETWORKING\" = \"no\" ] && exit 0\n\nnginx=\"/usr/bin/nginx\"\nprog=$(basename $nginx)\n\nNGINX_CONF_FILE=\"/opt/nginx/conf/nginx.conf\"\n\n[ -f /etc/sysconfig/nginx ] && . /etc/sysconfig/nginx\n\nlockfile=/var/lock/subsys/nginx\n\nmake_dirs() {\n   # make required directories\n   user=`$nginx -V 2>&1 | grep \"configure arguments:.*--user=\" | sed \'s/[^*]*--user=\\([^ ]*\\).*/\\1/g\' -`\n   if [ -n \"$user\" ]; then\n      if [ -z \"`grep $user /etc/passwd`\" ]; then\n         useradd -M -s /bin/nologin $user\n      fi\n      options=`$nginx -V 2>&1 | grep \'configure arguments:\'`\n      for opt in $options; do\n          if [ `echo $opt | grep \'.*-temp-path\'` ]; then\n              value=`echo $opt | cut -d \"=\" -f 2`\n              if [ ! -d \"$value\" ]; then\n                  # echo \"creating\" $value\n                  mkdir -p $value && chown -R $user $value\n              fi\n          fi\n       done\n    fi\n}\n\nstart() {\n    [ -x $nginx ] || exit 5\n    [ -f $NGINX_CONF_FILE ] || exit 6\n    make_dirs\n    echo -n $\"Starting $prog: \"\n    daemon $nginx -c $NGINX_CONF_FILE\n    retval=$?\n    echo\n    [ $retval -eq 0 ] && touch $lockfile\n    return $retval\n}\n\nstop() {\n    echo -n $\"Stopping $prog: \"\n    killproc $prog -QUIT\n    retval=$?\n    echo\n    [ $retval -eq 0 ] && rm -f $lockfile\n    return $retval\n}\n\nrestart() {\n    configtest || return $?\n    stop\n    sleep 1\n    start\n}\n\nreload() {\n    configtest || return $?\n    echo -n $\"Reloading $prog: \"\n    killproc $nginx -HUP\n    RETVAL=$?\n    echo\n}\n\nforce_reload() {\n    restart\n}\n\nconfigtest() {\n  $nginx -t -c $NGINX_CONF_FILE\n}\n\nrh_status() {\n    status $prog\n}\n\nrh_status_q() {\n    rh_status >/dev/null 2>&1\n}\n\ncase \"$1\" in\n    start)\n        rh_status_q && exit 0\n        $1\n        ;;\n    stop)\n        rh_status_q || exit 0\n        $1\n        ;;\n    restart|configtest)\n        $1\n        ;;\n    reload)\n        rh_status_q || exit 7\n        $1\n        ;;\n    force-reload)\n        force_reload\n        ;;\n    status)\n        rh_status\n        ;;\n    condrestart|try-restart)\n        rh_status_q || exit 0\n            ;;\n    *)\n        echo $\"Usage: $0 {start|stop|status|restart|condrestart|try-restart|reload|force-reload|configtest}\"\n        exit 2\nesac\n\n```\n\n修改文件权限，并加入服务列表\n\n```shell\n# 修改权限\nchmod 777 /etc/init.d/nginx \n# 添加到服务列表\nchkconfig --add /etc/init.d/nginx \n```\n\n设置开机启动\n\n```shell\nchkconfig nginx on\n```',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2018-10-20 11:04:12','2020-11-29 11:45:11',0),(8,'Linux命令','# <font color=#008000>神奇的Linux</font>\n### ls\n    -l: 长格式\n        显示项目：\n        1.文件类型：\n            -： 普通文件\n            d： 目录文件\n            b： 块设备文件(block)\n            c： 字符设备文件(character)\n            l:  符号连接文件(symbolic link file)\n            p:  命令管道文件(pipe)\n            s： 套接字文件(socket)：主机内的通信\n        2.文件权限：9位，每三位一组，rwx，r--\n        3.文件硬链接的次数\n        4.文件的属性(owner)\n        5.文件的属组(group)\n        6.时间戳(timestamp)：最近一次修改的时间\n    -h：文件大小单位转换(human readable)\n    -a: 显示以.开头的隐藏文件\n        . 表示当前目录\n        .. 表示父目录\n    -A：隐藏 . 和 ..\n    -d：显示目录自身属性\n    -i：打印引索\n    -r：逆序显示\n    -R: 递归(recursive)显示\n### cd(change directory)\n    cd ~USERNAME：进入指定账户的家目录\n    cd -：切换账户目录\n### type\n    显示指定属于那种类型\n    命令类型：\n    1.内部命令(shell内置)\n    2.外部命令，在文件系统的某个路径下有一个与命令相应的可执行文件\n### hash\n    查看缓存\n    缓存是o(1)\n### date(时间管理)\n    硬件时间：在主板上进行计时\n    系统时间：Linux开机后在软件上进行计时\n### 命令的使用帮助\n    内部命令：help COMMAND\n    外部命令：COMMAND --help\n    命令手册(manual)：man COMMAND\n        1. 以压缩文件的方式存放\n        2.内部命令使用help，外部使用manual\n        分章节\n        1.使用whatis COMMAND来查看命令手册有几个\n        2.man 章节 COMMAND：查看特定的章节\n        章节分类\n        1.用户命令\n        2.系统调用\n        3.库用户\n        4.特殊文件(设备文件)\n        5.文件格式(配置文件的语法)\n        6.游戏\n        7.杂项(miscellaneous)\n        8.管理命令\n### 命令手册\n    <>: 必选\n    []: 可选\n    ...: 可以出现多次\n    |：多选\n    ||: 分组\n    manual：\n    1.NAME：名称及简要概述\n    2.SYNOPSIS：用法说明，可用的选项\n    3.DESCRIPTION：详尽的说明\n    4.OPTIONS：每个选项的意义\n    5.FILES：相关的的配置文件\n    6.BUGS：汇报错误\n    7.EXAMPLES：示例\n    8.SEE ALSO：另外参照\n    查找：/KEYBOARD：向后\n    info COMMAND: 对于manual的补充\n    文档：/user/share/doc\n### Linux的文件系统(Filesystem Hierarchy Standard)\n    根目录文件系统\n        root filesystem\n    常见的文件\n    /boot：引导文件存放目录，内核文件，引导加载器\n    /bin：所有用户的基本命令\n    /sbin：管理类的基本命令\n    /lib：基本共享库文件，以及内核模块文件(/lib/modules)\n    /lib64：64位Linux\n    /etc：配置文件目录(纯文本文件)\n    /home/USERNAME：普通用户的家目录\n    /root：管理员的家目录(有的Linux发行版本没有管理员家目录)  \n        ==root的权限很大尽量避免使用管理员账号登入==\n    /media：便携式移动设备挂载点\n    /mnt：临时文件系统挂载点\n    /dev：设备文件储存位置：\n        b：block device(随机访问)\n        c：character device：字符设备(线性访问)\n    /opt: 第三方应用程序的安装位置\n    /srv：系统运行服务用到的数据\n    /tmp：临时文件储存\n    /usr(universal shared read-only date)\n        bin：保证系统有完整的功能\n        sbin：\n        lib：\n        lib64：\n        include：C程序头文件\n        share：结构化独立的数据\n        local：第三方应用程序的安装位置\n            bin，sbin，lib，lib64，etc，share\n    /var：variable data file\n        cache：应用程序缓存数据目录\n        lib：应用状态信息数据\n        local：专为/user/local下的应用程序储存可变数据\n        lock：锁文件\n        log：日志文件\n        opt：专用于为/opt下的应用程序存储可变数据\n        run：通常用于储存进程的pid文件\n        spool：应用程序数据池\n        tmp：保存系统两次重启之间产生的零时数据\n    /proc：用于输出内核与进程信息的虚拟文件系统\n    /sys：用于输出当前系统上硬件设备相关信息的虚拟文件系统\n    /selinux(security enhanced Linux)：安全策略等信息处理位置\n#### Linux上的应用程序的组成部分\n    二进制程序：/bin，/sbin，/usr/bin，/usr/sbin，/usr/local/bin，/usr/local/sbin\n    库文件：/lib，/lib64，/usr/lib，/usr/lib64，/usr/local/lib，/usr/local/lib64\n    配置文件：/etc，/usr/local/etc\n    帮助文件：/usr/share/man，/usr/share/doc，/usr/local/share/man，/usr/local/share/doc\n### bash的基本特性(1)\n    (1) history(历史命令)\n            环境变量：\n                HISTSIZE：命令历史计入的条数\n                HISTFILE：~/.bash_history\n                HISTFILESIZE: 命令历史文件记录历史的条数\n        -d NUM：删除指定的命令\n        -c：清除命令历史\n        -a：手动追加当前会话缓冲区的命令历史至历史文件中\n        history NUM：显示历史中最近的NUM条命令\n        \n        调用历史命令\n            !#: 重复第#条命令\n            !!: 重复上一条命令\n            !string: \n        调用上一条命令的最后一个参数\n            !$\n            ESC,.(先按ESC松了按.)\n            ALT+.(有的Linux发行版没用)\n        控制变量的计入方式：\n            环境变量：HISTCONTROL\n                ignoredups：忽略重复的命令(连续且相同)\n                ignorespace：忽略所有以空白开头的命令\n                ignoreboth：两者\n            修改环境变量：\n                export 变量名=\"值\"\n    (2)命令补全\n        Tab\n    (3)路径补全\n        Tab\n    (4)命令行的展开\n        ~：展开为用户的主目录\n        ~USERNAME：展开为指定用户的主目录\n        {}：可承载一个以逗号分隔的列表，并展开为多个路径\n            举例：mkdir temp/{x,y}=mkdir temp/x temp/y\n    (5)命令执行后的结果\n        1.状态结果\n            使用echo $?查看上一条命令的状态结果\n                成功：0\n                失败：1~255\n                成功只有一种，但失败有一万种\n        2.程序的返回值\n### 目录管理类命令\n    mkdir(创建文件夹)\n        -p：强制创建文件夹\n        -v(verbose)：显示步骤\n        -m MOOD：直接指定权限\n    rmdir(删除文件夹)\n        同上\n    tree 名称：显示层级结构\n        -d：只显示目录\n        -l NUM：只显示NUM层\n### 文本类文件查看命令\n    more\n        -d：显示翻页及退出提示\n    less\n    head\n        -c #：指定获取前#字节\n        -n #：指定获取前#行\n    tail\n        -c #：指定获取后#字节\n        -n #：指定获取后#行\n        -f：跟随显示文件新追加的内容\n### 时间戳管理\n    查看文件状态：stat\n        三个时间戳\n            access time(访问时间)：atime\n            modify time(修改时间)：mtime\n            change time(改变时间)：ctime\n    touch\n        -a：only atime\n        -m：only mtime\n        -t STAMP：修改时间戳，可以指定时间戳\n            [[CC]YY]MMDDhhmm[.ss]\n        -c: 如果文件不存在，则不予创建\n### 文件管理\n    1.cp(复制)\n        cp SRC DEST\n            SRC是文件：\n                DEST不存在：新建DEST，并将内容填充至DEST中\n                DEST存在：\n                    DEST是文件：将SRC中的内容覆盖至DEST中\n                        此时建议使用-i选项进行互动\n                    DEST是目录：在DEST下创建与SRC同名的文件并填充内容\n            SRC是目录：\n                此时应使用-r选项\n                DEST不存在：则创建指定目录，复制SRC中所有文件至DEST中\n                DEST存在：\n                    DEST是文件：报错\n                    DEST是目录：复制SRC中所有文件至DEST中\n        cp SRC...(多个文件) DEST\n            DEST必须存在且为目录\n        常用选项\n        -i：交互式\n        -r，-R：递归复制目录及内部的所有内容\n        -a：归档\n            -d：--no-dereference --preserv=links\n            --preserv\n                mode：权限\n                ownership：属组\n                timestamp：时间戳\n                links\n                xattr\n                context\n                all\n        -p：--preserv=mode，ownership，timestamp\n        -v：--verbose\n        -f：--force(很危险)\n    2.mv(移动)\n        同理\n    3.rm(删除)\n        -i: 交互式\n        -r(recurs)：递归式\n        -f：强制\n    4.nano\n### bash的基础特性(2)\n    1.命令别名(alias)\n        通过alias实现\n        (1)alias\n           显示当前可用\n        (2)alias NAME=\'VALUE\'\n    注意：定义别名只对当前shell有效，永久有效应定义在配置文件中\n        仅对当前用户：~/.bashrc\n        对所有系统：/etc/bashrc\n        bash重读配置文件\n            source /path/to/config_file\n            . source /path/to/config_file\n        撤销别名(alias)\n            alias NAME\n            如果别名与命令重合则使用/COMAN\n    2.glob\n        (1)*\n            任意长度的任意字符\n            a*b：aab，a123b\n        (2)?\n            任意单个字符\n            a?b:aab,a2b\n        (3)[]\n            匹配指定范围内的任意单个字符\n            [0-9]\n            [A-Z]：不区分大小写\n            [a-z]: 大写字母\n        (4)[^]\n            匹配指定范围外的任意单个字符\n                [^0-9]\n        专用字符合集：\n        [:alnum:]  [:alpha:]  [:blank:] [:cntrl:]\n       [:digit:]  [:graph:]  [:lower:]  [:print:]\n       [:punct:]  [:space:]  [:upper:]  [:xdigit:]\n    3.bash的快捷键\n        Ctrl+l：清屏，相当于clear\n        Ctrl+a：跳转至命令开始处\n        Ctrl+c：取消命令\n        Ctrl+u：删除命令行首至光标的内容\n        Ctrl+k：删除光标至尾部的内容\n    4.bash的I/O重定向及管道\n        程序：指令加数据\n            读入数据：Input\n            输出数据：Output\n        打开的文件都有一个fd：file descriptor(文件描述符)\n        标准输入：keyboard，0\n        标准输出：monitor，1\n        标准错误输出：monitor，2\n        \n        I/O重定向：改变标准位置\n        输出重定向：\n            COMMAND > NEW_pos, COMMAND >> NEW_POS\n            >: 覆盖重定向，目标文件中的原有内容会被清除\n            >>: 追加重定向，新内容会追加至目录文件尾部\n            \n            set -C：禁止将内容覆盖至已有文件中\n                强制覆盖：COMMAND >| NEW_pos\n            set +C：取消禁止覆盖\n        2>: 覆盖重定向错误输出数据流\n        2>>: 追加重定向错误输出数据流\n        \n        标准输出和错误输出各自定向至不同的位置\n            COMMAND > /path/to/file.out 2> /path/to/error.out\n        合并标准输出和错误输出各自不同位置\n            &>: 覆盖重定向\n            &>>: 追加重定向\n            COMMAND > /path/to/file.out> &1\n            COMMAND >> /path/to/file.out>> &1\n        输入重定向：\n            tr：转换或删除字符串\n        Documentation <<\n            cat << EOF\n            cat > /path/to/somefile\n        管道：\n            COMMAND1 | COMMAND2 | COMMAND3 |.....\n            最后一个命令在当前shell进程中执行\n            tee：在屏幕上输出且输入指定文件\n                tee [option]... [file]\n                示例：echo \"$PATH\" | tee temp/tee.out | tr \'a-z\' \'A-Z\'\\\\将环境变量输出之文件中且在屏幕上将小写转换为大写输出\n    文件类处理命令：\n        wc(world count)：计数\n            -l：line\n            -w：world\n            -c：characters\n        cut：切片处理\n            -d \'分隔符\': 默认为空格\n            -f FILES：\n                #：第#个字段\n                #,#: 离散的的字段\n                #-#：多个字段\n            示例：cut -d \':\' -f1,7 /etc/passwd(按文件中的:切出输出1和7片)\n### 用户和组管理\n    资源分配：\n        Authentication：认证\n        Authorization：授权\n        Accouting：审计\n    Linux用户：Username/UID\n        管理员：root，0\n        普通用户：\n            系统用户：守护进程\n            登入用户：\n    Linux组：Groupname/GID\n        管理员组：root，0\n        普通组：\n            系统组\n            普通组\n    Linux安全上下文：\n        运行中的程序：进程\n            以进程发起者的身份运行：\n                root\n                other\n    Linux组的类别：\n        用户的基本组(主组):\n            组名同用户名，且仅包含一个用户：私有组\n    Linux用户和组相关的配置文件：\n        /etc/passwd: 用户及其属性信息\n            name:password:UID:GID:GECOS:directory:shell\n        /etc/group: 组及其属性信息\n            group_name:password:GUI:user_list\n        /etc/shadow: 用户密码及相关属性\n            用户名：加密了的密码\n                加密使用单项加密(加密不可逆)\n                加密方式：\n                    md5：128bit\n                    sha1：160bit\n                    sha224：224bit\n                    sha256：256bit\n                    sha384：384bit\n                    sha512：512bit\n                雪崩效应，定长输出\n        /etc/gshadow: 组密码及相关属性\n    用户和组相关的管理命令\n        用户创建：useradd\n            -u UID：定义在/etc/login.defs\n            -g GID: 指明用户所处的基本组\n            -c \"ZHUSHI\": 注释\n            -d /path/to/home：以指定的路径为家目录\n            -s SHELL：指明用户默认的shell\n            -G GROUP：为用户指明附加组\n        默认值设定在：/etc/default/useradd文件中',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2019-07-05 15:49:53','2020-11-29 11:45:11',0),(9,'Linux英语大全','```c\n#pragma warning(disable:4996)\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\nstruct Book\n{\n	char name[128];\n	//char writter[40];\n	struct Book *next;//指向自身\n};\nvoid getinput(struct Book *book)\n{\n	printf(\"输入书名：\\n\");\n	scanf(\"%s\", book->name);\n	/*printf(\"输入作者：\\n\");\n	scanf(\"%s\", book->writter);*/\n}\nstruct Book *addBook(struct Book *library)//头插法\n{\n	struct Book *p;\n	p = malloc(sizeof(struct Book));\n	if (p == NULL)\n	{\n		printf(\"程序错误，已退出\");\n		exit(1);\n	}\n	getinput(p);\n	p->next = library;\n	return p;\n}\nvoid addBook2(struct Book **library)//头插法 (使用指针的指针传入library的地址）\n{\n	struct Book *p;\n	p = malloc(sizeof(struct Book));\n	if (p == NULL)\n	{\n		printf(\"程序错误，已退出\");\n		exit(1);\n	}\n	getinput(p);\n	p->next = *library;\n	*library = p;\n}\nvoid addBook3(struct Book *library)//头插法（使用指针转递）\n{\n	struct Book *p;\n	p = malloc(sizeof(struct Book));\n	if (p == NULL)\n	{\n		printf(\"程序错误，已退出\");\n		exit(1);\n	}\n	getinput(p);\n	if (library == NULL)\n	{\n		p->next = NULL;\n		library->next = p;\n	}\n	else\n	{\n		p->next = library->next;\n		library->next = p;\n	}\n}\nvoid addBookT(struct Book **library)//尾插法\n{\n	struct Book *p, *temp;\n	p = malloc(sizeof(struct Book));\n	if (p == NULL)\n	{\n		printf(\"程序错误，已退出\");\n		exit(1);\n	}\n	getinput(p);\n	if (*library != NULL)\n	{\n		temp = *library;\n		while (temp->next != NULL)\n		{\n			temp = temp->next;\n		}\n		temp->next = p;\n		p->next = NULL;\n	}\n	else\n	{\n		*library = p;//头指针\n		p->next = NULL;\n	}\n	//return p;\n}\nvoid printBook(struct Book *library)\n{\n	for (; library != NULL; library = library->next)\n	{\n		printf(\"%s\\n\", library->name);\n	}\n}\nstruct Book *deleteBook(struct Book *library)\n{\n	char str[10];\n	struct Book *now, *pre;\n	printf(\"请输入要删除的书籍名称：\\n\");\n	scanf(\"%s\", str);\n	for (now = library, pre = NULL; now != NULL && (strcmp(now->name, str) != 0); pre = now, now = now->next);//查找\n	if (now == NULL)//没有找到符合条件的书籍\n	{\n		printf(\"未找到符合的书籍\\n\");\n		return library;\n	}\n	if (pre == NULL)//避开删除头节点的情况\n	{\n		library = library->next;\n	}\n	else//正常删除\n	{\n		pre->next = now->next;\n		free(now);\n	}\n	return library;\n}\nserchBook(struct Book *library)\n{\n	char str[30];\n	printf(\"请输入要寻找的书籍名称：\");\n	scanf(\"%s\", str);\n	for (; library != NULL; library = library->next)\n	{\n		if (!strcmp(library->name , str))//strcmp相等返回0\n		{\n			printf(\"书籍已找到！\\n\");\n		}\n		\n	}\n}\nint main()\n{\n	struct Book *library = NULL;\n	/*library = addBook(library);\n	library = deleteBook(library);*/\n	library = malloc(sizeof(struct Book));\n	addBook3(library);\n	addBook3(library);\n	printBook(library);\n	printf(\"进行实验\\n\");\n	return 0;\n}\n```',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2019-07-05 15:49:53','2020-11-29 11:45:11',0),(10,'项目部署','[TOC]\n### 解压\ntar命令位于/bin目录下，它能够将用户所指定的文件或目录打包成一个文件，但不做压缩。一般Linux上常用的压缩方式是选用tar将许多文件打包成一个文件，再以gzip压缩命令压缩成xxx.tar.gz(或称为xxx.tgz)的文件。<br>常用参数：<br>\n-c：创建一个新tar文件<br>\n-v：显示运行过程的信息<br>\n-f：指定文件名<br>\n-z：调用gzip压缩命令进行压缩<br>\n-t：查看压缩文件的内容<br>\n-x：解开tar文件<br>\n\n```\n打包：tar –cvf xxx.tar ./*\n打包并且压缩：tar –zcvf xxx.tar.gz ./*\n解包：tar –xvf xxx.tar\n解压缩：tar -zxvf xxx.tar.gz -C /usr/aaa\n\n```\n### 软件\n使用管道\n```\n查找软件：rpm -qa | grep 软件名\n卸载软件：rpm -e --nodeps 软件名\n安装：rpm -ivh 软件名.rpm\n```\n\n### MySQL\n安装由于依赖关系必须顺序安装\n#### 使用\nmysql需要进行root用户激活，密码在/var/log/mysqld.log里面，需要进行更改后才能使用<br>\n```\n更改root用户密码：alter user \'root\'@\'localhost\' identified by \'密码\';\n```\n#### 更改密码复杂度（默认为mid）\n```\n查看现在密码复杂度要求：SHOW VARIABLES LIKE \'validate_password%\';\n更改密码的要求： set global validate_password_policy=LOW;\n```\n#### 添加远程访问权限\nmysql中的用户信息都存放在mysql数据库中的user表<br>\n可以通过查询表的方式查看用户权限<br>\n```\n查卡用户的权限信息：select  User,authentication_string,Host from user;\n修改Host：update user set host=\'%\' where user=\'root\';\n刷新权限：flush privileges;\n```\n#### 关闭防火墙\n```\n关闭防火墙：systemctl stop firewalld.service\n查看防火墙状态：systemctl status firewalld.service\n```\n\n\n### Nginx\n实现反向代理，负载均衡，作为静态网页服务器\n#### 问题\n记得关闭防火墙<br>\n更改日志位置否则无法启动<br>\n#### 反向代理\n\n```\ngraph LR\nA[浏览器]-->|192.168.2.104|B[Nginx]\nB-->|192.168.2.104:8080|C[tomcat服务器1]\nB-->|192.168.2.104:8080|D[tomcat服务器2]\n```\n\n修改配置文件<br>\n```\n    upstream tomcat-travel {\n    	   server 192.168.2.104:8080;\n    }\n\n    server {\n        listen       80;# 默认的端口号\n        server_name  localhost;# 域名\n        location / {\n            # root   index;# 默认的资源文件夹\n            proxy_pass http://tomcat-travel;\n            index  index.html index.htm;# 默认访问的资源\n        }\n```\n#### Windows操作命令\n```\nstart nginx 开启服务\nnginx -s quit 优雅关闭服务\nnginx -s reload 重新加载配置文件\nnginx -t 检查配置文件\n```\n浏览器输入：192.168.2.104进入tomcat首页，192.168.2.104/travel进入项目\n#### 负载均衡\n使用三个tomcat<br>\n权重默认为1<br>\n```\n    upstream tomcat-travel {\n    	   server 192.168.2.104:8080 weight=2;\n    	   server 192.168.2.104:8081;\n    	   server 192.168.2.104:8082;\n    }\n```',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2020-07-19 16:54:16','2020-11-29 11:45:11',0),(11,'gayhub入门','# gayhub使用方法\ngit可使用Linux命令<br>\n1.pwd查看当前目录\n### 初始化\n1.设置用户名及邮箱<br>\n```python\n    git config --global user.name\'roderickxing\'\n```\n2.设置邮箱<br>\n```python\n    git config --global user.email \'3097934536@qq.com\'\n```\n### 初始化一个新的Git仓库\n1.创建文件夹<br>\n```\n    mkdir (file)文件夹名\n```\n2.删除文件夹<br>\n```\n    rm -r 文件夹名\n```\n3.初始化文件夹<br>\n```\n    git init(存储仓库信息)\n```\n### 简单命令\n1.创建文件<br>\n```\n    touch temp.py\n```\n2.删除文件\n```\n    rm temp.py\n```\n3.查看状态\n```\n    git status\n```\n4.将文件从工作区添加到暂存区\n```\n    git add temp.py\n```\n5.将文件从暂存区添加到仓库\n```\n    git commit -m \'添加描述\'\n```\n6.',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2019-07-05 15:49:53','2020-11-29 11:45:11',0),(12,'github进阶','### 清除缓存\n```\ngit rm -r --cached .\ngit add .\ngit commit\n```\n### 查看分支\n```\ngit branch -a   查看所有的分支\ngit branch 查看现在所在分支\n```\n### 建立分支\n```\ngit checkout -b newbranch   创建本地分支并切换到新创建的分支\ngit chechout branch 切换分支\ngit push origin HEAD -u 将新的分支推到远程仓库\n```\n### 合并分支\n```\ngit checkout 接收修改的分支\ngit merge 分支名\n```\n### 推送分支\n```\ngit push 远程主机名 本地分支名:远程分支名\ngit push origin --delete master    删除指定的远程分支\n```',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2020-04-18 21:05:31','2020-11-29 11:45:11',0),(13,'开学事项','### 待办事项\n#### 开学前准备工作\n\n- [ ] 新生见面会\n    - [ ] 申请教室\n    - [ ] 零食购买\n    - [x] 制作新生见面会ppt</br>\n        1.给大家展示学习的方向</br>\n        2.为大家介绍我们的人员安排</br>\n        3.向大家表达我们协会会培养高水平人才的意愿\n    - [ ] 每个人准备好介绍词\n- [ ] 宣传单\n- [ ] 海报（不知道要不要）\n- [ ] 协会宣传海报\n- [x] 向社联申请贴吧发帖\n- [ ] 微博及qq的管理方案\n- [ ] 吃饭（看情况）\n\n#### 开学后工作安排\n\n- [ ] 宣传\n- [ ] 缴纳费用\n- [ ] 第一次授课准备\n    - [ ] 制作签到表\n    - [ ] ppt介绍协会\n    - [ ] 申请机房\n    - [ ] 技术部准备课程\n- [ ] 神秘部门招募计划\n    - [ ] 选拔方式',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2019-08-30 12:54:50','2020-11-29 11:45:11',0),(14,'纳新准备','- [x] 宣传单(未打印)\n- [x] 海报(未打印)\n- [ ] 新纳成员登记表\n- [ ] 会费收集账户\n- [ ] 2019计算机协会群\n    - 只有缴纳了会费的同学才能入群\n- [ ] 信工系下班宣传申请\n    - 其他系看着办\n    - [ ] 下班宣传内容\n- [ ] 棚子租借（没下雨就懒得弄）\n    - 社联那边有有通知后因立即去搬桌椅\n- [ ] 教室申请1116（十有八九弄不到，要个有个plan B）\n- [ ] 电源申请\n- [ ] 下营宣传（随机应变）',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2019-09-01 19:50:02','2020-11-29 11:45:11',0),(15,'在西部的那些日子','# 在西部的那些日子\r\n&emsp;&emsp;对于荒野大镖客：救赎2的入坑有三点一是因为R星就是R星，另一部分是应为塞尔达旷野之息续作开发的消息谈到了，借鉴了荒野大镖客2中剧情对于整个游戏过程的重要性。剧情对于大表哥2来说是十分重要的，剧情发展对我来说通常是无所谓的，但是这次，也是唯一一次我在游戏中严重受到剧情的干扰，在玩之前不小心在B站云通关了，通常来说这没什么，但是对于荒野大镖客2来讲影响实在太大了。谁是叛徒，谁在哪里要领盒饭了，全都知道，太影响游戏体验，但是这应该不是我最后一次云通关，因为B站上剧情的诱惑力实在是太大了。<br>\r\n&emsp;&emsp;还有一点非常吸引我的毫无疑问是它的表现力，荒野大镖客2的表现力真的太强了，R星把range引擎发挥到了极致，创造出来了下一个世代的游戏，荒野大镖客2在ps4的末代发布，就像当年的gta5在ps3的末代发布一样，虽然pc版本跳了很久的票，但好歹摘了个“教科书般的优化”的游戏名号，也让千千万万平民玩家可以去洛圣都闯荡一下，当年也辛亏有这样的优化才能让我的gt920m能在25帧下“流畅”运行。荒野大镖客2的优化肯定是算不上好的，但是再怎么说也比gta4要强太多了，gta4在当年就是不想让你玩的存在，据说就连当年的神机都无法做到欢乐游玩，虽然我不太清楚哪个时代，但是今天的荒野大镖客2好歹能玩2080力大飞砖，而我的gtx1650也终于能打破cemu模拟器50%占用的枷锁（模拟器比较看重cpu,有来自cpu方面的瓶颈），但也只能在30帧下走中高了，优化就是中下的水平。但还有很多玩家遇到了根本无发愉快玩耍的情况（闪退，打不开之类的）。大表哥2在这方面倒是没太为难我，就是开始的时候虚拟内存设置太小了导致闪退。坐在马上看着阳光在树林中产生的丁达尔效应，在没有光线追踪的大表哥里难道还不满足吗？<br>\r\n&emsp;&emsp;在剧情上面荒野大镖客：救赎2其实是荒野大镖客：救赎1的前传，虽然玩2不需要1的剧情但其中联系还算比较紧密。在游戏的结尾上，2的处理方式与1如出一辙。R星在游戏的理念上认为开放世界就是要在结束任务后还能继续对世界进行探索，所以在亚瑟完成他的救赎之路后，还需要使用约翰完成复仇就像在1中约翰完成成他的救赎之后，需要杰克完成复仇一样。当你在2中看着陌生的约翰时就像1中看着陌生的杰克一样。而荒野之息在结尾上的处理就感觉很有问题。<br>\r\n&emsp;&emsp;荒野大镖客：救赎2在国内给我的感觉就是典型的叫好不叫座，可能是因为我们这边对于西部文化不感冒，或许又是因为大多数玩家太过于浮躁，完全无法理解这种慢节奏的，骑马模拟器游戏。在所有人都嚷嚷着要gta6的时候，荒野大镖客：救赎2并没有得到应有的拥护度，gta5还在卖呢！哦我的上帝你可瞧瞧吧，那可是13年的游戏啊。',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2020-02-13 23:09:37','2020-11-29 11:45:11',0),(16,'动态规划初见','## 什么是Dynamic Programing?\n计算的结果对下一次计算产生影响  \n\n## 题目\n> 669.换硬币--lintcode  \n给出不同面额的硬币以及一个总金额. 写一个方法来计算给出的总金额可以换取的最少的硬币数量. 如果已有硬币的任意组合均无法与总金额面额相等, 那么返回 -1.  \n样例1  \n输入：\n[1, 2, 5]  \n11  \n输出： 3  \n解释： 11 = 5 + 5 + 1  \n\n### 递归\n划分子问题\n```java\nclass Solution {\n    /**\n     * @param x 凑成的数目\n     * @return 最少使用多少个硬币\n     */\n    public Integer coin(int x) {\n        int result = Short.MAX_VALUE;\n        if (x == 0) {\n            return 0;\n        }\n        if (x >= 2) {\n            result = Math.min(coin(x - 2) + 1, result); //加上最后的2元硬币\n        }\n        if (x >= 5) {\n            result = Math.min(coin(x - 5) + 1, result); //加上最后的5元硬币\n        }\n        if (x >= 7) {\n            result = Math.min(coin(x - 7) + 1, result); //加上最后的7元硬币\n        }\n        return result;\n    }\n}\n```\n\n### 动态规划\n步骤：  \n. 确定状态  \n. 转移方程  \n. 初始条件和边界情况  \n. 计算顺序  \n使用数组存储每一个硬币数的最优解，而现在的最优解从前面寻找  \n```java\nclass Solution {\n    /**\n     * @param coins  [2,5,7]\n     * @param amount 数量\n     * @return\n     */\n    public Integer coinChange(int[] coins, int amount) {\n        int[] f = new int[amount + 1];  //the list of each result\n        //init\n        f[0] = 0;\n        for (int i = 1; i < f.length; ) {\n            f[i] = Short.MAX_VALUE;\n            //the best result for each number\n            for (int j = 0; j < coins.length; j++) {\n                if (i >= coins[j] && f[i - coins[j]] != Short.MAX_VALUE) {\n                    f[i] = Math.min(f[i - coins[j]] + 1, f[i]);\n                }\n            }\n        }\n        return f[amount] == Short.MAX_VALUE ? -1 : f[amount];\n    }\n}\n```\n\n## 题目\n> 62.不同路径  \n一个机器人位于一个 m x n网格的左上角（起始点在下图中标记为“Start” ）。  \n机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。  \n问总共有多少条不同的路径？\n![image](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/robot_maze.png)\n\n### 确定状态\n最后一步，划分子问题  \n最后一步为：**在[M-1][N]上向右移动一格 或 在[M][N-1]上向下移动一格**  \n那么如果有X种方法走到[M-1][N]，有Y种方法走到[M][N-1]，走到[M][N]有X+Y种方式  \n状态：有f[i][j]种方式从左上角到i,j  \n\n### 转移方程\n**f[i][j] = f[i - 1][j] + f[i][j - 1]**\n\n### 初始条件和边界情况\nf[0][0] = 1    \nf[0][j] = 1 或 f[i][0]\n\n### 计算顺序\n由于所需要计算的格子需要上面和左边的格子，所以采用从左到右从上到下的顺序',1,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2020-10-28 16:23:41','2020-11-29 11:45:11',0),(17,'回溯','## 概念\n回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择。\n\n## 题目\n> 78. 子集  \n给定一组不含重复元素的整数数组nums，返回该数组所有可能的子集（幂集）。  \n说明：解集不能包含重复的子集。\n\n示例:\n```\n输入: nums = [1,2,3]\n输出:\n[\n  [3],\n  [1],\n  [2],\n  [1,2,3],\n  [1,3],\n  [2,3],\n  [1,2],\n  []\n]\n```\n## 题解\n![image](https://pic.leetcode-cn.com/d8e07f0c876d9175df9f679fcb92505d20a81f09b1cb559afc59a20044cc3e8c-%E5%AD%90%E9%9B%86%E9%97%AE%E9%A2%98%E9%80%92%E5%BD%92%E6%A0%91.png)\n子集、组合类问题，关键是用一个start参数来控制选择列表！！  \n最后回溯六步走：  \n①画出递归树，找到状态变量(回溯函数的参数)，这一步非常重要   \n②根据题意，确立结束条件  \n③找准选择列表(与函数参数相关),与第一步紧密关联  \n④判断是否需要剪枝  \n⑤作出选择，递归调用，进入下一层  \n⑥撤销选择  \n```cpp\nclass Solution {\npublic:\n    vector<vector<int>> subsets(vector<int> &nums) {\n        vector<vector<int>> result;\n        vector<int> path;\n        this->backTrace(nums, path, 0, result);\n        return result;\n    }\n    /**\n     * \n     * @param nums 数字集合\n     * @param path 路径\n     * @param start 每一层开始的下标\n     * @param result 结果\n     */\n    void backTrace(vector<int> nums, vector<int> &path, int start, vector<vector<int>> &result) {\n        result.push_back(path);\n        for (int i = start; i < nums.size(); ++i) {\n            path.push_back(nums[i]);\n            this->backTrace(nums, path, i + 1, result); //继续寻找下一层的组合\n            path.pop_back();    //撤销选择\n        }\n    }\n};\n```\n\n力扣详细解释回溯：https://leetcode-cn.com/problems/subsets/solution/c-zong-jie-liao-hui-su-wen-ti-lei-xing-dai-ni-gao-/',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2020-10-30 17:25:30','2020-11-29 11:45:11',0),(18,'散列表','## 概念\n含有键值对key value可以快速找到元素  \n\n## 简单实现\n使用列表存放数据  \n使用哈希函数计算储存的下标：通常为 **val % nums.size()**  \n由于使用模除所以会遇到位置冲突，解决方法有：\n\n1. 链表  \n\n![image](https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=3994694613,35372666&fm=26&gp=0.jpg)\n\n2. 开放地址  \n    a. 线性探测  \n    b. 平方探测  \n    c. 双哈希  \n\n## 题目\n> 381. O(1) 时间插入、删除和获取随机元素 - 允许重复  \n设计一个支持在平均 时间复杂度 O(1) 下，   执行以下操作的数据结构。  \n注意: 允许出现重复元素。  \ninsert(val)：向集合中插入元素 val。  \nremove(val)：当 val 存在时，从集合中移除一个 val。  \ngetRandom：从现有集合中随机获取一个元素。每个元素被返回的概率应该与其在集合中的数量呈线性相关。 \n\n示例:  \n```\n// 初始化一个空的集合。\nRandomizedCollection collection = new RandomizedCollection();\n\n// 向集合中插入 1 。返回 true 表示集合不包含 1 。\ncollection.insert(1);\n\n// 向集合中插入另一个 1 。返回 false 表示集合包含 1 。集合现在包含 [1,1] 。\ncollection.insert(1);\n\n// 向集合中插入 2 ，返回 true 。集合现在包含 [1,1,2] 。\ncollection.insert(2);\n\n// getRandom 应当有 2/3 的概率返回 1 ，1/3 的概率返回 2 。\ncollection.getRandom();\n\n// 从集合中删除 1 ，返回 true 。集合现在包含 [1,2] 。\ncollection.remove(1);\n\n// getRandom 应有相同概率返回 1 和 2 。\ncollection.getRandom();\n```\n\n## 使用哈希表+链表实现\nlist存放存入的数据，table为存储数据的哈希表  \n冲突使用链表解决，数据采用IntegerNode结构体存储  \ntable为存放IntegerNode指针的数组  \n```cpp\nclass RandomizedCollection {\nprivate:\n    struct IntegerNode {\n        int val;\n        IntegerNode *next;\n\n        IntegerNode(int val) : val(val), next(nullptr) {}\n    };\n\n    list<int> nums;    //存放所有数字--为了获取随机值\n    IntegerNode *table[100];    //使用散列表存放数字\n    int capacity;   //存放的最大容量与vector的容量有关\n\n\npublic:\n\n    /** Initialize your data structure here. */\n    RandomizedCollection() {\n        this->capacity = 100;\n        for (auto &i : table) {\n            i = nullptr;\n        }\n    }\n\n    /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */\n    bool insert(int val) {\n        int index = this->getIndex(val);\n        IntegerNode *node = table[index];\n        if (node == nullptr) {  //当前散列表下标没有元素\n            table[index] = new IntegerNode(val);\n            nums.push_back(val);\n            return true;\n        } else {    //当前散列表下标有元素--头插入\n            bool flag = true;\n            //首先进行遍历查看是否含有相同的元素\n            IntegerNode *head = node;\n            while (head != nullptr) {\n                if (head->val == val) {\n                    flag = false;\n                }\n                head = head->next;\n            }\n            //头插法添加元素\n            table[index] = new IntegerNode(val);\n            table[index]->next = node;\n            nums.push_back(val);\n            return flag;\n        }\n    }\n\n    /** Removes a value from the collection. Returns true if the collection contained the specified element. */\n    bool remove(int val) {\n        bool flag = false;\n        //查看是否有可以删除的元素\n        list<int>::iterator tmp;\n        for (auto it = nums.begin(); it != nums.end(); ++it) {\n            if (*it == val) {\n                tmp = it;   //列表中的需要被删除元素的指针\n                flag = true;\n            }\n        }\n        //头插法链表\n        if (flag) {\n            int index = this->getIndex(val);\n            IntegerNode *node = table[index];\n            table[index] = new IntegerNode(val);\n            table[index]->next = node;\n\n            nums.erase(tmp);    //删除列表中的元素\n        }\n        return flag;\n    }\n\n    /** Get a random element from the collection. */\n    int getRandom() {\n        int index = rand() % nums.size() - 1;\n        auto it = nums.begin();\n        for (; index >= 0; ++it) {\n            index--;\n        }\n        return *it;\n    }\n\n    int getIndex(int val) {\n        return abs(val) % this->capacity;\n    }\n};\n```',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2020-11-01 21:35:11','2020-11-29 11:45:11',0),(19,'OOP七大原则','## 开放-封闭原则\n**对修改关闭，对扩展开放**\n\n## 单一职责原则\n**就一个类而言，应当只有一个引起它变化的原因（对于后期更改）**\n\n## 依赖倒转原则\n面向接口编程<br>\n**抽象不应该依赖细节，而细节应该依赖与抽象**\n\n## 里氏替换原则\n**子类必须能完全替换掉父类**<br>\n只有当子类可以替换掉父类，父类才能真正被复用，而子类也能够在父类的基础上添加新的行为（子类用于扩展父类）',1,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2020-06-07 21:20:31','2020-11-29 11:45:11',0),(20,'代理模式','## 概念\n为某个对象提供一个代理，以控制对这个对象的访问\n![image](https://img-blog.csdn.net/20170629213938736?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYnJpYmx1ZQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)\n> 在遵循开放封闭原则的条件下，为一个CRUD服务添加日志功能\n\n## 实现\n接口：\n```java\npublic interface CRUD {\n    void create();\n\n    void retrieve();\n\n    void update();\n\n    void delete();\n}\n```\n被代理的对象：\n```java\npublic class Service implements CRUD {\n    @Override\n    public void create() {\n        System.out.println(\"添加\");\n    }\n\n    @Override\n    public void retrieve() {\n        System.out.println(\"查找\");\n    }\n\n    @Override\n    public void update() {\n        System.out.println(\"更新\");\n    }\n\n    @Override\n    public void delete() {\n        System.out.println(\"删除\");\n    }\n}\n```\n代理：\n```java\npublic class ServiceProxy implements CRUD {\n\n    Service service;\n\n    public void setService(Service service) {\n        this.service = service;\n    }\n\n    @Override\n    public void create() {\n        this.log();\n        service.create();\n    }\n\n    @Override\n    public void retrieve() {\n        this.log();\n        service.retrieve();\n    }\n\n    @Override\n    public void update() {\n        this.log();\n        service.update();\n    }\n\n    @Override\n    public void delete() {\n        this.log();\n        service.delete();\n    }\n\n    private void log() {\n        System.out.println(\"输出日志\");\n    }\n}\n```\n客户：\n```java\npublic class Main {\n    public static void main(String[] args) {\n        ServiceProxy serviceProxy = new ServiceProxy();\n        serviceProxy.setService(new Service());\n        serviceProxy.create();\n    }\n}\n```',3,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2020-08-11 23:21:05','2020-11-29 11:45:11',0),(21,'动态代理','## 概念\n利用**反射机制**在运行时创建代理类  \n整体框架与静态代理相同，只是在创建代理对象使用反射在运行时完成 \n\n## 实现\nJava的动态代理需要顶层接口：\n```java\npublic interface CRUD {\n    void create();\n\n    void retrieve();\n\n    void update();\n\n    void delete();\n}\n```\n原始对象：\n```java\npublic class Service implements CRUD {\n    @Override\n    public void create() {\n        System.out.println(\"添加\");\n    }\n\n    @Override\n    public void retrieve() {\n        System.out.println(\"查找\");\n    }\n\n    @Override\n    public void update() {\n        System.out.println(\"更新\");\n    }\n\n    @Override\n    public void delete() {\n        System.out.println(\"删除\");\n    }\n}\n```\n\n## 创建代理对象\n使用Proxy下面的newProxyInstance方法，返回一个代理对象  \n> 获取代理对象需要的参数:  \nloader – the class loader to define the proxy class  \ninterfaces – the list of interfaces for the proxy class to implement  \ninvocationHandler – the invocation handler to dispatch method invocations to  \n\nInvocationHandler -- 调用处理器\n> InvocationHandler is the interface implemented by the invocation handler of a proxy instance.  \nEach proxy instance has an associated invocation handler. When a method is invoked on a proxy instance, the method invocation is encoded and dispatched to the invoke method of its invocation handler\n\n> 这个接口由代理对象实例的invocation handler实现  \n没一个代理实例都有一个关联的InvocationHandler，当代理对象的方法被调用时，方法的调用被编码并转发到自己InvocationHandler的invoke方法上  \n\n## 实现\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Service service = new Service();\n        CRUD crud = (CRUD) Proxy.newProxyInstance(service.getClass().getClassLoader(), service.getClass().getInterfaces(), new InvocationHandler() {\n            @Override\n            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n                if (!method.getName().equals(\"toString\"))\n                    System.out.println(\"记录日志\");\n                return method.invoke(service, args);\n            }\n        });\n        crud.create();\n    }\n}\n```',1,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2020-08-12 18:18:09','2020-11-29 11:45:11',0),(22,'单例模式','[TOC]\n## 概念\n在多次创建对象只允许一个实例，在创建空间占用大的对象的时候可以节省空间\n\n## 饿汉式单例模式\n```java\n/*饿汉式单例模式*/\npublic class HungryMan {\n    //构造器私有化，防止在外部new\n    private HungryMan() {\n\n    }\n\n    private final static HungryMan hungryMan = new HungryMan(); //浪费空间\n\n    public static HungryMan getInstance() {\n        return hungryMan;\n    }\n}\n```\n在饿汉式单例模式中，在实例化之前就会创建对象，所以即便不使用对象内存空间也会被浪费。\n## 简单懒汉式单例模式\n```java\n/*懒汉式单例模式*/\npublic class LazyMan {\n    private LazyMan() {\n    \n    }\n\n    private static LazyMan lazyMan;\n\n    /*DCL双重检测锁模式*/\n    public static LazyMan getInstance() {   //+锁\n        if (lazyMan == null) {\n            lazyMan = new LazyMan();    //在需要的时候进行实例化\n        }\n        return lazyMan;\n    }\n}\n```\n这种方式不是线程安全的，在多线程的时候会打破单例模式\n## DCL双重检测锁单例模式（Double-Checked Locking）\n```java\npublic class LazyMan {\n    private LazyMan() {\n\n    }\n\n    private volatile static LazyMan lazyMan;\n\n    /*DCL双重检测锁模式*/\n    public static LazyMan getInstance() {   //+锁\n        if (lazyMan == null) {\n            synchronized (LazyMan.class) {\n                if (lazyMan == null)\n                    lazyMan = new LazyMan();    //在需要的时候进行实例化\n            }\n        }\n        return lazyMan;\n    }\n}\n```\n使用同步代码块解决了多线程下单例模式失效的问题，但是如果使用暴力反射创建对象还是可以打破单例模式  \n**有关于volatile：**  \n> lazyMan = new LazyMan();  \n对象创建过程（非原子性）  \n1.分配内存空间  \n2.执行构造方法，初始化对象  \n3.将对象指向这个内存空间  \n如果说发生指令重排执行顺序为132那么当另一个线程B开始执行 (lazyMan == null) 时判断结果就会为假，那么就会返回空对象  \n\n这里如果没有使用volatile修饰的话，会导致执行顺序不是123，可能是132，导致对象创建还没有完全创建完毕，但是外部执行到if(instance==null)这里的时候，已经不为空了，会直接返回，导致返回版初始化状态的实例，发生错误。\n### 使用反射打破单例模式\n拿到构造器就是无敌\n```java\n//使用双反射打破单例模式\nConstructor<?>[] constructors = LazyMan.class.getDeclaredConstructors();\nConstructor<?> constructor = constructors[0];\nconstructor.setAccessible(true);\nLazyMan lazyMan = (LazyMan) constructor.newInstance();\nLazyMan lazyMan2 = (LazyMan) constructor.newInstance();\nSystem.out.println(lazyMan);\nSystem.out.println(lazyMan2);\n```\n\n## 静态内部类单例模式\n```java\npublic class InnerSingleton {\n    private static class Instance { //只有当外部类需要使用，内部类才会加载\n        private static final Instance instance = new Instance();\n    }\n\n    public static Instance getInstance() {\n        return Instance.instance;\n    }\n}\n```\n静态内部类的变量被调用时，外部类进行了加载（注：外部类中的静态代码块中的代码执行了），但是并没有被初始化（注：外部类的构造方法并没有执行），且静态内部类也完成了加载，由于是静态属性所以不会进行第二次加载  \n缺点：创建对象时无法传入参数 \n\n## 枚举实现单例模式\n枚举在java中默认就是单例的\n```java\npublic enum EnumSingleton {\n    INSTANCE,OBJECT;\n\n    public String getName() {\n        return \"Name\";\n    }\n\n    public static EnumSingleton getInstance() {\n        return INSTANCE;\n    }\n}\n```\n例子：\n```java\npublic enum Test {\n    INSTANCE;\n\n    private String name;\n    private int age;\n\n    public String getName() {\n        return this.name;\n    }\n\n    public static Test getInstance() {\n        return INSTANCE;\n    }\n}\n```\n同时也无法通过反射拿到私有的构造器\n```java\nConstructor<EnumSingleton> declaredConstructor = EnumSingleton.class.getDeclaredConstructor(String.class, int.class);\ndeclaredConstructor.setAccessible(true);\ndeclaredConstructor.newInstance();\n```\n结果：\n```\njava.lang.IllegalArgumentException: Cannot reflectively create enum objects\n\n	at java.lang.reflect.Constructor.newInstance(Constructor.java:417)\n```',5,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2020-11-17 11:06:21','2020-11-29 11:45:11',0),(23,'原型模式','[TOC]\n## 概念\n通过一个已经产生的实例，复制出另一个副本\n\n## Java中的实现\n在Java中无法对内存进行直接操作，但是却可以调用来自c++的原生方法，也就是native原生方法\n```java\n protected native Object clone() throws CloneNotSupportedException;\n```\n通过这种方法可以直接从内存中复制二进制数据从而产生一份相同的对象\n\n### 原型模式\n需要拷贝的类应该实现Cloneable接口：\n```java\npackage prototype;\n\nimport java.util.Date;\n\n/*原型模式*/\npublic class Video implements Cloneable {\n    private String name;\n    private Date date;\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public Date getDate() {\n        return date;\n    }\n\n    public void setDate(Date date) {\n        this.date = date;\n    }\n\n    @Override\n    public String toString() {\n        return \"Video{\" +\n                \"name=\'\" + name + \'\\\'\' +\n                \", date=\" + date +\n                \'}\';\n    }\n\n    @Override\n    public Object clone() throws CloneNotSupportedException {\n        Object object = super.clone();  //原生方法\n        Video video = (Video) object;\n        video.date = new Date();\n        System.out.println(video.date.hashCode());\n        return object;\n    }\n}\n```\n拷贝操作：\n```java\nVideo video2 = (Video) video1.clone();\n```\n### 浅拷贝\n浅拷贝：基础数据类型的修改互不影响，而引用类型修改后是会有影响的\n![image](https://upload-images.jianshu.io/upload_images/8878793-61eb6dbc8885a9bc.png?imageMogr2/auto-orient/strip|imageView2/2/w/670/format/webp)  \n在java的clone方法中，对于所拷贝的对象本身是创建一个新的对象实现拷贝，但是对于对象中的引用类型属性是直接引用（基础数据类型是直接传递，包括封装类），当引用的值发生改变时属性会跟着改变。\n```java\nVideo videoA = new Video();\nDate date = new Date();\nvideoA.setDate(date);\nVideo videoB = (Video) videoA.clone();\nSystem.out.println(videoA.hashCode());\nSystem.out.println(videoB.hashCode());\nSystem.out.println(videoA.getDate());\nSystem.out.println(videoB.getDate());\n\ndate.setTime(1L);\nSystem.out.println(videoA.getDate());\nSystem.out.println(videoB.getDate());\n```\n结果：\n```\n54495403\n665372494\nMon Jul 27 23:52:46 CST 2020\nMon Jul 27 23:52:46 CST 2020\nThu Jan 01 08:00:00 CST 1970\nThu Jan 01 08:00:00 CST 1970\n```\n\n## C++中的实现\n> 在C++中如果不写拷贝函数，编译器会为我们添加拷贝函数（添加的拷贝函数为浅拷贝，指针类型的数据直接传递指针，使用同一块储存空间）\n### 浅拷贝\n\n```c++\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\nclass Person {\npublic:\n    string name;\n    int *height;\n\n    Person(string name, int height) {\n        Person::name = name;\n        Person::height = new int(height);\n    }\n\n    /*析构函数*/\n    ~Person() {\n        delete height;  //释放在堆中申请的空间\n    }\n};\n\nvoid test() {\n    Person p1(\"roderick\", 170);\n    Person p2(p1);\n    cout << *p1.height << endl;\n    cout << *p2.height << endl;\n    /*函数结束调用后，栈区中的空间会被释放，先释放p1然后p2，先后调用析构函数*/\n    /*两次释放同一块内存空间报错*/\n}\n\nint main() {\n    test(); //调用此函数\n    return 0;\n}\n```\n\n### 深拷贝\n我们可以重写默认的拷贝函数，为堆区的变量重新申请新的内存空间  \n```c++\nclass Person {\npublic:\n    string name;\n    int *height;\n\n    Person(string name, int height) {\n        Person::name = name;\n        Person::height = new int(height);\n    }\n\n    Person(const Person &person) {\n        Person::name = person.name;\n        Person::height = new int(*person.height);   //为新的Person对象开辟新的堆储存空间\n    }\n\n    /*析构函数*/\n    ~Person() {\n        delete height;  //释放在堆中申请的空间\n    }\n};\n```',2,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2020-10-08 19:34:53','2020-11-29 11:45:11',0),(24,'工厂模式','[TOC]\n## 概念\n通过工厂创建对象，这样我们就不需要知道需要被创建对象的细节，只需要向工厂申请就行\n\n## 简单工厂模式\n通过静态方法生产对象，违反oop开放封闭原则，无法进行扩展，但是结构与代码简单<br>\n**最大优点在于工厂中含有逻辑判断，可以根据客户端动态选择实现类**\n```java\n/*静态工厂模式*/\npublic class StaticFactory {\n    public static Car getCar(String name) { //无法进行添加操作\n        if (\"奥迪\".equals(name)) {\n            return new Audi();\n        } else if (\"特斯拉\".equals(name)) {\n            return new Tesla();\n        } else {\n            return null;\n        }\n    }\n}\n```\n\n## 工厂方法模式\n方便扩展，但是结构更加复杂<br>\n工厂接口：\n```java\npublic interface MethodFactory {\n    Car getCar();\n}\n```\n通过工厂实现类创建对象：\n```java\npublic class TeslaFactory implements MethodFactory {\n    @Override\n    public Car getCar() {\n        return new Tesla();\n    }\n}\n```\n**客户端需要选择实例化哪个实现类，选择判断问题还是存在，只是从工厂中移到客户端**\n```java\nMethodFactory methodFactory = new TeslaFactory()    //根据情况变动\nCar car = methodFactory.getCar();\n```\n\n## 抽象工厂模式\n将工厂进一步抽象，成为工厂的工厂<br>\n使用抽象工厂模式一般要满足以下条件：\n1. 系统中有多个产品族，每个具体工厂创建同一族但属于不同等级结构的产品\n2. 系统一次只可能消费其中某一族产品，即同族的产品一起使用\n\n抽象工厂：\n```java\n/*抽象工厂，让不同产品等级的工厂继承接口*/\npublic interface AbstractFactory {\n    //产品族难扩展，产品等级易扩展\n    Phone producePhone();   //产品族\n\n    Router produceRouter();\n}\n```\n工厂实现：\n```java\npublic class HuaweiFactory implements AbstractFactory {\n    @Override\n    public Phone producePhone() {\n        return new HuaweiPhone();\n    }\n\n    @Override\n    public Router produceRouter() {\n        return new HuaweiRouter();\n    }\n}\n```\n![image](https://img-blog.csdnimg.cn/20190709103512538.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lleWF6aGlzaGFuZw==,size_16,color_FFFFFF,t_70)',1,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2020-06-04 22:28:09','2020-11-29 11:45:11',0),(25,'建造者模式','[TOC]\n## 概念\n通过建造者模式可以创建复杂对象，这些对象内部构建间的顺序通常是稳定的，但是对象内部的构建面临着复杂的变化<br>\n**将一个复杂对象的构建与表示分离，使得同样的构建过程可以创建不同的表示**\n## 建造者模式\n![image](https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=3243412804,4216446205&fm=26&gp=0.jpg)<br>\n指挥者（控制创建顺序）：\n```java\npublic class Director {\n    public Product getProduct(Builder builder) {\n        builder.buildA();\n        builder.buildB();\n        builder.buildC();\n        builder.buildD();\n        return builder.getProduct();\n    }\n}\n```\n抽象类接口（用于规范创建的每一个步骤，但是没有规范顺序）：\n```java\n/*抽象的建造者*/\npublic abstract class Builder {\n    abstract void buildA();\n    abstract void buildB();\n    abstract void buildC();\n    abstract void buildD();\n\n    abstract Product getProduct();\n}\n```\n实现类（实现创建步骤）：\n```java\npublic class Worker extends Builder {\n\n    private Product product;\n\n    public Worker() {\n        this.product = new Product();\n    }\n\n    @Override\n    void buildA() {\n        product.setA(\"地基\");\n    }\n\n    @Override\n    void buildB() {\n        product.setB(\"钢筋工程\");\n    }\n\n    @Override\n    void buildC() {\n        product.setC(\"铺电线\");\n    }\n\n    @Override\n    void buildD() {\n        product.setD(\"粉刷\");\n    }\n\n    @Override\n    Product getProduct() {\n        return product;\n    }\n}\n```\n产品：\n```java\n/*产品*/\npublic class Product {\n    private String A;\n    private String B;\n    private String C;\n    private String D;\n\n    public String getA() {\n        return A;\n    }\n\n    public void setA(String a) {\n        A = a;\n    }\n\n    public String getB() {\n        return B;\n    }\n\n    public void setB(String b) {\n        B = b;\n    }\n\n    public String getC() {\n        return C;\n    }\n\n    public void setC(String c) {\n        C = c;\n    }\n\n    public String getD() {\n        return D;\n    }\n\n    public void setD(String d) {\n        D = d;\n    }\n\n    @Override\n    public String toString() {\n        return \"Product{\" +\n                \"A=\'\" + A + \'\\\'\' +\n                \", B=\'\" + B + \'\\\'\' +\n                \", C=\'\" + C + \'\\\'\' +\n                \", D=\'\" + D + \'\\\'\' +\n                \'}\';\n    }\n}\n```\n创建：\n```java\nBuilder builder = new Worker();\nProduct product = new Director().getProduct(builder);\nSystem.out.println(product);\n```\n## 静态内部类建造者模式\n```java\npublic class Computer {\n\n    private String cpu;\n    private String mainBoard;\n    private String hardDisk;\n    private String displayCard;\n    private String power;\n    private String memory;\n\n    public Computer(ComputerBuilder computerBuilder){\n        this.cpu = computerBuilder.cpu;\n        this.mainBoard = computerBuilder.mainBoard;\n        this.hardDisk = computerBuilder.hardDisk;\n        this.displayCard = computerBuilder.displayCard;\n        this.power = computerBuilder.power;\n        this.memory = computerBuilder.memory;\n    }\n\n    @Override\n    public String toString() {\n        return \"Computer{\" +\n                \"cpu=\'\" + cpu + \'\\\'\' +\n                \", mainBoard=\'\" + mainBoard + \'\\\'\' +\n                \", hardDisk=\'\" + hardDisk + \'\\\'\' +\n                \", displayCard=\'\" + displayCard + \'\\\'\' +\n                \", power=\'\" + power + \'\\\'\' +\n                \", memory=\'\" + memory + \'\\\'\' +\n                \'}\';\n    }\n\n    public static class ComputerBuilder{\n\n        private String cpu;\n        private String mainBoard;\n        private String hardDisk;\n        private String displayCard;\n        private String power;\n        private String memory;\n\n        public ComputerBuilder buildCPU(String cpu){\n            this.cpu = cpu;\n            return this;\n        }\n        public ComputerBuilder buildMainBoard(String mainBoard){\n            this.mainBoard = mainBoard;\n            return this;\n        }\n        public ComputerBuilder buildHardDisk(String hardDisk){\n            this.hardDisk = hardDisk;\n            return this;\n        }\n        public ComputerBuilder buildDisplayCard(String displayCard){\n            this.displayCard = displayCard;\n            return this;\n        }\n        public ComputerBuilder buildPower(String power){\n            this.power = power;\n            return this;\n        }\n        public ComputerBuilder buildMemory(String memory){\n            this.memory = memory;\n            return this;\n        }\n        public Computer build(){\n            return new Computer(this);  //调用构造函数\n        }\n    }\n}\n```\n创建：\n```java\n//首先实例化静态内部类（静态内部类可以在外部类没有实例化的情况下实例化）\n//使用内部建造者创建对象\nComputer computer = new Computer.ComputerBuilder()\n        .buildCPU(\"i5\")\n        .buildDisplayCard(\"5\")\n        .buildHardDisk(\"hardDisk\")\n        .build();\nSystem.out.println(computer);\n```\n\n## 省略导演类\n```java\n/*抽象的建造者*/\npublic abstract class Builder {\n    public abstract Builder buildA();\n\n    public abstract Builder buildB();\n\n    public abstract Builder buildC();\n\n    public abstract Builder buildD();\n\n    public abstract ProductB getProduct();\n}\n```\n实现类：\n```java\npublic class Worker extends Builder {\n    ProductB productB;\n\n    public Worker() {\n        this.productB = new ProductB();\n    }\n\n    @Override\n    public Builder buildA() {\n        return this;\n    }\n\n    @Override\n    public Builder buildB() {\n        return this;\n    }\n\n    @Override\n    public Builder buildC() {\n        return this;\n    }\n\n    @Override\n    public Builder buildD() {\n        return this;\n    }\n\n    @Override\n    public ProductB getProduct() {\n        return this.productB;\n    }\n}\n```\n创建：\n```java\n//将创建过程放在外面而不需要导演类\nBuilder builder = new Worker();\nProductB product = builder.buildA()\n        .buildB()\n        .buildC()\n        .buildD()\n        .getProduct();\n```',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2020-07-26 23:38:44','2020-11-29 11:45:11',0),(26,'桥接模式','## 概念\n使用组合将两组不相关的抽象关系产生联系\n> 画出颜色不同的正方形、长方形、圆形   \n方案一：为每种形状都提供各种颜色的版本。  \n方案二：根据实际需要对颜色和形状进行组合--桥接模式。\n\n![image](https://www.runoob.com/wp-content/uploads/2018/06/1528771072-8457-5780d2384acdbb60ec07fc3c71a1.png)\n\n## 实现\n抽象颜色：\n```java\npublic interface Color {\n    void info();\n}\n```\n颜色实体：\n```java\npublic class Blue implements Color {\n    @Override\n    public void info() {\n        System.out.print(\"蓝色\");\n    }\n}\n```\n```java\npublic class Green implements Color {\n    @Override\n    public void info() {\n        System.out.print(\"绿色\");\n    }\n}\n```\n抽象图形和图形实体：\n```java\npublic abstract class Shape {\n    protected Color color;\n\n    public Shape(Color color) {\n        this.color = color; //使用组合让两种不同的抽象类型产生联系\n    }\n\n    abstract void paint();\n}\n\nclass Circle extends Shape {\n    public Circle(Color color) {\n        super(color);\n    }\n\n    @Override\n    void paint() {\n        this.color.info();\n        System.out.print(\"圆形\");\n    }\n}\n\nclass Rectangle extends Shape {\n    public Rectangle(Color color) {\n        super(color);\n    }\n\n    @Override\n    void paint() {\n        this.color.info();\n        System.out.print(\"长方形\");\n    }\n}\n```\n使用：\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Shape shape = new Circle(new Blue());   //可以自由组合从而生成想要的对象\n        shape.paint();\n    }\n}\n```',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2020-08-01 22:05:59','2020-11-29 11:45:11',0),(27,'适配器模式','[TOC]\n## 概念\n通过适配器，将原来不兼容的连个接口相互兼容  \nTarget：客户端可以使用的接口  \nAdaptee：要使用的接口但是不能兼容，需要进行适配  \nAdpter：两者适配的桥梁  \n![image](https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=709252618,139645322&fm=26&gp=0.jpg)\n\n## 类适配器\n**使用继承让适配器做所有的工作，非多继承语言只能适配一个Adaptee类**\n\nAdaptee:\n```java\n//被适配者\npublic class Adaptee {\n    public void Net() {\n        System.out.println(\"使用网线上网\");\n    }\n}\n```\nTarget:\n```java\n//目标接口(USB)\npublic interface Target {\n    void UseUSBNet();\n}\n```\nAdapter:  \n**使用继承被适配类，从而实现转接方法**\n```java\n//适配器\npublic class Adapter extends Adaptee implements Target{\n    @Override\n    public void UseUSBNet() {\n        super.Net();\n    }\n}\n```\n使用：\n```java\npublic class Computer {\n    //需要转接器才能上网\n    public void UseNet(Target target) {\n        target.UseUSBNet();\n    }\n\n    public static void main(String[] args) {\n        Computer computer = new Computer();\n        Adaptee adaptee = new Adaptee();    //无需使用\n        Adapter adapter = new Adapter();\n        computer.UseNet(adapter);\n    }\n}\n```\n\n## 对象适配器\n**使用组合调用适配类的方法**\n\nAdapter:\n```java\n//类适配器\npublic class Adapter implements Target {\n    private final Adaptee adaptee;\n\n    public Adapter(Adaptee adaptee) {\n        this.adaptee = adaptee;\n    }\n\n    @Override\n    public void UseUSBNet() {\n        this.adaptee.Net();\n    }\n}\n```\n使用：\n```java\npublic class Computer {\n    //需要转接器才能上网\n    public void UseNet(Target target) {\n        target.UseUSBNet();\n    }\n\n    public static void main(String[] args) {\n        Computer computer = new Computer();\n        Adaptee adaptee = new Adaptee();\n        Adapter adapter = new Adapter(adaptee);\n        computer.UseNet(adapter);\n    }\n}\n```',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2020-08-01 21:46:30','2020-11-29 11:45:11',0),(28,'使用模板类写自定义数组类ArrayList','## 自定模板类\n模板类似于Java中的泛型，可以传入对象  \n```cpp\ntemplate<class T>\nclass MyArray {\n}\n```\n\n## 代码实现\n通过.hpp文件写在其它文件中  \n```cpp\n#pragma once    //保证头文件只能被编译一次\n\n#include <iostream>\n\nusing namespace std;\n\ntemplate<class T>\nclass MyArray {\nprivate:\n    T *ptrAddress;  //泛型\n    int capacity{};\n    int size{};\npublic:\n\n    MyArray(const int capacity) {\n        this->capacity = capacity;\n        this->size = 0;\n        this->ptrAddress = new T[capacity]; //开辟在堆区中\n    }\n\n    //重写拷贝函数实现深拷贝\n    MyArray(const MyArray &array) {\n        this->ptrAddress = new T[array.capacity];\n        this->capacity = array.capacity;\n        this->size = array.size;\n        //复制数据\n        for (int i = 0; i < array.size; ++i) {\n            this->ptrAddress[i] = array.ptrAddress[i];\n        }\n    }\n\n    //重写赋值符号\n    MyArray &operator=(const MyArray &array) {\n        //防止自赋值的现象出现，如果出现自赋值直接返回自身\n        if (this->ptrAddress != nullptr && &array != this) {\n            delete[] ptrAddress;\n            this->ptrAddress = nullptr;\n            this->capacity = 0;\n            this->size = 0;\n        }\n        this->ptrAddress = new T[array.capacity];\n        this->capacity = array.capacity;\n        this->size = array.size;\n        //复制数据\n        for (int i = 0; i < array.size; ++i) {\n            this->ptrAddress[i] = array.ptrAddress[i];\n        }\n        return *this;\n    }\n\n    //尾部插入\n    MyArray &append(const T &element) {\n        if (size + 1 >= capacity) { //超出范围重新赋值\n            T *tmpAddress = this->ptrAddress;   //提取原始数组\n            this->ptrAddress = new T[capacity + 20];\n            //复制到新数组\n            for (int i = 0; i < this->size; ++i) {\n                this->ptrAddress[i] = tmpAddress[i];\n            }\n            this->ptrAddress[size] = element;\n            this->capacity = capacity + 20;\n            this->size++;\n            delete[] tmpAddress;    //清除原数组\n            return *this;\n        } else {\n            this->ptrAddress[this->size] = element;\n            this->size++;\n            return *this;\n        }\n    }\n\n    //尾部删除\n    MyArray &pop() {\n        if (this->size - 1 < 0) {\n            return *this;\n        } else {\n            this->size--;\n        }\n    }\n\n    //获取元素\n    T &get(int index) {\n        return this->ptrAddress[index];\n    }\n\n    int getSize() {\n        return this->size;\n    }\n\n\n    ~MyArray() {\n        if (ptrAddress != nullptr) {\n            delete[] ptrAddress;\n            ptrAddress = nullptr;\n        }\n    }\n};\n\n#ifndef LEETCODE_C_MYARRAY_HPP\n#define LEETCODE_C_MYARRAY_HPP\n\n#endif //LEETCODE_C_MYARRAY_HPP\n```',2,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2020-10-18 21:01:39','2020-11-29 11:45:11',0),(29,'重载运算符','## 自己写一个Integer封装类\n通过重写\'++\' \'--\'运算符实现int的基本功能\n\n## C++代码 \n对运算符进行定义，类似于python中的魔法方法\n```cpp\nclass Integer {\nprivate:\n    int num;\npublic:\n\n    Integer() {\n        this->num = 0;\n    }\n\n    Integer(int num) : num(num) {}\n\n    /*重写加法*/\n    Integer operator+(Integer b) const {\n        return Integer(this->num + b.num);  //相加返回新的对象\n    }\n\n    /*前置运算符*/\n    Integer &operator++() {\n        num++;\n        return *this;\n    }\n\n    Integer &operator--() {\n        num--;\n        return *this;\n    }\n\n    /*后置运算符*/\n    Integer operator++(int) {\n        Integer temp = *this;\n        num++;\n        return temp;    //只能返回新的对象，局部变量使用后空间会被收回，不得使用引用\n    }\n\n    Integer operator--(int) {\n        Integer temp = *this;\n        num--;\n        return temp;\n    }\n\n    int getNum() const {\n        return num;\n    }\n\n};\n\n/*重写输出操作符*/\nostream &operator<<(ostream &out, Integer integer) {\n    cout << integer.getNum();\n    return cout;\n}\n\nint main() {\n    Integer a(3);\n    Integer b(1);\n    cout << ++a << endl;\n    cout << a++ << endl;\n    cout << a << endl;\n    cout << a + b << endl;\n    return 0;\n}\n```\n\n## python中的实现\n突然想起我还会python，实现起来舒服多了\n```python\nclass Integer(object):\n    def __init__(self, num):\n        self.num = num\n\n    def __add__(self, other):\n        self.num += other.num\n        return Integer(self.num)\n\n    def __sub__(self, other):\n        self.num -= other.num\n        return Integer(self.num)\n\n    def __repr__(self):\n        return str(self.num)\n\n\nif __name__ == \'__main__\':\n    a = Integer(3)\n    b = Integer(4)\n    c = a + b\n    print(c)\n```',1,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2020-10-18 21:01:54','2020-11-29 11:45:11',0),(30,'float类型的精度','符号位          阶码          尾数\n\n1位                8位           23位\n\n比如130.0可表示为：130.0=1000  0010B=1.000  0010*(2^7)  //都要转化为1.xxx*(2^yy)这种形式\n\n符号位(正负号）                  阶码（指数7+127)                                            尾数（小数部分） \n\n0                                             1000 0110                                                        0000 0100 0000 0000 0000 000\n\n从浮点数二进制表示格式可以知道，尾数部分表示的是23位效位数，因为23位尾数表示的是小数点右边的数，小数点左边是默认是1，所以一共能表示24位有效数，\n\n      而 2^(24) = 16777216，转化为十进制10^7 < 16777216 < 10^8，所以只能精确表示7位。\n\n注意事项：以上只能说明超过7位一定不能精确表示，而小于7位时有可能被精确表示，为什么这么说，比如0.1就不能被精确表示，这是因为浮点数表示的并不是连续的数，而是离散的数。\n```c\n#include<stdio.h>\n\nint main()\n\n{\n\nfloat a;\n\na = 10000/3.0;\n\nprintf(\"%f\\n\",a);\n\nreturn 0;\n\n}\n```\n结果：\n\n3333.333252\n\n请按任意键继续. . .\n\n注意：由于float型数据只有6位有效数字，故此程序从左边开始的第七位起，后面的数字并不保证是绝对正确的',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2019-08-15 15:41:27','2020-11-29 11:45:11',0),(31,'for循环小飞机','```c\n#include<stdio.h>\n#include<stdlib.h>\n#include<conio.h>\n/*\n*1,打印飞机\n*2，（清屏之后）循环控制飞机静止\n*3,实现移动\n*4,升级移动用getch()\n*5,升级飞机\n*6,实现激光\n*7,打靶练习\n*/\nint main() {\n	int i, j;			//临时变量\n	int y = 5, x = 10;		//初始坐标\n	char input;		//输出\n	int isFire = 0;		//判断是否开火，默认不开\n	int nx = 5;			//障碍物位置\n	int isKill = 0;		//障碍物是否消失,默认不消失\n	//定义死循环实现游戏体\n	while (1) {\n		system(\"cls\");		//清屏函数,每次循环开始前清屏\n		//判断是否显示(没杀死)障碍物,没杀死即打印出来\n		if (isKill == 0)\n		{\n			for (j = 0; j < nx; j++)\n			{\n				printf(\" \");\n			}\n			printf(\"+\\n\");\n		}\n		//判断是否开火,开火打印子弹同时控制纵坐标位置,再判断是否打到障碍物\n		if (isFire == 1)\n		{\n			//打印子弹\n			for (i = 0; i < y; i++)\n			{\n				for (j = 0; j < x; j++)\n				{\n					printf(\" \");\n				}\n				printf(\"  |\\n\");\n			}\n			//判断是否打到障碍物\n			if (x + 2 == nx) {\n\n				isKill = 1;\n			}\n			//每次发射完子弹后要取消子弹发射直到下一次按键\n			isFire = 0;\n		}\n		//没有开火就打印换行控制纵坐标\n		else\n		{\n			for (i = 0; i < y; i++)\n			{\n				printf(\"\\n\");\n			}\n		}\n		//控制横坐标\n		for (j = 0; j < x; j++)\n		{\n			printf(\" \");\n		}\n		printf(\"  *\\n\");\n		//控制横坐标\n		for (j = 0; j < x; j++) {\n			printf(\" \");\n		}\n		printf(\"*****\\n\");\n		//控制横坐标\n		for (j = 0; j < x; j++) {\n			printf(\" \");\n		}\n		printf(\" * *\\n\");\n		//接受输入的字符，不需要回城键\n		input = _getch();\n		//移动按键控制\n		if (input == \'s\')y++;\n		if (input == \'w\')y--;\n		if (input == \'a\')x--;\n		if (input == \'d\')x++;\n		//开火按键控制\n		if (input == \' \')isFire = 1;\n	}\n	return 0;\n}\n```',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2019-12-17 13:24:08','2020-11-29 11:45:11',0),(32,'变长数组','变长数组通常用在结构体中申请一个未初始化的数组\n```c\n#pragma warning(disable:4996)\n#include<conio.h>\n#include<stdio.h>\n#include<stdlib.h>\ntypedef struct _SoftArray {\n	int len;\n	int array[];\n}SoftArray;\n\nint main()\n{\n	int len = 10;\n\n	printf(\"The struct\'s size is %d\\n\", sizeof(SoftArray));\n	enum { n = 5 };\n	int a[n];\n\n	return 0;\n}\n```\n结构体的大小为4个字节，由此可见数组并没有占用空间。\n用法 ：在一个结构体的最后 ，申明一个长度为空的数组，就可以使得这个结构体是可变长的。对于编译器来说，此时长度为0的数组并不占用空间，因为数组名本身不占空间，它只是一个偏移量， 数组名这个符号本身代表了一个不可修改的地址常量 （注意：数组名永远都不会是指针！ ），但对于这个数组的大小，我们可以进行动态分配,对于编译器而言，数组名仅仅是一个符号，它不会占用任何空间，它在结构体中，只是代表了一个偏移量，代表一个不可修改的地址常量！',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2019-08-17 12:51:15','2020-11-29 11:45:11',0),(33,'哥德巴赫猜想偶数等于两质数相加','```c\n/*哥德巴赫猜想偶数等于两质数相加*/\n#pragma warning(disable:4996)\n#include<stdio.h>\nvoid func(int n, int *x, int *y)\n{\n	int flag, i, j, t = 0;\n	int temp[100];\n	for (i = 2; i < n; i++)//寻找小于n的质数\n	{\n		flag = 1;\n		/*if (i == 2)\n		{\n			printf(\"%d \", i);\n			continue;\n		}*/\n		for (int j = 2; j < i; j++)//进行判断\n		{\n			if (i%j == 0)//不是质数\n			{\n				flag = 0;\n				break;\n			}\n		}\n		if (flag == 1)\n		{\n			temp[t++] = i;\n			temp[t] = \'\\0\';\n		}\n	}\n	int a, b;\n	for (i = 0; i <= t - 1; i++)//开始乱的加\n	{\n		for (j = i; j <= t - 1; j++)\n		{\n			if (temp[i] + temp[j] == n)\n			{\n				//printf(\"%d+%d=%d\\n\", temp[i], temp[j], n);\n				a = temp[i];\n				b = temp[j];\n			}\n		}\n	}\n	*x = a;\n	*y = b;\n}\nint main()\n{\n	int n, *x, *y;\n	printf(\"请输入值：\\n\");\n	scanf(\"%d\", &n);\n	func(n, &x, &y);\n	printf(\"%d+%d=%d\", x, y, n);\n	return 0;\n}\n```',1,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2019-07-05 15:49:52','2020-11-29 11:45:11',0),(34,'常变量','```c\n#pragma warning(disable:4996)\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\nint main()\n{\n	const int a = 5;\n	int* p;\n	p = &a;\n	*p = 6;\n	printf(\"%d\\n\", a);//可以通过指针修改一个const定义的值\n}\n```',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2019-08-19 21:32:07','2020-11-29 11:45:11',0),(35,'数字的转化','数字的ASCII码值从48(0)开始，可以通过减48得到整形数字\n```c\n#include<stdio.h>\nint main()\n{\n    char a = \'9\';\n    printf(\"%d %d %d\",a , a-48 ,a-\'0\')\n    \n}\n```\n还可以通过atoi(str)转化，\n```c\n#include<stdio.h>\nint main()\n{\n	char *a = \"1239\";\n	int Interger;\n	printf(\"%d\",atoi(a));\n	Interger = atoi(a);\n	printf(\"%d\", Interger);\n}\n```\nisdigit是计算机C(C++)语言中的一个函数，主要用于检查其参数是否为十进制数字字符，若参数c为阿拉伯数字0~9，则返回非0值，否则返回0',1,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2019-08-14 17:06:24','2020-11-29 11:45:11',0),(36,'数组读取','```c\n#pragma warning(disable:4996)\n#include<conio.h>\n#include<stdio.h>\n#include<stdlib.h>\nint main()\n{\n	int a[3][2] = { {1,5},{10,15},{20,25} };\n	int i, j;\n	for (i = 0; i < 3; i++)\n	{\n		for (j = 0; j < 2; j++)\n		{\n			printf(\"%3d\", a[i][j]);\n		}\n		putchar(\'\\n\');\n	}\n	printf(\"%d\", *(a+1)[1]);//(a+1)表示移动到第二行第零个，[1]表示在此基础上再移动一行\n}\n```',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2019-08-19 21:29:39','2020-11-29 11:45:11',0),(37,'结构体比较','C语言中结构体的比较可以使用memcmp<br>\nmemcmp要使用指针进行比较\n```c\n#pragma warning(disable:4996)\n#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\ntypedef struct node\n{\n	int a;\n}Node;\nint main()\n{\n	Node a = { 2 };\n	Node b = { 2 };\n	Node* pa = &a;\n	Node* pb = &b;\n	printf(\"%d\\n\", memcmp(&a, &b, sizeof(Node)));	/*memcmp必须使用指针*/\n	/*结构体z直接比较失败*/\n	/*if (a == b)\n	{\n		printf(\"same\");\n	}*/\n	/*使用指针进行比较(fail)*/\n	if (&a == &b)\n	{\n		printf(\"same\");\n	}\n}\n```',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2019-09-16 22:55:27','2020-11-29 11:45:11',0),(38,'button','```java\npublic class button {\n    public static void main(String[] args) {\n        Frame frame = new Frame(\"frame\");\n        Button button1 = new Button(\"b1\");\n        Button button2 = new Button(\"b1\");\n        Button button3 = new Button(\"b1\");\n        Button button4 = new Button(\"b1\");\n        Button button5 = new Button(\"b1\");\n        Button button6 = new Button(\"b1\");\n        Button button7 = new Button(\"b1\");\n        Button button8 = new Button(\"b1\");\n        Button button9 = new Button(\"b1\");\n        Button button10 = new Button(\"b1\");\n\n        frame.setLayout(new GridLayout(2,1));\n        frame.setVisible(true);\n\n        //创建面板区域\n        Panel p1 = new Panel(new BorderLayout());\n        Panel p2=new Panel(new GridLayout(2,1));\n        Panel p3=new Panel(new BorderLayout());\n        Panel p4=new Panel(new GridLayout(2,1));\n\n        p1.add(button1,BorderLayout.EAST);\n        p1.add(button2,BorderLayout.WEST);\n        p2.add(button3);\n        p2.add(button4);\n        p1.add(p2,BorderLayout.CENTER);\n\n        p3.add(button5,BorderLayout.EAST);\n        p3.add(button6,BorderLayout.WEST);\n        p4.add(button7);\n        p4.add(button8);\n        p3.add(p4,BorderLayout.CENTER);\n\n        frame.add(p1);\n        frame.add(p3);\n    }\n\n\n}\n```',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2020-01-13 16:39:40','2020-11-29 11:45:11',0),(39,'Data','```java\nimport java.text.*;\nimport java.util.Date;\n\npublic class Demon01 {\n    public static void main(String[] args) throws ParseException {\n        Date date = new Date();\n        SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n        System.out.println(date.getTime());//毫秒值（方便进行计算）\n        System.out.println(simpleDateFormat.format(date));\n        //解析\n        System.out.println(simpleDateFormat.parse(\"2020-01-15 11:50:52\"));\n    }\n}\n```\n### date 和 simpleDateFormat\n```java\npublic class Demon01 {\n    public static void main(String[] args) throws ParseException {\n        Scanner sc = new Scanner(System.in);\n        Date date = new Date();\n        SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n        SimpleDateFormat simpleDateFormat2 = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n        System.out.println(\"请输入出生时间：\" + \"（格式）yyyy-MM-dd HH:mm:ss\");\n        Date begin = simpleDateFormat.parse(sc.nextLine());\n        //解析\n        long past = begin.getTime();\n        long now = date.getTime();\n        long theTime = now - past;\n\n        //输出\n        System.out.println(\"现在的时间：\" + simpleDateFormat.format(date));\n        System.out.println(theTime/1000/60/60/24);\n    }\n}\n```\n### Calendar\n```java\nimport java.text.*;\nimport java.util.Calendar;\n\npublic class Demon01 {\n    public static void main(String[] args) throws ParseException {\n        Calendar calendar = Calendar.getInstance();\n        System.out.println(calendar.get(Calendar.YEAR));\n        System.out.println(calendar.getTime());\n    }\n}\n```',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2020-01-15 15:02:30','2020-11-29 11:45:11',0),(40,'JFrame','```java\npublic class Demon01 {\n    public static void main(String[] args) {\n        new MyFrame().init();\n    }\n}\n\nclass MyFrame extends JFrame {\n    public void init() {\n        this.setTitle(\"JFrame\");\n        this.setBounds(200, 200, 200, 100);\n        this.setVisible(true);\n        JLabel jLabel = new JLabel(\"开始\");\n        this.add(jLabel);\n\n        //实例化容器\n        Container container = this.getContentPane();\n        container.setBackground(Color.RED);\n    }\n\n}\n```',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2020-01-15 11:38:33','2020-11-29 11:45:11',0),(41,'简易加法计算器','```java\nimport java.awt.*;\nimport java.awt.event.*;\nimport java.rmi.activation.ActivationMonitor;\n\npublic class Demon01 {\n    public static void main(String[] args) {\n        MyFrame myFrame = new MyFrame();\n    }\n}\n\nclass MyFrame extends Frame {\n    public MyFrame() {\n        TextField num1 = new TextField(10);\n        TextField num2 = new TextField(10);\n        TextField num3 = new TextField(10);\n\n        //按钮\n        Button button = new Button(\"=\");\n        MyActionListener myActionListener = new MyActionListener(num1, num2, num3);\n        button.addActionListener(myActionListener);\n\n        //标签\n        Label label = new Label(\"+\");\n\n        //布局\n        setLayout(new FlowLayout());\n        add(num1);\n        add(label);\n        add(num2);\n        add(button);\n        add(num3);\n\n        setTitle(\"JavaWindows\");\n        myActionListener.closeWindows(this);\n        setVisible(true);\n        pack();\n    }\n}\n\nclass MyActionListener implements ActionListener {\n    private TextField num1, num2, num3;\n\n    public MyActionListener(TextField num1, TextField num2, TextField num3) {\n        this.num1 = num1;\n        this.num2 = num2;\n        this.num3 = num3;\n    }\n\n    @Override\n    public void actionPerformed(ActionEvent e) {\n        //1.获取两个数\n        int i = Integer.parseInt(num1.getText());\n        int j = Integer.parseInt(num2.getText());\n\n        //2.相加放上结果\n        num3.setText(\"\" + (i + j));\n        //3.清除输入数字\n        num1.setText(\"\");\n        num2.setText(\"\");\n    }\n\n    public void closeWindows(MyFrame myFrame) {\n        myFrame.addWindowListener(new WindowAdapter() {\n            @Override\n            public void windowClosing(WindowEvent e) {\n                System.exit(0);\n            }\n        });\n    }\n}\n```\n### 面向对象代码重构（组合）\n```java\nimport java.awt.*;\nimport java.awt.event.*;\nimport java.rmi.activation.ActivationMonitor;\n\npublic class Demon01 {\n    public static void main(String[] args) {\n        MyFrame myFrame = new MyFrame();\n    }\n}\n\nclass MyFrame extends Frame {\n    //属性 + 方法\n    TextField num1 = new TextField(10);\n    TextField num2 = new TextField(10);\n    TextField num3 = new TextField(10);\n\n    public MyFrame() {\n        //按钮\n        Button button = new Button(\"=\");\n        MyActionListener myActionListener = new MyActionListener(this);\n        button.addActionListener(myActionListener);\n\n        //标签\n        Label label = new Label(\"+\");\n\n        //布局\n        setLayout(new FlowLayout());\n        add(num1);\n        add(label);\n        add(num2);\n        add(button);\n        add(num3);\n\n        setTitle(\"JavaWindows\");\n        myActionListener.closeWindows(this);\n        setVisible(true);\n        pack();\n    }\n}\n\nclass MyActionListener implements ActionListener {\n    MyFrame myFrame;\n\n    public MyActionListener(MyFrame myFrame) {\n        this.myFrame = myFrame;\n    }\n\n    @Override\n    public void actionPerformed(ActionEvent e) {\n        int n1 = Integer.parseInt(myFrame.num1.getText());\n        int n2 = Integer.parseInt(myFrame.num2.getText());\n        myFrame.num3.setText(\"\" + (n1 + n2));\n        myFrame.num1.setText(\"\");\n        myFrame.num2.setText(\"\");\n    }\n\n    public void closeWindows(MyFrame myFrame) {\n        myFrame.addWindowListener(new WindowAdapter() {\n            @Override\n            public void windowClosing(WindowEvent e) {\n                System.exit(0);\n            }\n        });\n    }\n}\n```\n```java\nclass MyFrame extends Frame {\n    //属性 + 方法\n    TextField num1 = new TextField(10);\n    TextField num2 = new TextField(10);\n    TextField num3 = new TextField(10);\n\n    public MyFrame() {\n        //按钮\n        Button button = new Button(\"=\");\n        MyActionListener myActionListener = new MyActionListener();\n        button.addActionListener(myActionListener);\n\n        //标签\n        Label label = new Label(\"+\");\n\n        //布局\n        setLayout(new FlowLayout());\n        add(num1);\n        add(label);\n        add(num2);\n        add(button);\n        add(num3);\n\n        setTitle(\"JavaWindows\");\n        myActionListener.closeWindows(this);\n        setVisible(true);\n        pack();\n    }\n\n    @Override\n    public void paintComponents(Graphics g) {\n        g.setColor(Color.red);\n        g.fillOval(2,2,20,20);\n    }\n\n    class MyActionListener implements ActionListener {\n\n        @Override\n        public void actionPerformed(ActionEvent e) {\n            int n1 = Integer.parseInt(num1.getText());\n            int n2 = Integer.parseInt(num2.getText());\n            num3.setText(\"\" + (n1 + n2));\n            num1.setText(\"\");\n            num2.setText(\"\");\n        }\n\n        public void closeWindows(MyFrame myFrame) {\n            myFrame.addWindowListener(new WindowAdapter() {\n                @Override\n                public void windowClosing(WindowEvent e) {\n                    System.exit(0);\n                }\n            });\n        }\n    }\n}\n```',1,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2020-01-14 12:19:41','2020-11-29 11:45:11',0),(42,'输入框','```java\nimport java.awt.*;\nimport java.awt.event.*;\nimport java.rmi.activation.ActivationMonitor;\n\npublic class Demon01 {\n    public static void main(String[] args) {\n        MyFrame myFrame = new MyFrame();\n    }\n}\n\nclass MyFrame extends Frame {\n    public MyFrame() {\n        TextField textField = new TextField();\n        add(textField);\n\n        //监听文本框中的文字\n        MyActionListener myActionListener = new MyActionListener();\n        textField.addActionListener(myActionListener);\n\n        textField.setEchoChar(\'*\');\n\n        setTitle(\"JavaWindows\");\n        myActionListener.closeWindows(this);\n        setVisible(true);\n        pack();\n    }\n}\n\nclass MyActionListener implements ActionListener {\n    @Override\n    public void actionPerformed(ActionEvent e) {\n        //e.getSource是 object\n        TextField textField = (TextField) e.getSource();\n        System.out.println(textField.getText());\n        textField.setText(\"\");\n    }\n\n    public void closeWindows(MyFrame myFrame) {\n        myFrame.addWindowListener(new WindowAdapter() {\n            @Override\n            public void windowClosing(WindowEvent e) {\n                System.exit(0);\n            }\n        });\n    }\n}\n```',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2020-01-14 09:59:44','2020-11-29 11:45:11',0),(43,'Ajax&Json笔记','## 今日内容\r\n	1. AJAX：\r\n	2. JSON\r\n\r\n\r\n\r\n\r\n\r\n# AJAX：\r\n	1. 概念： ASynchronous JavaScript And XML	异步的JavaScript 和 XML\r\n		1. 异步和同步：客户端和服务器端相互通信的基础上\r\n			* 客户端必须等待服务器端的响应。在等待的期间客户端不能做其他操作。\r\n			* 客户端不需要等待服务器端的响应。在服务器处理请求的过程中，客户端可以进行其他的操作。\r\n\r\n			Ajax 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。 [1] \r\n			通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。\r\n			传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。\r\n\r\n			提升用户的体验\r\n\r\n	2. 实现方式：\r\n		1. 原生的JS实现方式（了解）\r\n					 //1.创建核心对象\r\n		            var xmlhttp;\r\n		            if (window.XMLHttpRequest)\r\n		            {// code for IE7+, Firefox, Chrome, Opera, Safari\r\n		                xmlhttp=new XMLHttpRequest();\r\n		            }\r\n		            else\r\n		            {// code for IE6, IE5\r\n		                xmlhttp=new ActiveXObject(\"Microsoft.XMLHTTP\");\r\n		            }\r\n		\r\n		            //2. 建立连接\r\n		            /*\r\n		                参数：\r\n		                    1. 请求方式：GET、POST\r\n		                        * get方式，请求参数在URL后边拼接。send方法为空参\r\n		                        * post方式，请求参数在send方法中定义\r\n		                    2. 请求的URL：\r\n		                    3. 同步或异步请求：true（异步）或 false（同步）\r\n		\r\n		             */\r\n		            xmlhttp.open(\"GET\",\"ajaxServlet?username=tom\",true);\r\n		\r\n		            //3.发送请求\r\n		            xmlhttp.send();\r\n		\r\n		            //4.接受并处理来自服务器的响应结果\r\n		            //获取方式 ：xmlhttp.responseText\r\n		            //什么时候获取？当服务器响应成功后再获取\r\n		\r\n		            //当xmlhttp对象的就绪状态改变时，触发事件onreadystatechange。\r\n		            xmlhttp.onreadystatechange=function()\r\n		            {\r\n		                //判断readyState就绪状态是否为4，判断status响应状态码是否为200\r\n		                if (xmlhttp.readyState==4 && xmlhttp.status==200)\r\n		                {\r\n		                   //获取服务器的响应结果\r\n		                    var responseText = xmlhttp.responseText;\r\n		                    alert(responseText);\r\n		                }\r\n		            }\r\n		2. JQeury实现方式\r\n			1. $.ajax()\r\n				* 语法：$.ajax({键值对});\r\n				 //使用$.ajax()发送异步请求\r\n		            $.ajax({\r\n		                url:\"ajaxServlet1111\" , // 请求路径\r\n		                type:\"POST\" , //请求方式\r\n		                //data: \"username=jack&age=23\",//请求参数\r\n		                data:{\"username\":\"jack\",\"age\":23},\r\n		                success:function (data) {\r\n		                    alert(data);\r\n		                },//响应成功后的回调函数\r\n		                error:function () {\r\n		                    alert(\"出错啦...\")\r\n		                },//表示如果请求响应出现错误，会执行的回调函数\r\n		\r\n		                dataType:\"text\"//设置接受到的响应数据的格式\r\n		            });\r\n			2. $.get()：发送get请求\r\n				* 语法：$.get(url, [data], [callback], [type])\r\n					* 参数：\r\n						* url：请求路径\r\n						* data：请求参数\r\n						* callback：回调函数\r\n						* type：响应结果的类型\r\n\r\n			3. $.post()：发送post请求\r\n				* 语法：$.post(url, [data], [callback], [type])\r\n					* 参数：\r\n						* url：请求路径\r\n						* data：请求参数\r\n						* callback：回调函数\r\n						* type：响应结果的类型\r\n\r\n\r\n\r\n# JSON：\r\n	1. 概念： JavaScript Object Notation		JavaScript对象表示法\r\n		Person p = new Person();\r\n		p.setName(\"张三\");\r\n		p.setAge(23);\r\n		p.setGender(\"男\");\r\n\r\n		var p = {\"name\":\"张三\",\"age\":23,\"gender\":\"男\"};\r\n\r\n		* json现在多用于存储和交换文本信息的语法\r\n		* 进行数据的传输\r\n		* JSON 比 XML 更小、更快，更易解析。\r\n	\r\n	2. 语法：\r\n		1. 基本规则\r\n			* 数据在名称/值对中：json数据是由键值对构成的\r\n				* 键用引号(单双都行)引起来，也可以不使用引号\r\n				* 值得取值类型：\r\n					1. 数字（整数或浮点数）\r\n					2. 字符串（在双引号中）\r\n					3. 逻辑值（true 或 false）\r\n					4. 数组（在方括号中）	{\"persons\":[{},{}]}\r\n					5. 对象（在花括号中） {\"address\":{\"province\"：\"陕西\"....}}\r\n					6. null\r\n			* 数据由逗号分隔：多个键值对由逗号分隔\r\n			* 花括号保存对象：使用{}定义json 格式\r\n			* 方括号保存数组：[]\r\n		2. 获取数据:\r\n			1. json对象.键名\r\n			2. json对象[\"键名\"]\r\n			3. 数组对象[索引]\r\n			4. 遍历\r\n					 //1.定义基本格式\r\n			        var person = {\"name\": \"张三\", age: 23, \'gender\': true};\r\n			\r\n			        var ps = [{\"name\": \"张三\", \"age\": 23, \"gender\": true},\r\n			            {\"name\": \"李四\", \"age\": 24, \"gender\": true},\r\n			            {\"name\": \"王五\", \"age\": 25, \"gender\": false}];\r\n			\r\n			\r\n			\r\n			\r\n			        //获取person对象中所有的键和值\r\n			        //for in 循环\r\n			       /* for(var key in person){\r\n			            //这样的方式获取不行。因为相当于  person.\"name\"\r\n			            //alert(key + \":\" + person.key);\r\n			            alert(key+\":\"+person[key]);\r\n			        }*/\r\n			\r\n			       //获取ps中的所有值\r\n			        for (var i = 0; i < ps.length; i++) {\r\n			            var p = ps[i];\r\n			            for(var key in p){\r\n			                alert(key+\":\"+p[key]);\r\n			            }\r\n			        }\r\n	\r\n\r\n	3. JSON数据和Java对象的相互转换\r\n\r\n		* JSON解析器：\r\n			* 常见的解析器：Jsonlib，Gson，fastjson，jackson\r\n		\r\n		1. JSON转为Java对象\r\n			1. 导入jackson的相关jar包\r\n			2. 创建Jackson核心对象 ObjectMapper\r\n			3. 调用ObjectMapper的相关方法进行转换\r\n				1. readValue(json字符串数据,Class)\r\n		2. Java对象转换JSON\r\n			1. 使用步骤：\r\n				1. 导入jackson的相关jar包\r\n				2. 创建Jackson核心对象 ObjectMapper\r\n				3. 调用ObjectMapper的相关方法进行转换\r\n					1. 转换方法：\r\n						* writeValue(参数1，obj):\r\n		                    参数1：\r\n		                        File：将obj对象转换为JSON字符串，并保存到指定的文件中\r\n		                        Writer：将obj对象转换为JSON字符串，并将json数据填充到字符输出流中\r\n		                        OutputStream：将obj对象转换为JSON字符串，并将json数据填充到字节输出流中\r\n		                * writeValueAsString(obj):将对象转为json字符串\r\n\r\n					2. 注解：\r\n						1. @JsonIgnore：排除属性。\r\n						2. @JsonFormat：属性值得格式化\r\n							* @JsonFormat(pattern = \"yyyy-MM-dd\")\r\n\r\n					3. 复杂java对象转换\r\n						1. List：数组\r\n						2. Map：对象格式一致（就是键值对）\r\n\r\n\r\n# 案例：\r\n	* 校验用户名是否存在\r\n		1. 服务器响应的数据，在客户端使用时，要想当做json数据格式使用。有两种解决方案：\r\n			1. $.get(type):将最后一个参数type指定为\"json\"\r\n			2. 在服务器端设置MIME类型\r\n				response.setContentType(\"application/json;charset=utf-8\");',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2020-03-14 16:52:02','2020-11-29 11:45:11',0),(44,'Ajax完成异步字符串校验','* 校验用户名是否存在\r\n	1. 服务器响应的数据，在客户端使用时，要想当做json数据格式使用。有两种解决方案：\r\n		1. $.get(type):将最后一个参数type指定为\"json\"\r\n		2. 在服务器端设置MIME类型\r\n			response.setContentType(\"application/json;charset=utf-8\");\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <title>注册</title>\r\n    <script src=\"js/jquery-3.3.1.min.js\"></script>\r\n    <script>\r\n        $(function () {\r\n            $(\"#username\").blur(function () {\r\n                //发送用户名进行校验\r\n                let username = $(this).val();\r\n                //设置键值对\r\n                $.get(\"checkUsernameServlet\", {\"username\": username}, function (data) { //data为servelt返回的数据\r\n                    //回复的数据\r\n                    $(\"span\").css(\"color\", \"red\");\r\n                    $(\"span\").html(data.msg);\r\n                });\r\n            });\r\n        });\r\n    </script>\r\n</head>\r\n<body>\r\n<form>\r\n    <input type=\"text\" id=\"username\" placeholder=\"用户名\" name=\"username\">\r\n    <span></span>\r\n    <br>\r\n    <input type=\"password\" id=\"password\" placeholder=\"密码\" name=\"password\"><br>\r\n    <input type=\"submit\" value=\"注册\">\r\n</form>\r\n</body>\r\n</html>\r\n```\r\n\r\n```html\r\n<script>\r\n    $(function () {\r\n        let flag = false;\r\n\r\n        /*异步登录请求*/\r\n        $(\"#btn-login\").click(function () {\r\n            let $username = $(\"#username\");\r\n            let $password = $(\"#password\");\r\n\r\n            /*判断表单是否为空*/\r\n            if ($username.val() === \"\") {\r\n                $username.attr(\"class\", \"form-control is-invalid\");\r\n                flag = false;\r\n            }\r\n            if ($password.val() === \"\") {\r\n                $password.attr(\"class\", \"form-control is-invalid\");\r\n                flag = false;\r\n            }\r\n            if (!flag) {\r\n                return;\r\n            }\r\n\r\n            /*Ajax发送异步登入请求*/\r\n            $.post(\"login\", {username: $username.val(), password: $password.val()}, function (result) {\r\n                if (result[\"msg\"] === \"error\") {\r\n                    $(\"#fail\").css(\"display\", \"\");\r\n                } else if (result[\"msg\"] === \"success\") {\r\n                    $(this).attr(\"class\", \"btn btn-lg btn-success btn-block col\");\r\n                    window.location.href = result[\"url\"];\r\n                }\r\n            });\r\n        });\r\n\r\n        /*回车提交*/\r\n        $(window).keydown(function (e) {\r\n            let curKey = e.which;\r\n            if (curKey === 13) {\r\n                $(\"#btn-login\").click();    //点击按钮\r\n            }\r\n        });\r\n\r\n        /*判断输入框是否为空*/\r\n        $(\"#username\").blur(function () {\r\n            if ($(this).val() === \"\") {\r\n                $(this).attr(\"class\", \"form-control is-invalid\");\r\n            } else {\r\n                $(this).attr(\"class\", \"form-control\");\r\n                flag = true;\r\n            }\r\n        });\r\n        $(\"#password\").blur(function () {\r\n            if ($(this).val() === \"\") {\r\n                $(this).attr(\"class\", \"form-control is-invalid\");\r\n            } else {\r\n                $(this).attr(\"class\", \"form-control\");\r\n                flag = true;\r\n            }\r\n        });\r\n    });\r\n</script>\r\n```\r\nservlet\r\n```java\r\npackage servler;\r\n\r\nimport com.fasterxml.jackson.databind.ObjectMapper;\r\n\r\nimport javax.servlet.ServletException;\r\nimport javax.servlet.annotation.WebServlet;\r\nimport javax.servlet.http.HttpServlet;\r\nimport javax.servlet.http.HttpServletRequest;\r\nimport javax.servlet.http.HttpServletResponse;\r\nimport java.io.IOException;\r\nimport java.util.HashMap;\r\nimport java.util.Map;\r\n\r\n@WebServlet(\"/checkUsernameServlet\")\r\npublic class CheckUsernameServlet extends HttpServlet {\r\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\r\n        response.setContentType(\"application/json;charset=utf-8\");  //如果不使用json的方式发送数据会导致回调函数接受的值为纯字符串而不是json对象\r\n        String username = request.getParameter(\"username\");\r\n        Map<String, Object> map = new HashMap<>();\r\n        if (\"Mike\".equals(username)) {\r\n            map.put(\"msg\", \"用户名不可用\");\r\n        } else {\r\n            map.put(\"msg\", \"可用\");\r\n        }\r\n        //json数据格式的封装\r\n        ObjectMapper objectMapper = new ObjectMapper();\r\n        String string = objectMapper.writeValueAsString(map);   //这里其实可以自己直接写字符串\r\n        response.getWriter().write(string);\r\n        //objectMapper.writeValue(response.getOutputStream(),String)\r\n    }\r\n\r\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\r\n        this.doPost(request, response);\r\n    }\r\n}\r\n```',6,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2020-11-21 20:37:03','2020-11-29 11:45:11',0),(45,'BootStrap笔记','# 今日内容\r\n	1. Bootstrap\r\n\r\n\r\n\r\n\r\n## Bootstrap：\r\n	1. 概念： 一个前端开发的框架，Bootstrap，来自 Twitter，是目前很受欢迎的前端框架。Bootstrap 是基于 HTML、CSS、JavaScript 的，它简洁灵活，使得 Web 开发更加快捷。\r\n		* 框架:一个半成品软件，开发人员可以在框架基础上，在进行开发，简化编码。\r\n		* 好处：\r\n			1. 定义了很多的css样式和js插件。我们开发人员直接可以使用这些样式和插件得到丰富的页面效果。\r\n			2. 响应式布局。\r\n				* 同一套页面可以兼容不同分辨率的设备。\r\n\r\n\r\n	2. 快速入门\r\n		1. 下载Bootstrap\r\n		2. 在项目中将这三个文件夹复制\r\n		3. 创建html页面，引入必要的资源文件\r\n\r\n\r\n		<!DOCTYPE html>\r\n		<html lang=\"zh-CN\">\r\n		<head>\r\n		    <meta charset=\"utf-8\">\r\n		    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\r\n		    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\r\n		    <!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ -->\r\n		    <title>Bootstrap HelloWorld</title>\r\n		\r\n		    <!-- Bootstrap -->\r\n		    <link href=\"css/bootstrap.min.css\" rel=\"stylesheet\">\r\n		\r\n		\r\n		    <!-- jQuery (Bootstrap 的所有 JavaScript 插件都依赖 jQuery，所以必须放在前边) -->\r\n		    <script src=\"js/jquery-3.2.1.min.js\"></script>\r\n		    <!-- 加载 Bootstrap 的所有 JavaScript 插件。你也可以根据需要只加载单个插件。 -->\r\n		    <script src=\"js/bootstrap.min.js\"></script>\r\n		</head>\r\n		<body>\r\n		<h1>你好，世界！</h1>\r\n		\r\n		</body>\r\n		</html>\r\n\r\n## 响应式布局\r\n	* 同一套页面可以兼容不同分辨率的设备。\r\n	* 实现：依赖于栅格系统：将一行平均分成12个格子，可以指定元素占几个格子\r\n	* 步骤：\r\n		1. 定义容器。相当于之前的table、\r\n			* 容器分类：\r\n				1. container：两边留白\r\n				2. container-fluid：每一种设备都是100%宽度\r\n		2. 定义行。相当于之前的tr   样式：row\r\n		3. 定义元素。指定该元素在不同的设备上，所占的格子数目。样式：col-设备代号-格子数目\r\n			* 设备代号：\r\n				1. xs：超小屏幕 手机 (<768px)：col-xs-12\r\n				2. sm：小屏幕 平板 (≥768px)\r\n				3. md：中等屏幕 桌面显示器 (≥992px)\r\n				4. lg：大屏幕 大桌面显示器 (≥1200px)\r\n\r\n		* 注意：\r\n			1. 一行中如果格子数目超过12，则超出部分自动换行。\r\n			2. 栅格类属性可以向上兼容。栅格类适用于与屏幕宽度大于或等于分界点大小的设备。\r\n			3. 如果真实设备宽度小于了设置栅格类属性的设备代码的最小值，会一个元素沾满一整行。\r\n\r\n## CSS样式和JS插件\r\n	1. 全局CSS样式：\r\n		* 按钮：class=\"btn btn-default\"\r\n		* 图片：\r\n			*  class=\"img-responsive\"：图片在任意尺寸都占100%\r\n			*  图片形状\r\n				*  <img src=\"...\" alt=\"...\" class=\"img-rounded\">：方形\r\n				*  <img src=\"...\" alt=\"...\" class=\"img-circle\"> ： 圆形\r\n				*  <img src=\"...\" alt=\"...\" class=\"img-thumbnail\"> ：相框\r\n		* 表格\r\n			* table\r\n			* table-bordered\r\n			* table-hover\r\n		* 表单\r\n			* 给表单项添加：class=\"form-control\" \r\n	2. 组件：\r\n		* 导航条\r\n		* 分页条\r\n	3. 插件：\r\n		* 轮播图\r\n\r\n## 案例\r\n	<!DOCTYPE html>\r\n	<html lang=\"zh-CN\">\r\n	<head>\r\n	    <meta charset=\"utf-8\">\r\n	    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\">\r\n	    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\r\n	    <!-- 上述3个meta标签*必须*放在最前面，任何其他内容都*必须*跟随其后！ -->\r\n	    <title>Bootstrap HelloWorld</title>\r\n	\r\n	    <!-- Bootstrap -->\r\n	    <link href=\"css/bootstrap.min.css\" rel=\"stylesheet\">\r\n	\r\n	\r\n	    <!-- jQuery (Bootstrap 的所有 JavaScript 插件都依赖 jQuery，所以必须放在前边) -->\r\n	    <script src=\"js/jquery-3.2.1.min.js\"></script>\r\n	    <!-- 加载 Bootstrap 的所有 JavaScript 插件。你也可以根据需要只加载单个插件。 -->\r\n	    <script src=\"js/bootstrap.min.js\"></script>\r\n	    <style>\r\n	        .paddtop{\r\n	            padding-top: 10px;\r\n	        }\r\n	        .search-btn{\r\n	            float: left;\r\n	            border:1px solid #ffc900;\r\n	            width: 90px;\r\n	            height: 35px;\r\n	            background-color:#ffc900 ;\r\n	            text-align: center;\r\n	            line-height: 35px;\r\n	            margin-top: 15px;\r\n	        }\r\n	\r\n	        .search-input{\r\n	            float: left;\r\n	            border:2px solid #ffc900;\r\n	            width: 400px;\r\n	            height: 35px;\r\n	            padding-left: 5px;\r\n	            margin-top: 15px;\r\n	        }\r\n	        .jx{\r\n	            border-bottom: 2px solid #ffc900;\r\n	            padding: 5px;\r\n	        }\r\n	        .company{\r\n	            height: 40px;\r\n	            background-color: #ffc900;\r\n	            text-align: center;\r\n	            line-height:40px ;\r\n	            font-size: 8px;\r\n	        }\r\n	    </style>\r\n	</head>\r\n	<body>\r\n	\r\n	   <!-- 1.页眉部分-->\r\n	   <header class=\"container-fluid\">\r\n	       <div class=\"row\">\r\n	           <img src=\"img/top_banner.jpg\" class=\"img-responsive\">\r\n	       </div>\r\n	       <div class=\"row paddtop\">\r\n	           <div class=\"col-md-3\">\r\n	               <img src=\"img/logo.jpg\" class=\"img-responsive\">\r\n	           </div>\r\n	           <div class=\"col-md-5\">\r\n	               <input class=\"search-input\" placeholder=\"请输入线路名称\">\r\n	               <a class=\"search-btn\" href=\"#\">搜索</a>\r\n	           </div>\r\n	           <div class=\"col-md-4\">\r\n	               <img src=\"img/hotel_tel.png\" class=\"img-responsive\">\r\n	           </div>\r\n	\r\n	       </div>\r\n	       <!--导航栏-->\r\n	       <div class=\"row\">\r\n	           <nav class=\"navbar navbar-default\">\r\n	               <div class=\"container-fluid\">\r\n	                   <!-- Brand and toggle get grouped for better mobile display -->\r\n	                   <div class=\"navbar-header\">\r\n	                       <!-- 定义汉堡按钮 -->\r\n	                       <button type=\"button\" class=\"navbar-toggle collapsed\" data-toggle=\"collapse\" data-target=\"#bs-example-navbar-collapse-1\" aria-expanded=\"false\">\r\n	                           <span class=\"sr-only\">Toggle navigation</span>\r\n	                           <span class=\"icon-bar\"></span>\r\n	                           <span class=\"icon-bar\"></span>\r\n	                           <span class=\"icon-bar\"></span>\r\n	                       </button>\r\n	                       <a class=\"navbar-brand\" href=\"#\">首页</a>\r\n	                   </div>\r\n	\r\n	                   <!-- Collect the nav links, forms, and other content for toggling -->\r\n	                   <div class=\"collapse navbar-collapse\" id=\"bs-example-navbar-collapse-1\">\r\n	                       <ul class=\"nav navbar-nav\">\r\n	                           <li class=\"active\"><a href=\"#\">Link <span class=\"sr-only\">(current)</span></a></li>\r\n	                           <li><a href=\"#\">Link</a></li>\r\n	                           <li><a href=\"#\">Link</a></li>\r\n	                           <li><a href=\"#\">Link</a></li>\r\n	                           <li><a href=\"#\">Link</a></li>\r\n	                           <li><a href=\"#\">Link</a></li>\r\n	\r\n	                       </ul>\r\n	                   </div><!-- /.navbar-collapse -->\r\n	               </div><!-- /.container-fluid -->\r\n	           </nav>\r\n	\r\n	       </div>\r\n	\r\n	       <!--轮播图-->\r\n	       <div class=\"row\">\r\n	           <div id=\"carousel-example-generic\" class=\"carousel slide\" data-ride=\"carousel\">\r\n	               <!-- Indicators -->\r\n	               <ol class=\"carousel-indicators\">\r\n	                   <li data-target=\"#carousel-example-generic\" data-slide-to=\"0\" class=\"active\"></li>\r\n	                   <li data-target=\"#carousel-example-generic\" data-slide-to=\"1\"></li>\r\n	                   <li data-target=\"#carousel-example-generic\" data-slide-to=\"2\"></li>\r\n	               </ol>\r\n	\r\n	               <!-- Wrapper for slides -->\r\n	               <div class=\"carousel-inner\" role=\"listbox\">\r\n	                   <div class=\"item active\">\r\n	                       <img src=\"img/banner_1.jpg\" alt=\"...\">\r\n	                   </div>\r\n	                   <div class=\"item\">\r\n	                       <img src=\"img/banner_2.jpg\" alt=\"...\">\r\n	                   </div>\r\n	                   <div class=\"item\">\r\n	                       <img src=\"img/banner_3.jpg\" alt=\"...\">\r\n	                   </div>\r\n	\r\n	               </div>\r\n	\r\n	               <!-- Controls -->\r\n	               <a class=\"left carousel-control\" href=\"#carousel-example-generic\" role=\"button\" data-slide=\"prev\">\r\n	                   <span class=\"glyphicon glyphicon-chevron-left\" aria-hidden=\"true\"></span>\r\n	                   <span class=\"sr-only\">Previous</span>\r\n	               </a>\r\n	               <a class=\"right carousel-control\" href=\"#carousel-example-generic\" role=\"button\" data-slide=\"next\">\r\n	                   <span class=\"glyphicon glyphicon-chevron-right\" aria-hidden=\"true\"></span>\r\n	                   <span class=\"sr-only\">Next</span>\r\n	               </a>\r\n	           </div>\r\n	\r\n	\r\n	\r\n	       </div>\r\n	\r\n	   </header>\r\n	   <!-- 2.主体部分-->\r\n	   <div class=\"container\">\r\n	        <div class=\"row jx\">\r\n	            <img src=\"img/icon_5.jpg\">\r\n	            <span>黑马精选</span>\r\n	        </div>\r\n	\r\n	       <div class=\"row paddtop\">\r\n	           <div class=\"col-md-3\">\r\n	                <div class=\"thumbnail\">\r\n	                    <img src=\"img/jiangxuan_3.jpg\" alt=\"\">\r\n	                    <p>上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)</p>\r\n	                    <font color=\"red\">&yen; 699</font>\r\n	                </div>\r\n	           </div>\r\n	           <div class=\"col-md-3\">\r\n	               <div class=\"thumbnail\">\r\n	                   <img src=\"img/jiangxuan_3.jpg\" alt=\"\">\r\n	                   <p>上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)</p>\r\n	                   <font color=\"red\">&yen; 699</font>\r\n	               </div>\r\n	\r\n	           </div>\r\n	           <div class=\"col-md-3\">\r\n	\r\n	               <div class=\"thumbnail\">\r\n	                   <img src=\"img/jiangxuan_3.jpg\" alt=\"\">\r\n	                   <p>上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)</p>\r\n	                   <font color=\"red\">&yen; 699</font>\r\n	               </div>\r\n	           </div>\r\n	           <div class=\"col-md-3\">\r\n	\r\n	               <div class=\"thumbnail\">\r\n	                   <img src=\"img/jiangxuan_3.jpg\" alt=\"\">\r\n	                   <p>上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)</p>\r\n	                   <font color=\"red\">&yen; 699</font>\r\n	               </div>\r\n	           </div>\r\n	\r\n	\r\n	       </div>\r\n	       <div class=\"row jx\">\r\n	           <img src=\"img/icon_6.jpg\">\r\n	           <span>国内游</span>\r\n	       </div>\r\n	       <div class=\"row paddtop\">\r\n	           <div class=\"col-md-4\">\r\n	               <img src=\"img/guonei_1.jpg\">\r\n	           </div>\r\n	           <div class=\"col-md-8\">\r\n	               <div class=\"row\">\r\n	                   <div class=\"col-md-4\">\r\n	                       <div class=\"thumbnail\">\r\n	                           <img src=\"img/jiangxuan_3.jpg\" alt=\"\">\r\n	                           <p>上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)</p>\r\n	                           <font color=\"red\">&yen; 699</font>\r\n	                       </div>\r\n	                   </div>\r\n	                   <div class=\"col-md-4\">\r\n	                       <div class=\"thumbnail\">\r\n	                           <img src=\"img/jiangxuan_3.jpg\" alt=\"\">\r\n	                           <p>上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)</p>\r\n	                           <font color=\"red\">&yen; 699</font>\r\n	                       </div>\r\n	\r\n	                   </div>\r\n	                   <div class=\"col-md-4\">\r\n	\r\n	                       <div class=\"thumbnail\">\r\n	                           <img src=\"img/jiangxuan_3.jpg\" alt=\"\">\r\n	                           <p>上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)</p>\r\n	                           <font color=\"red\">&yen; 699</font>\r\n	                       </div>\r\n	                   </div>\r\n	\r\n	               </div>\r\n	               <div class=\"row\">\r\n	                   <div class=\"col-md-4\">\r\n	                       <div class=\"thumbnail\">\r\n	                           <img src=\"img/jiangxuan_3.jpg\" alt=\"\">\r\n	                           <p>上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)</p>\r\n	                           <font color=\"red\">&yen; 699</font>\r\n	                       </div>\r\n	                   </div>\r\n	                   <div class=\"col-md-4\">\r\n	                       <div class=\"thumbnail\">\r\n	                           <img src=\"img/jiangxuan_3.jpg\" alt=\"\">\r\n	                           <p>上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)</p>\r\n	                           <font color=\"red\">&yen; 699</font>\r\n	                       </div>\r\n	\r\n	                   </div>\r\n	                   <div class=\"col-md-4\">\r\n	\r\n	                       <div class=\"thumbnail\">\r\n	                           <img src=\"img/jiangxuan_3.jpg\" alt=\"\">\r\n	                           <p>上海直飞三亚5天4晚自由行(春节预售+亲子/蜜月/休闲游首选+豪华酒店任选+接送机)</p>\r\n	                           <font color=\"red\">&yen; 699</font>\r\n	                       </div>\r\n	                   </div>\r\n	\r\n	\r\n	               </div>\r\n	\r\n	           </div>\r\n	\r\n	       </div>\r\n	   </div>\r\n	   <!-- 3.页脚部分-->\r\n	   <footer class=\"container-fluid\">\r\n	       <div class=\"row\">\r\n	           <img src=\"img/footer_service.png\" class=\"img-responsive\">\r\n	       </div>\r\n	       <div class=\"row company\">\r\n	           江苏传智播客教育科技股份有限公司 版权所有Copyright 2006-2018, All Rights Reserved 苏ICP备16007882\r\n	       </div>\r\n	\r\n	   </footer>\r\n	\r\n	\r\n	</body>\r\n	</html>',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2020-01-17 16:37:28','2020-11-29 11:45:11',0),(46,'注意项','在使用hr的时候很容易误解为border就是水平线，改变border就能改变水平线的颜色，然而事实并不是这样的，要想改变水平线的颜色，要从下面的i几个属性出发：\n\nborder：设置为none或者0px；\n\nheight：给定一个高度，在水平线中指的是水平线有多粗；\n\nwidth：给定一个长度，即水平线大概有多长，占页面的多少；\n\nbackground-color：设置水平线的颜色。\n\n具体代码如下：\n\n <hr style=\"background-color:red;height: 1px;width:90%;border: none;\"/>\n\n\n\n注意：在使用border时，若设定值为border：1px solid red；则针对的是水平线的边，是4个边，而中间的颜色是空，即未改变水平线的实际颜色。\n\n <hr style=\"clear: both;background-color:red;height: 5px;width:90%;border: 5px solid green;\"/>                \n\n\n\n绿色的是边框，红色的是里面的内容。\n————————————————\n版权声明：本文为CSDN博主「ColourfulTiger」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。\n原文链接：https://blog.csdn.net/ColourfulTiger/article/details/81322524',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2020-02-23 20:59:30','2020-11-29 11:45:11',0),(47,'Cookie&Session笔记','# 今日内容\r\n	1. 会话技术\r\n		1. Cookie\r\n		2. Session\r\n	2. JSP：入门学习\r\n\r\n\r\n\r\n## 会话技术\r\n	1. 会话：一次会话中包含多次请求和响应。\r\n		* 一次会话：浏览器第一次给服务器资源发送请求，会话建立，直到有一方断开为止\r\n	2. 功能：在一次会话的范围内的多次请求间，共享数据\r\n	3. 方式：\r\n		1. 客户端会话技术：Cookie\r\n		2. 服务器端会话技术：Session\r\n\r\n\r\n## Cookie：\r\n	1. 概念：客户端会话技术，将数据保存到客户端\r\n\r\n	2. 快速入门：\r\n		* 使用步骤：\r\n			1. 创建Cookie对象，绑定数据\r\n				* new Cookie(String name, String value) \r\n			2. 发送Cookie对象\r\n				* response.addCookie(Cookie cookie) \r\n			3. 获取Cookie，拿到数据\r\n				* Cookie[]  request.getCookies()  \r\n\r\n\r\n	3. 实现原理\r\n		* 基于响应头set-cookie和请求头cookie实现\r\n\r\n	4. cookie的细节\r\n		1. 一次可不可以发送多个cookie?\r\n			* 可以\r\n			* 可以创建多个Cookie对象，使用response调用多次addCookie方法发送cookie即可。\r\n		2. cookie在浏览器中保存多长时间？\r\n			1. 默认情况下，当浏览器关闭后，Cookie数据被销毁\r\n			2. 持久化存储：\r\n				* setMaxAge(int seconds)\r\n					1. 正数：将Cookie数据写到硬盘的文件中。持久化存储。并指定cookie存活时间，时间到后，cookie文件自动失效\r\n					2. 负数：默认值\r\n					3. 零：删除cookie信息\r\n		3. cookie能不能存中文？\r\n			* 在tomcat 8 之前 cookie中不能直接存储中文数据。\r\n				* 需要将中文数据转码---一般采用URL编码(%E3)\r\n			* 在tomcat 8 之后，cookie支持中文数据。特殊字符还是不支持，建议使用URL编码存储，URL解码解析\r\n		4. cookie共享问题？\r\n			1. 假设在一个tomcat服务器中，部署了多个web项目，那么在这些web项目中cookie能不能共享？\r\n				* 默认情况下cookie不能共享\r\n\r\n				* setPath(String path):设置cookie的获取范围。默认情况下，设置当前的虚拟目录\r\n					* 如果要共享，则可以将path设置为\"/\"\r\n\r\n			\r\n			2. 不同的tomcat服务器间cookie共享问题？\r\n				* setDomain(String path):如果设置一级域名相同，那么多个服务器之间cookie可以共享\r\n					* setDomain(\".baidu.com\"),那么tieba.baidu.com和news.baidu.com中cookie可以共享\r\n			\r\n\r\n	5. Cookie的特点和作用\r\n		1. cookie存储数据在客户端浏览器\r\n		2. 浏览器对于单个cookie 的大小有限制(4kb) 以及 对同一个域名下的总cookie数量也有限制(20个)\r\n\r\n		* 作用：\r\n			1. cookie一般用于存出少量的不太敏感的数据\r\n			2. 在不登录的情况下，完成服务器对客户端的身份识别\r\n\r\n	6. 案例：记住上一次访问时间\r\n		1. 需求：\r\n			1. 访问一个Servlet，如果是第一次访问，则提示：您好，欢迎您首次访问。\r\n			2. 如果不是第一次访问，则提示：欢迎回来，您上次访问时间为:显示时间字符串\r\n\r\n		2. 分析：\r\n			1. 可以采用Cookie来完成\r\n			2. 在服务器中的Servlet判断是否有一个名为lastTime的cookie\r\n				1. 有：不是第一次访问\r\n					1. 响应数据：欢迎回来，您上次访问时间为:2018年6月10日11:50:20\r\n					2. 写回Cookie：lastTime=2018年6月10日11:50:01\r\n				2. 没有：是第一次访问\r\n					1. 响应数据：您好，欢迎您首次访问\r\n					2. 写回Cookie：lastTime=2018年6月10日11:50:01\r\n\r\n		3. 代码实现：\r\n			package cn.itcast.cookie;\r\n\r\n			import javax.servlet.ServletException;\r\n			import javax.servlet.annotation.WebServlet;\r\n			import javax.servlet.http.Cookie;\r\n			import javax.servlet.http.HttpServlet;\r\n			import javax.servlet.http.HttpServletRequest;\r\n			import javax.servlet.http.HttpServletResponse;\r\n			import java.io.IOException;\r\n			import java.net.URLDecoder;\r\n			import java.net.URLEncoder;\r\n			import java.text.SimpleDateFormat;\r\n			import java.util.Date;\r\n\r\n\r\n		@WebServlet(\"/cookieTest\")\r\n		public class CookieTest extends HttpServlet {\r\n		    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\r\n		        //设置响应的消息体的数据格式以及编码\r\n		        response.setContentType(\"text/html;charset=utf-8\");\r\n		\r\n		        //1.获取所有Cookie\r\n		        Cookie[] cookies = request.getCookies();\r\n		        boolean flag = false;//没有cookie为lastTime\r\n		        //2.遍历cookie数组\r\n		        if(cookies != null && cookies.length > 0){\r\n		            for (Cookie cookie : cookies) {\r\n		                //3.获取cookie的名称\r\n		                String name = cookie.getName();\r\n		                //4.判断名称是否是：lastTime\r\n		                if(\"lastTime\".equals(name)){\r\n		                    //有该Cookie，不是第一次访问\r\n		\r\n		                    flag = true;//有lastTime的cookie\r\n		\r\n		                    //设置Cookie的value\r\n		                    //获取当前时间的字符串，重新设置Cookie的值，重新发送cookie\r\n		                    Date date  = new Date();\r\n		                    SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy年MM月dd日 HH:mm:ss\");\r\n		                    String str_date = sdf.format(date);\r\n		                    System.out.println(\"编码前：\"+str_date);\r\n		                    //URL编码\r\n		                    str_date = URLEncoder.encode(str_date,\"utf-8\");\r\n		                    System.out.println(\"编码后：\"+str_date);\r\n		                    cookie.setValue(str_date);\r\n		                    //设置cookie的存活时间\r\n		                    cookie.setMaxAge(60 * 60 * 24 * 30);//一个月\r\n		                    response.addCookie(cookie);\r\n		\r\n		\r\n		                    //响应数据\r\n		                    //获取Cookie的value，时间\r\n		                    String value = cookie.getValue();\r\n		                    System.out.println(\"解码前：\"+value);\r\n		                    //URL解码：\r\n		                    value = URLDecoder.decode(value,\"utf-8\");\r\n		                    System.out.println(\"解码后：\"+value);\r\n		                    response.getWriter().write(\"<h1>欢迎回来，您上次访问时间为:\"+value+\"</h1>\");\r\n		\r\n		                    break;\r\n		\r\n		                }\r\n		            }\r\n		        }\r\n		\r\n		\r\n		        if(cookies == null || cookies.length == 0 || flag == false){\r\n		            //没有，第一次访问\r\n		\r\n		            //设置Cookie的value\r\n		            //获取当前时间的字符串，重新设置Cookie的值，重新发送cookie\r\n		            Date date  = new Date();\r\n		            SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy年MM月dd日 HH:mm:ss\");\r\n		            String str_date = sdf.format(date);\r\n		            System.out.println(\"编码前：\"+str_date);\r\n		            //URL编码\r\n		            str_date = URLEncoder.encode(str_date,\"utf-8\");\r\n		            System.out.println(\"编码后：\"+str_date);\r\n		\r\n		            Cookie cookie = new Cookie(\"lastTime\",str_date);\r\n		            //设置cookie的存活时间\r\n		            cookie.setMaxAge(60 * 60 * 24 * 30);//一个月\r\n		            response.addCookie(cookie);\r\n		\r\n		            response.getWriter().write(\"<h1>您好，欢迎您首次访问</h1>\");\r\n		        }\r\n		\r\n		\r\n		    }\r\n		\r\n		    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\r\n		        this.doPost(request, response);\r\n		    }\r\n		}\r\n\r\n\r\n## JSP：入门学习\r\n	1. 概念：\r\n		* Java Server Pages： java服务器端页面\r\n			* 可以理解为：一个特殊的页面，其中既可以指定定义html标签，又可以定义java代码\r\n			* 用于简化书写！！！\r\n\r\n\r\n	2. 原理\r\n		* JSP本质上就是一个Servlet\r\n\r\n	3. JSP的脚本：JSP定义Java代码的方式\r\n		1. <%  代码 %>：定义的java代码，在service方法中。service方法中可以定义什么，该脚本中就可以定义什么。\r\n		2. <%! 代码 %>：定义的java代码，在jsp转换后的java类的成员位置。\r\n		3. <%= 代码 %>：定义的java代码，会输出到页面上。输出语句中可以定义什么，该脚本中就可以定义什么。\r\n\r\n\r\n	4. JSP的内置对象：\r\n		* 在jsp页面中不需要获取和创建，可以直接使用的对象\r\n		* jsp一共有9个内置对象。\r\n		* 今天学习3个：\r\n			* request\r\n			* response\r\n			* out：字符输出流对象。可以将数据输出到页面上。和response.getWriter()类似\r\n				* response.getWriter()和out.write()的区别：\r\n					* 在tomcat服务器真正给客户端做出响应之前，会先找response缓冲区数据，再找out缓冲区数据。\r\n					* response.getWriter()数据输出永远在out.write()之前\r\n				\r\n	5. 案例:改造Cookie案例\r\n\r\n\r\n\r\n\r\n## Session：主菜\r\n	1. 概念：服务器端会话技术，在一次会话的多次请求间共享数据，将数据保存在服务器端的对象中。HttpSession\r\n	2. 快速入门：\r\n		1. 获取HttpSession对象：\r\n			HttpSession session = request.getSession();\r\n		2. 使用HttpSession对象：\r\n			Object getAttribute(String name)  \r\n			void setAttribute(String name, Object value)\r\n			void removeAttribute(String name)  \r\n	\r\n	3. 原理\r\n		* Session的实现是依赖于Cookie的。\r\n\r\n	\r\n	4. 细节：\r\n		1. 当客户端关闭后，服务器不关闭，两次获取session是否为同一个？\r\n			* 默认情况下。不是。\r\n			* 如果需要相同，则可以创建Cookie,键为JSESSIONID，设置最大存活时间，让cookie持久化保存。\r\n				 Cookie c = new Cookie(\"JSESSIONID\",session.getId());\r\n		         c.setMaxAge(60*60);\r\n		         response.addCookie(c);\r\n\r\n		2. 客户端不关闭，服务器关闭后，两次获取的session是同一个吗？\r\n			* 不是同一个，但是要确保数据不丢失。tomcat自动完成以下工作\r\n				* session的钝化：\r\n					* 在服务器正常关闭之前，将session对象系列化到硬盘上\r\n				* session的活化：\r\n					* 在服务器启动后，将session文件转化为内存中的session对象即可。\r\n				\r\n		3. session什么时候被销毁？\r\n			1. 服务器关闭\r\n			2. session对象调用invalidate() 。\r\n			3. session默认失效时间 30分钟\r\n				选择性配置修改	\r\n				<session-config>\r\n			        <session-timeout>30</session-timeout>\r\n			    </session-config>\r\n\r\n	 5. session的特点\r\n		 1. session用于存储一次会话的多次请求的数据，存在服务器端\r\n		 2. session可以存储任意类型，任意大小的数据\r\n\r\n		* session与Cookie的区别：\r\n			1. session存储数据在服务器端，Cookie在客户端\r\n			2. session没有数据大小限制，Cookie有\r\n			3. session数据安全，Cookie相对于不安全\r\n\r\n\r\n## 案例：验证码\r\n	1. 案例需求：\r\n		1. 访问带有验证码的登录页面login.jsp\r\n		2. 用户输入用户名，密码以及验证码。\r\n			* 如果用户名和密码输入有误，跳转登录页面，提示:用户名或密码错误\r\n			* 如果验证码输入有误，跳转登录页面，提示：验证码错误\r\n			* 如果全部输入正确，则跳转到主页success.jsp，显示：用户名,欢迎您\r\n\r\n\r\n	2. 分析：',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2020-01-17 16:20:43','2020-11-29 11:45:11',0),(48,'Cookie实现记录登入时间','判断Cookie是否含有有关时间的信息，有就更改后重新发送，没有就直接发送时间信息<br>\n遇到的问题：\n传输文字的时候报出字符的异常（不支持空格），解决方法使用URL进行编码和解码<br>\n```java\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.Cookie;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.net.URLDecoder;\nimport java.net.URLEncoder;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\n@WebServlet(\"/ServletCookie\")\npublic class ServletCookie extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=utf-8\");\n        boolean flag = false;\n        Cookie[] cookies = request.getCookies();\n        if (cookies != null && cookies.length != 0) {\n            for (Cookie cookie : cookies) {\n                String name = cookie.getName();\n                if (name.equals(\"lastTime\")) {\n                    flag = true;\n                    response.getWriter().write(\"上一次登入的时间为：\" + URLDecoder.decode(cookie.getValue(), \"utf-8\"));   //URL解码\n                    //更改时间\n                    Date date = new Date();\n                    SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"yyyy年MM月dd日 HH:mm:ss\");   //要使用URL编码\n                    String format = simpleDateFormat.format(date);\n                    String encode = URLEncoder.encode(format, \"utf-8\");\n                    cookie.setValue(encode);\n                    cookie.setMaxAge(60 * 60 * 24 * 30);  //一个月\n                    response.addCookie(cookie);\n                    break;\n                }\n            }\n        }\n        if (cookies == null || cookies.length == 0 || !flag) {\n            response.getWriter().write(\"欢迎第一次登入\");\n            SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"yyyy年MM月dd日 HH:mm:ss\");\n            Date date = new Date();\n            String format = simpleDateFormat.format(date);\n            Cookie cookie = new Cookie(\"lastTime\", URLEncoder.encode(format, \"utf-8\"));\n            cookie.setMaxAge(60 * 60 * 24 * 30);  //一个月\n            response.addCookie(cookie);\n        }\n    }\n\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        this.doPost(request, response);\n    }\n}\n```',1,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2020-03-02 16:17:30','2020-11-29 11:45:11',0),(49,'简单实现页面登入','<!-- TOC -->\n\n- [简单实现](#简单实现)\n- [整体思想](#整体思想)\n- [亿点细节](#亿点细节)\n    - [在登入页面下直接输出验证码错误信息](#在登入页面下直接输出验证码错误信息)\n    - [看不清换一张](#看不清换一张)\n    - [中文乱码的问题](#中文乱码的问题)\n\n<!-- /TOC -->\n### 简单实现\n使用servlet和jsp简单写一个登入页面<br>\n实现：<br>\n1.使用MySQL实现对于用户名和密码的判断(Spring JDBCTemplate)<br>\n2.通过BufferImage实现验证码的简单绘制<br>\n3.先判断验证码，减轻服务器的无效开销<br>\n### 整体思想\n1.通过表单获取用户发送post请求到CheckUserServlet<br>\n2.判断用户输入的验证码。使用CheckCodeServlet绘制验证码，使用session设置属性，使得其他servlet得以获取验证码<br>\n3.判断验证码<br>\n4.使用CheckUserServlet先封装一个User类<br>\n5.使用数据库连接对象连接数据库，传递用户名和密码，若正确则封装User对象，并将其返回，否则返回null（调用userDatabaseAccessObject.userLogin(loginUser)）<br>\n6.转发到成功或者失败的jsp<br>\n### 亿点细节\n#### 在登入页面下直接输出验证码错误信息\n```jsp\n <div id=\"warning\">\n     <%=request.getAttribute(\"verificationCode_error\") == null ? \"\" : request.getAttribute(\"verificationCode_error\")%>\n </div>\n```\n使用三元运算符和jsp（<%= 代碼%>）直接显示在html位置中，在没有错误的时候显示空字符串，而不为空的时候显示错误信息<br>\n#### 看不清换一张\n```jsp\n<img src=\"${pageContext.request.contextPath}/checkCode\" alt=\"验证码\" id=\"verificationCode\">\n        <a href=\"#\" id=\"changeCode\">看不清，换一张</a>\n```\nhref中写#可以不用进行跳转<br>\n当然只使用html是不行的，还需要js的配合（绑定用户的点击）<br>\n这里有一个注意点，如果只是更改图片的属性，由于浏览器有缓存，所以验证码图片并不会发生更改。所以在请求servlet资源的时候要加上一个post请求（随便获取一下毫秒值），这样图片就会发生变化了。<br>\n```html\n<script>\n    window.onload = function () {\n        let img = document.getElementById(\"verificationCode\");\n        img.onclick = function () {\n            img.src = \"/checkCode?\" + new Date().getMilliseconds();\n        };\n        document.getElementById(\"changeCode\").onclick = function () {\n            img.src = \"/checkCode?\" + new Date().getMilliseconds();\n        };\n    }\n</script>\n```\n#### 中文乱码的问题\n在使用servlet进行，response进行回复的时候要首先设置编码<br>\n```java\nresponse.setContentType(\"text/html;charset=utf-8\");\n```\n而在jsp中idea已经进行了默认的设置<br>\n```jsp\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n```',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2020-03-04 22:50:01','2020-11-29 11:45:11',0),(50,'Filter&Listener笔记','## 今日内容\r\n	1. Filter：过滤器\r\n	2. Listener：监听器\r\n\r\n\r\n\r\n\r\n# Filter：过滤器\r\n	1. 概念：\r\n		* 生活中的过滤器：净水器,空气净化器，土匪、\r\n		* web中的过滤器：当访问服务器的资源时，过滤器可以将请求拦截下来，完成一些特殊的功能。\r\n		* 过滤器的作用：\r\n			* 一般用于完成通用的操作。如：登录验证、统一编码处理、敏感字符过滤...\r\n\r\n	2. 快速入门：\r\n		1. 步骤：\r\n			1. 定义一个类，实现接口Filter\r\n			2. 复写方法\r\n			3. 配置拦截路径\r\n				1. web.xml\r\n				2. 注解\r\n		2. 代码：\r\n			@WebFilter(\"/*\")//访问所有资源之前，都会执行该过滤器\r\n			public class FilterDemo1 implements Filter {\r\n			    @Override\r\n			    public void init(FilterConfig filterConfig) throws ServletException {\r\n			\r\n			    }\r\n			\r\n			    @Override\r\n			    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {\r\n			        System.out.println(\"filterDemo1被执行了....\");\r\n			\r\n			\r\n			        //放行\r\n			        filterChain.doFilter(servletRequest,servletResponse);\r\n			\r\n			    }\r\n			\r\n			    @Override\r\n			    public void destroy() {\r\n			\r\n			    }\r\n			}\r\n\r\n\r\n	3. 过滤器细节：\r\n		1. web.xml配置	（优先于注解方式配置）\r\n			<filter>\r\n		        <filter-name>demo1</filter-name>\r\n		        <filter-class>cn.itcast.web.filter.FilterDemo1</filter-class>\r\n		    </filter>\r\n		    <filter-mapping>\r\n		        <filter-name>demo1</filter-name>\r\n				<!-- 拦截路径 -->\r\n		        <url-pattern>/*</url-pattern>\r\n		    </filter-mapping>\r\n		2. 过滤器执行流程\r\n			1. 执行过滤器\r\n			2. 执行放行后的资源\r\n			3. 回来执行过滤器放行代码下边的代码\r\n		3. 过滤器生命周期方法\r\n			1. init:在服务器启动后，会创建Filter对象，然后调用init方法。只执行一次。用于加载资源\r\n			2. doFilter:每一次请求被拦截资源时，会执行。执行多次\r\n			3. destroy:在服务器关闭后，Filter对象被销毁。如果服务器是正常关闭，则会执行destroy方法。只执行一次。用于释放资源\r\n		4. 过滤器配置详解\r\n			* 拦截路径配置：\r\n				1. 具体资源路径： /index.jsp   只有访问index.jsp资源时，过滤器才会被执行\r\n				2. 拦截目录： /user/*	访问/user下的所有资源时，过滤器都会被执行\r\n				3. 后缀名拦截： *.jsp		访问所有后缀名为jsp资源时，过滤器都会被执行\r\n				4. 拦截所有资源：/*		访问所有资源时，过滤器都会被执行\r\n			* 拦截方式配置：资源被访问的方式\r\n				* 注解配置：\r\n					* 设置dispatcherTypes属性\r\n						1. REQUEST：默认值。浏览器直接请求资源\r\n						2. FORWARD：转发访问资源\r\n						3. INCLUDE：包含访问资源\r\n						4. ERROR：错误跳转资源\r\n						5. ASYNC：异步访问资源\r\n				* web.xml配置\r\n					* 设置<dispatcher></dispatcher>标签即可\r\n				\r\n		5. 过滤器链(配置多个过滤器)\r\n			* 执行顺序：如果有两个过滤器：过滤器1和过滤器2\r\n				1. 过滤器1\r\n				2. 过滤器2\r\n				3. 资源执行\r\n				4. 过滤器2\r\n				5. 过滤器1 \r\n\r\n			* 过滤器先后顺序问题：\r\n				1. 注解配置：按照类名的字符串比较规则比较，值小的先执行\r\n					* 如： AFilter 和 BFilter，AFilter就先执行了。\r\n				2. web.xml配置： <filter-mapping>谁定义在上边，谁先执行\r\n	4. 案例：\r\n		1. 案例1_登录验证\r\n			* 需求：\r\n				1. 访问day17_case案例的资源。验证其是否登录\r\n				2. 如果登录了，则直接放行。\r\n				3. 如果没有登录，则跳转到登录页面，提示\"您尚未登录，请先登录\"。\r\n 		\r\n	\r\n\r\n		2. 案例2_敏感词汇过滤\r\n			* 需求：\r\n				1. 对day17_case案例录入的数据进行敏感词汇过滤\r\n				2. 敏感词汇参考《敏感词汇.txt》\r\n				3. 如果是敏感词汇，替换为 *** \r\n\r\n			* 分析：\r\n				1. 对request对象进行增强。增强获取参数相关方法\r\n				2. 放行。传递代理对象\r\n\r\n\r\n			* 增强对象的功能：\r\n				* 设计模式：一些通用的解决固定问题的方式\r\n				1. 装饰模式\r\n				2. 代理模式\r\n					* 概念：\r\n						1. 真实对象：被代理的对象\r\n						2. 代理对象：\r\n						3. 代理模式：代理对象代理真实对象，达到增强真实对象功能的目的\r\n				 	* 实现方式：\r\n					 	1. 静态代理：有一个类文件描述代理模式\r\n					 	2. 动态代理：在内存中形成代理类\r\n							* 实现步骤：\r\n								1. 代理对象和真实对象实现相同的接口\r\n								2. 代理对象 = Proxy.newProxyInstance();\r\n								3. 使用代理对象调用方法。\r\n								4. 增强方法\r\n\r\n							* 增强方式：\r\n								1. 增强参数列表\r\n								2. 增强返回值类型\r\n								3. 增强方法体执行逻辑	\r\n\r\n\r\n## Listener：监听器\r\n	* 概念：web的三大组件之一。\r\n		* 事件监听机制\r\n			* 事件	：一件事情\r\n			* 事件源 ：事件发生的地方\r\n			* 监听器 ：一个对象\r\n			* 注册监听：将事件、事件源、监听器绑定在一起。 当事件源上发生某个事件后，执行监听器代码\r\n\r\n\r\n	* ServletContextListener:监听ServletContext对象的创建和销毁\r\n		* 方法：\r\n			* void contextDestroyed(ServletContextEvent sce) ：ServletContext对象被销毁之前会调用该方法\r\n			* void contextInitialized(ServletContextEvent sce) ：ServletContext对象创建后会调用该方法\r\n		* 步骤：\r\n			1. 定义一个类，实现ServletContextListener接口\r\n			2. 复写方法\r\n			3. 配置\r\n				1. web.xml\r\n						<listener>\r\n     					 <listener-class>cn.itcast.web.listener.ContextLoaderListener</listener-class>\r\n   						</listener>\r\n\r\n						* 指定初始化参数<context-param>\r\n				2. 注解：\r\n					* @WebListener',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2020-03-11 11:09:54','2020-11-29 11:45:11',0),(51,'JavaScript基础笔记','# 今日内容\r\n	1. JavaScript基础\r\n\r\n\r\n## JavaScript：\r\n	* 概念：	一门客户端脚本语言\r\n		* 运行在客户端浏览器中的。每一个浏览器都有JavaScript的解析引擎\r\n		* 脚本语言：不需要编译，直接就可以被浏览器解析执行了\r\n\r\n	* 功能：\r\n		* 可以来增强用户和html页面的交互过程，可以来控制html元素，让页面有一些动态的效果，增强用户的体验。\r\n	\r\n	* JavaScript发展史：\r\n		1. 1992年，Nombase公司，开发出第一门客户端脚本语言，专门用于表单的校验。命名为 ： C--	，后来更名为：ScriptEase\r\n		2. 1995年，Netscape(网景)公司，开发了一门客户端脚本语言：LiveScript。后来，请来SUN公司的专家，修改LiveScript，命名为JavaScript\r\n		3. 1996年，微软抄袭JavaScript开发出JScript语言\r\n		4. 1997年，ECMA(欧洲计算机制造商协会)，制定出客户端脚本语言的标准：ECMAScript，就是统一了所有客户端脚本语言的编码方式。\r\n\r\n		* JavaScript = ECMAScript + JavaScript自己特有的东西(BOM+DOM)\r\n\r\n	* ECMAScript：客户端脚本语言的标准\r\n		1. 基本语法：\r\n			1. 与html结合方式\r\n				1. 内部JS：\r\n					* 定义<script>，标签体内容就是js代码\r\n				2. 外部JS：\r\n					* 定义<script>，通过src属性引入外部的js文件\r\n\r\n				* 注意：\r\n					1. <script>可以定义在html页面的任何地方。但是定义的位置会影响执行顺序。\r\n					2. <script>可以定义多个。\r\n			2. 注释\r\n				1. 单行注释：//注释内容\r\n				2. 多行注释：/*注释内容*/\r\n			3. 数据类型：\r\n				1. 原始数据类型(基本数据类型)：\r\n					1. number：数字。 整数/小数/NaN(not a number 一个不是数字的数字类型)\r\n					2. string：字符串。 字符串  \"abc\" \"a\" \'abc\'\r\n					3. boolean: true和false\r\n					4. null：一个对象为空的占位符\r\n					5. undefined：未定义。如果一个变量没有给初始化值，则会被默认赋值为undefined\r\n					\r\n				2. 引用数据类型：对象\r\n				\r\n			4. 变量\r\n				* 变量：一小块存储数据的内存空间\r\n				* Java语言是强类型语言，而JavaScript是弱类型语言。\r\n					* 强类型：在开辟变量存储空间时，定义了空间将来存储的数据的数据类型。只能存储固定类型的数据\r\n					* 弱类型：在开辟变量存储空间时，不定义空间将来的存储数据类型，可以存放任意类型的数据。\r\n				* 语法：\r\n					* var 变量名 = 初始化值;\r\n				\r\n				* typeof运算符：获取变量的类型。\r\n					* 注：null运算后得到的是object\r\n			5. 运算符\r\n				1. 一元运算符：只有一个运算数的运算符\r\n					++，-- ， +(正号)  \r\n					* ++ --: 自增(自减)\r\n						* ++(--) 在前，先自增(自减)，再运算\r\n						* ++(--) 在后，先运算，再自增(自减)\r\n					* +(-)：正负号\r\n				    * 注意：在JS中，如果运算数不是运算符所要求的类型，那么js引擎会自动的将运算数进行类型转换\r\n                        * 其他类型转number：\r\n                            * string转number：按照字面值转换。如果字面值不是数字，则转为NaN（不是数字的数字）\r\n                            * boolean转number：true转为1，false转为0\r\n				2. 算数运算符\r\n					+ - * / % ...\r\n\r\n				3. 赋值运算符\r\n					= += -+....\r\n\r\n				4. 比较运算符\r\n					> < >= <= == ===(全等于)\r\n					* 比较方式\r\n	                  1. 类型相同：直接比较\r\n	                      * 字符串：按照字典顺序比较。按位逐一比较，直到得出大小为止。\r\n	                  2. 类型不同：先进行类型转换，再比较\r\n	                      * ===：全等于。在比较之前，先判断类型，如果类型不一样，则直接返回false\r\n					\r\n\r\n				5. 逻辑运算符\r\n					&& || !\r\n					* 其他类型转boolean：\r\n	                   1. number：0或NaN为假，其他为真\r\n	                   2. string：除了空字符串(\"\")，其他都是true\r\n	                   3. null&undefined:都是false\r\n	                   4. 对象：所有对象都为true\r\n				\r\n				6. 三元运算符\r\n					? : 表达式\r\n					var a = 3;\r\n			        var b = 4;\r\n			\r\n			        var c = a > b ? 1:0;\r\n					* 语法：\r\n						* 表达式? 值1:值2;\r\n						* 判断表达式的值，如果是true则取值1，如果是false则取值2；\r\n				\r\n			6. 流程控制语句：\r\n				1. if...else...\r\n				2. switch:\r\n					* 在java中，switch语句可以接受的数据类型： byte int shor char,枚举(1.5) ,String(1.7)\r\n						* switch(变量):\r\n							case 值:\r\n					* 在JS中,switch语句可以接受任意的原始数据类型\r\n				3. while\r\n				4. do...while\r\n				5. for\r\n			7. JS特殊语法：\r\n				1. 语句以;结尾，如果一行只有一条语句则 ;可以省略 (不建议)\r\n				2. 变量的定义使用var关键字，也可以不使用\r\n            		* 用： 定义的变量是局部变量\r\n	                * 不用：定义的变量是全局变量(不建议)\r\n\r\n			8. 练习：99乘法表\r\n			<!DOCTYPE html>\r\n			<html lang=\"en\">\r\n			<head>\r\n			    <meta charset=\"UTF-8\">\r\n			    <title>99乘法表</title>\r\n			    <style>\r\n			        td{\r\n			            border: 1px solid;\r\n			        }\r\n			\r\n			    </style>\r\n			\r\n			    <script>\r\n			\r\n			        document.write(\"<table  align=\'center\'>\");\r\n			\r\n			\r\n			        //1.完成基本的for循环嵌套，展示乘法表\r\n			        for (var i = 1; i <= 9 ; i++) {\r\n			            document.write(\"<tr>\");\r\n			            for (var j = 1; j <=i ; j++) {\r\n			                document.write(\"<td>\");\r\n			\r\n			                //输出  1 * 1 = 1\r\n			                document.write(i + \" * \" + j + \" = \" + ( i*j) +\"&nbsp;&nbsp;&nbsp;\");\r\n			\r\n			                document.write(\"</td>\");\r\n			            }\r\n			            /*//输出换行\r\n			            document.write(\"<br>\");*/\r\n			\r\n			            document.write(\"</tr>\");\r\n			        }\r\n			\r\n			        //2.完成表格嵌套\r\n			        document.write(\"</table>\");\r\n			\r\n			    </script>\r\n			</head>\r\n			<body>\r\n			\r\n			</body>\r\n			</html>\r\n\r\n		2. 基本对象：\r\n			1. Function：函数(方法)对象\r\n                1. 创建：\r\n                    1. var fun = new Function(形式参数列表,方法体);  //忘掉吧\r\n                    2. \r\n	                    function 方法名称(形式参数列表){\r\n                            方法体\r\n                        }\r\n\r\n                    3. \r\n	                   var 方法名 = function(形式参数列表){\r\n                            方法体\r\n                       }\r\n                2. 方法：\r\n\r\n                3. 属性：\r\n                    length:代表形参的个数\r\n                4. 特点：\r\n                    1. 方法定义是，形参的类型不用写,返回值类型也不写。\r\n                    2. 方法是一个对象，如果定义名称相同的方法，会覆盖\r\n                    3. 在JS中，方法的调用只与方法的名称有关，和参数列表无关\r\n                    4. 在方法声明中有一个隐藏的内置对象（数组），arguments,封装所有的实际参数\r\n                5. 调用：\r\n                    方法名称(实际参数列表);\r\n			\r\n			2. Array:数组对象\r\n                1. 创建：\r\n                    1. var arr = new Array(元素列表);\r\n                    2. var arr = new Array(默认长度);\r\n                    3. var arr = [元素列表];\r\n                2. 方法\r\n                    join(参数):将数组中的元素按照指定的分隔符拼接为字符串\r\n                    push()	向数组的末尾添加一个或更多元素，并返回新的长度。\r\n                3. 属性\r\n                    length:数组的长度\r\n                4. 特点：\r\n                    1. JS中，数组元素的类型可变的。\r\n                    2. JS中，数组长度可变的。\r\n			3. Boolean\r\n			4. Date：日期对象\r\n                1. 创建：\r\n                    var date = new Date();\r\n\r\n                2. 方法：\r\n                    toLocaleString()：返回当前date对象对应的时间本地字符串格式\r\n                    getTime():获取毫秒值。返回当前如期对象描述的时间到1970年1月1日零点的毫秒值差\r\n			5. Math：数学对象\r\n                1. 创建：\r\n                    * 特点：Math对象不用创建，直接使用。  Math.方法名();\r\n\r\n                2. 方法：\r\n                    random():返回 0 ~ 1 之间的随机数。 含0不含1\r\n                    ceil(x)：对数进行上舍入。\r\n                    floor(x)：对数进行下舍入。\r\n                    round(x)：把数四舍五入为最接近的整数。\r\n                3. 属性：\r\n                    PI\r\n			6. Number\r\n			7. String\r\n			8. RegExp：正则表达式对象\r\n				1. 正则表达式：定义字符串的组成规则。\r\n					1. 单个字符:[]\r\n						如： [a] [ab] [a-zA-Z0-9_]\r\n						* 特殊符号代表特殊含义的单个字符:\r\n							\\d:单个数字字符 [0-9]\r\n							\\w:单个单词字符[a-zA-Z0-9_]\r\n					2. 量词符号：\r\n						?：表示出现0次或1次\r\n						*：表示出现0次或多次\r\n						+：出现1次或多次\r\n						{m,n}:表示 m<= 数量 <= n\r\n							* m如果缺省： {,n}:最多n次\r\n							* n如果缺省：{m,} 最少m次\r\n					3. 开始结束符号\r\n						* ^:开始\r\n						* $:结束\r\n				2. 正则对象：\r\n					1. 创建\r\n						1. var reg = new RegExp(\"正则表达式\");\r\n						2. var reg = /正则表达式/;\r\n					2. 方法	\r\n						1. test(参数):验证指定的字符串是否符合正则定义的规范	\r\n			9. Global\r\n				1. 特点：全局对象，这个Global中封装的方法不需要对象就可以直接调用。  方法名();\r\n				2. 方法：\r\n				    encodeURI():url编码\r\n				    decodeURI():url解码\r\n\r\n				    encodeURIComponent():url编码,编码的字符更多\r\n				    decodeURIComponent():url解码\r\n\r\n				    parseInt():将字符串转为数字\r\n				        * 逐一判断每一个字符是否是数字，直到不是数字为止，将前边数字部分转为number\r\n				    isNaN():判断一个值是否是NaN\r\n				        * NaN六亲不认，连自己都不认。NaN参与的==比较全部问false\r\n\r\n				    eval():讲 JavaScript 字符串，并把它作为脚本代码来执行。\r\n                3. URL编码\r\n                   传智播客 =  %E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2\r\n\r\n	* BOM\r\n\r\n	* DOM',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2020-01-17 16:44:56','2020-11-29 11:45:11',0),(52,'JavaScript高级笔记','# 今日内容：\r\n	1. JavaScript：\r\n		1. ECMAScript：\r\n		2. BOM：\r\n		3. DOM：\r\n			1. 事件\r\n\r\n## DOM简单学习：为了满足案例要求\r\n	* 功能：控制html文档的内容\r\n	* 获取页面标签(元素)对象：Element\r\n		* document.getElementById(\"id值\"):通过元素的id获取元素对象\r\n\r\n	* 操作Element对象：\r\n		1. 修改属性值：\r\n			1. 明确获取的对象是哪一个？\r\n			2. 查看API文档，找其中有哪些属性可以设置\r\n		2. 修改标签体内容：\r\n			* 属性：innerHTML\r\n			1. 获取元素对象\r\n			2. 使用innerHTML属性修改标签体内容\r\n\r\n## 事件简单学习\r\n	* 功能： 某些组件被执行了某些操作后，触发某些代码的执行。\r\n		* 造句：  xxx被xxx,我就xxx\r\n			* 我方水晶被摧毁后，我就责备对友。\r\n			* 敌方水晶被摧毁后，我就夸奖自己。\r\n\r\n	* 如何绑定事件\r\n		1. 直接在html标签上，指定事件的属性(操作)，属性值就是js代码\r\n			1. 事件：onclick--- 单击事件\r\n\r\n		2. 通过js获取元素对象，指定事件属性，设置一个函数\r\n\r\n		* 代码：\r\n			<body>\r\n				<img id=\"light\" src=\"img/off.gif\"  onclick=\"fun();\">\r\n				<img id=\"light2\" src=\"img/off.gif\">\r\n				\r\n				<script>\r\n				    function fun(){\r\n				        alert(\'我被点了\');\r\n				        alert(\'我又被点了\');\r\n				    }\r\n				\r\n				    function fun2(){\r\n				        alert(\'咋老点我？\');\r\n				    }\r\n				\r\n				    //1.获取light2对象\r\n				    var light2 = document.getElementById(\"light2\");\r\n				    //2.绑定事件\r\n				    light2.onclick = fun2;\r\n				\r\n				\r\n				</script>\r\n			</body>\r\n	\r\n	* 案例1：电灯开关\r\n		<!DOCTYPE html>\r\n		<html lang=\"en\">\r\n		<head>\r\n		    <meta charset=\"UTF-8\">\r\n		    <title>电灯开关</title>\r\n		\r\n		</head>\r\n		<body>\r\n		\r\n		<img id=\"light\" src=\"img/off.gif\">\r\n		\r\n		<script>\r\n		    /*\r\n		        分析：\r\n		            1.获取图片对象\r\n		            2.绑定单击事件\r\n		            3.每次点击切换图片\r\n		                * 规则：\r\n		                    * 如果灯是开的 on,切换图片为 off\r\n		                    * 如果灯是关的 off,切换图片为 on\r\n		                * 使用标记flag来完成\r\n		\r\n		     */\r\n		\r\n		    //1.获取图片对象\r\n		    var light = document.getElementById(\"light\");\r\n		\r\n		    var flag = false;//代表灯是灭的。 off图片\r\n		\r\n		    //2.绑定单击事件\r\n		    light.onclick = function(){\r\n		        if(flag){//判断如果灯是开的，则灭掉\r\n		            light.src = \"img/off.gif\";\r\n		            flag = false;\r\n		\r\n		        }else{\r\n		            //如果灯是灭的，则打开\r\n		\r\n		            light.src = \"img/on.gif\";\r\n		            flag = true;\r\n		        }\r\n		\r\n		\r\n		    }\r\n		    \r\n		</script>\r\n		</body>\r\n		</html>\r\n\r\n\r\n# BOM:\r\n	1. 概念：Browser Object Model 浏览器对象模型\r\n		* 将浏览器的各个组成部分封装成对象。\r\n\r\n	2. 组成：\r\n		* Window：窗口对象\r\n		* Navigator：浏览器对象\r\n		* Screen：显示器屏幕对象\r\n		* History：历史记录对象\r\n		* Location：地址栏对象\r\n\r\n	3. Window：窗口对象\r\n	    1. 创建\r\n	    2. 方法\r\n	         1. 与弹出框有关的方法：\r\n	            alert()	显示带有一段消息和一个确认按钮的警告框。\r\n	            confirm()	显示带有一段消息以及确认按钮和取消按钮的对话框。\r\n	                * 如果用户点击确定按钮，则方法返回true\r\n	                * 如果用户点击取消按钮，则方法返回false\r\n	            prompt()	显示可提示用户输入的对话框。\r\n	                * 返回值：获取用户输入的值\r\n	         2. 与打开关闭有关的方法：\r\n	            close()	关闭浏览器窗口。\r\n	                * 谁调用我 ，我关谁\r\n	            open()	打开一个新的浏览器窗口\r\n	                * 返回新的Window对象\r\n	         3. 与定时器有关的方式\r\n	            setTimeout()	在指定的毫秒数后调用函数或计算表达式。\r\n	                * 参数：\r\n	                    1. js代码或者方法对象\r\n	                    2. 毫秒值\r\n	                * 返回值：唯一标识，用于取消定时器\r\n	            clearTimeout()	取消由 setTimeout() 方法设置的 timeout。\r\n	\r\n	            setInterval()	按照指定的周期（以毫秒计）来调用函数或计算表达式。\r\n	            clearInterval()	取消由 setInterval() 设置的 timeout。\r\n	\r\n	    3. 属性：\r\n	        1. 获取其他BOM对象：\r\n	            history\r\n	            location\r\n	            Navigator\r\n	            Screen:\r\n	        2. 获取DOM对象\r\n	            document\r\n	    4. 特点\r\n	        * Window对象不需要创建可以直接使用 window使用。 window.方法名();\r\n	        * window引用可以省略。  方法名();\r\n\r\n\r\n	4. Location：地址栏对象\r\n		1. 创建(获取)：\r\n			1. window.location\r\n			2. location\r\n\r\n		2. 方法：\r\n			* reload()	重新加载当前文档。刷新\r\n		3. 属性\r\n			* href	设置或返回完整的 URL。\r\n\r\n\r\n	5. History：历史记录对象\r\n        1. 创建(获取)：\r\n            1. window.history\r\n            2. history\r\n\r\n        2. 方法：\r\n            * back()	加载 history 列表中的前一个 URL。\r\n            * forward()	加载 history 列表中的下一个 URL。\r\n            * go(参数)	加载 history 列表中的某个具体页面。\r\n                * 参数：\r\n                    * 正数：前进几个历史记录\r\n                    * 负数：后退几个历史记录\r\n        3. 属性：\r\n            * length	返回当前窗口历史列表中的 URL 数量。\r\n\r\n\r\n\r\n\r\n## DOM：\r\n	* 概念： Document Object Model 文档对象模型\r\n		* 将标记语言文档的各个组成部分，封装为对象。可以使用这些对象，对标记语言文档进行CRUD的动态操作\r\n\r\n	* W3C DOM 标准被分为 3 个不同的部分：\r\n\r\n		* 核心 DOM - 针对任何结构化文档的标准模型\r\n			* Document：文档对象\r\n			* Element：元素对象\r\n			* Attribute：属性对象\r\n			* Text：文本对象\r\n			* Comment:注释对象\r\n\r\n			* Node：节点对象，其他5个的父对象\r\n		* XML DOM - 针对 XML 文档的标准模型\r\n		* HTML DOM - 针对 HTML 文档的标准模型\r\n\r\n\r\n\r\n\r\n\r\n	* 核心DOM模型：\r\n		* Document：文档对象\r\n			1. 创建(获取)：在html dom模型中可以使用window对象来获取\r\n				1. window.document\r\n				2. document\r\n			2. 方法：\r\n				1. 获取Element对象：\r\n					1. getElementById()	： 根据id属性值获取元素对象。id属性值一般唯一\r\n					2. getElementsByTagName()：根据元素名称获取元素对象们。返回值是一个数组\r\n					3. getElementsByClassName():根据Class属性值获取元素对象们。返回值是一个数组\r\n					4. getElementsByName(): 根据name属性值获取元素对象们。返回值是一个数组\r\n				2. 创建其他DOM对象：\r\n					createAttribute(name)\r\n                	createComment()\r\n                	createElement()\r\n                	createTextNode()\r\n			3. 属性\r\n		* Element：元素对象\r\n			1. 获取/创建：通过document来获取和创建\r\n			2. 方法：\r\n				1. removeAttribute()：删除属性\r\n				2. setAttribute()：设置属性\r\n		* Node：节点对象，其他5个的父对象\r\n			* 特点：所有dom对象都可以被认为是一个节点\r\n			* 方法：\r\n				* CRUD dom树：\r\n					* appendChild()：向节点的子节点列表的结尾添加新的子节点。\r\n					* removeChild()	：删除（并返回）当前节点的指定子节点。\r\n					* replaceChild()：用新节点替换一个子节点。\r\n			* 属性：\r\n				* parentNode 返回节点的父节点。\r\n\r\n\r\n	* HTML DOM\r\n		1. 标签体的设置和获取：innerHTML\r\n		2. 使用html元素对象的属性\r\n		3. 控制元素样式\r\n			1. 使用元素的style属性来设置\r\n				如：\r\n					 //修改样式方式1\r\n			        div1.style.border = \"1px solid red\";\r\n			        div1.style.width = \"200px\";\r\n			        //font-size--> fontSize\r\n			        div1.style.fontSize = \"20px\";\r\n			2. 提前定义好类选择器的样式，通过元素的className属性来设置其class属性值。\r\n\r\n\r\n## 事件监听机制：\r\n	* 概念：某些组件被执行了某些操作后，触发某些代码的执行。	\r\n		* 事件：某些操作。如： 单击，双击，键盘按下了，鼠标移动了\r\n		* 事件源：组件。如： 按钮 文本输入框...\r\n		* 监听器：代码。\r\n		* 注册监听：将事件，事件源，监听器结合在一起。 当事件源上发生了某个事件，则触发执行某个监听器代码。\r\n\r\n\r\n	* 常见的事件：\r\n		1. 点击事件：\r\n			1. onclick：单击事件\r\n			2. ondblclick：双击事件\r\n		2. 焦点事件\r\n			1. onblur：失去焦点\r\n			2. onfocus:元素获得焦点。\r\n\r\n		3. 加载事件：\r\n			1. onload：一张页面或一幅图像完成加载。\r\n\r\n		4. 鼠标事件：\r\n			1. onmousedown	鼠标按钮被按下。\r\n			2. onmouseup	鼠标按键被松开。\r\n			3. onmousemove	鼠标被移动。\r\n			4. onmouseover	鼠标移到某元素之上。\r\n			5. onmouseout	鼠标从某元素移开。\r\n			\r\n			\r\n		5. 键盘事件：\r\n			1. onkeydown	某个键盘按键被按下。	\r\n			2. onkeyup		某个键盘按键被松开。\r\n			3. onkeypress	某个键盘按键被按下并松开。\r\n\r\n		6. 选择和改变\r\n			1. onchange	域的内容被改变。\r\n			2. onselect	文本被选中。\r\n\r\n		7. 表单事件：\r\n			1. onsubmit	确认按钮被点击。\r\n			2. onreset	重置按钮被点击。',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2020-01-17 16:42:08','2020-11-29 11:45:11',0),(53,'表单校验','外部进行事件绑定后调用函数\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>常见事件</title>\n\n    <script>\n    \n        window.onload = function(){\n            document.getElementById(\"form\").onsubmit = function(){\n                //校验用户名格式是否正确\n                var flag = false;\n                return flag;\n            }\n        }\n    </script>\n\n</head>\n<body>\n\n<!--\n    function fun(){\n       return  checkForm();\n    }\n\n -->\n<form action=\"#\" id=\"form\">\n<input name=\"username\" id=\"username\">\n\n<select id=\"city\">\n    <option>--请选择--</option>\n    <option>北京</option>\n    <option>上海</option>\n    <option>西安</option>\n</select>\n<input type=\"submit\" value=\"提交\">\n</form>\n</body>\n</html>\n```\n返回布尔类型\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>常见事件</title>\n\n    <script>\n        function checkForm(){\n            return false;\n        }\n    </script>\n\n</head>\n<body>\n\n<form action=\"#\" id=\"form\" onclick=\"return checkFrom()\">\n<input name=\"username\" id=\"username\">\n\n<select id=\"city\">\n    <option>--请选择--</option>\n    <option>北京</option>\n    <option>上海</option>\n    <option>西安</option>\n</select>\n<input type=\"submit\" value=\"提交\">\n</form>\n</body>\n</html>',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2020-02-20 21:08:18','2020-11-29 11:45:11',0),(54,'EL&JSTL笔记','# 今日内容\r\n	1. JSP:\r\n		1. 指令\r\n		2. 注释\r\n		3. 内置对象\r\n\r\n	2. MVC开发模式\r\n	3. EL表达式\r\n	4. JSTL标签\r\n	5. 三层架构\r\n\r\n\r\n\r\n## JSP:\r\n	1. 指令\r\n		* 作用：用于配置JSP页面，导入资源文件\r\n		* 格式：\r\n			<%@ 指令名称 属性名1=属性值1 属性名2=属性值2 ... %>\r\n		* 分类：\r\n			1. page		： 配置JSP页面的\r\n				* contentType：等同于response.setContentType()\r\n					1. 设置响应体的mime类型以及字符集\r\n					2. 设置当前jsp页面的编码（只能是高级的IDE才能生效，如果使用低级工具，则需要设置pageEncoding属性设置当前页面的字符集）\r\n				* import：导包\r\n				* errorPage：当前页面发生异常后，会自动跳转到指定的错误页面\r\n				* isErrorPage：标识当前也是是否是错误页面。\r\n					* true：是，可以使用内置对象exception\r\n					* false：否。默认值。不可以使用内置对象exception\r\n\r\n\r\n			2. include	： 页面包含的。导入页面的资源文件\r\n				* <%@include file=\"top.jsp\"%>\r\n			3. taglib	： 导入资源\r\n				* <%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %>\r\n					* prefix：前缀，自定义的\r\n	2. 注释:\r\n		1. html注释：\r\n			<!-- -->:只能注释html代码片段\r\n		2. jsp注释：推荐使用\r\n			<%-- --%>：可以注释所有\r\n\r\n\r\n	3. 内置对象\r\n		* 在jsp页面中不需要创建，直接使用的对象\r\n		* 一共有9个：\r\n				变量名					真实类型						作用\r\n			* pageContext				PageContext					当前页面共享数据，还可以获取其他八个内置对象\r\n			* request					HttpServletRequest			一次请求访问的多个资源(转发)\r\n			* session					HttpSession					一次会话的多个请求间\r\n			* application				ServletContext				所有用户间共享数据\r\n			* response					HttpServletResponse			响应对象\r\n			* page						Object						当前页面(Servlet)的对象  this\r\n			* out						JspWriter					输出对象，数据输出到页面上\r\n			* config					ServletConfig				Servlet的配置对象\r\n			* exception					Throwable					异常对象\r\n\r\n	\r\n\r\n\r\n## MVC：开发模式	\r\n	1. jsp演变历史\r\n		1. 早期只有servlet，只能使用response输出标签数据，非常麻烦\r\n		2. 后来又jsp，简化了Servlet的开发，如果过度使用jsp，在jsp中即写大量的java代码，有写html表，造成难于维护，难于分工协作\r\n		3. 再后来，java的web开发，借鉴mvc开发模式，使得程序的设计更加合理性\r\n\r\n	2. MVC：\r\n		1. M：Model，模型。JavaBean\r\n			* 完成具体的业务操作，如：查询数据库，封装对象\r\n		2. V：View，视图。JSP\r\n			* 展示数据\r\n		3. C：Controller，控制器。Servlet\r\n			* 获取用户的输入\r\n			* 调用模型\r\n			* 将数据交给视图进行展示\r\n\r\n\r\n		* 优缺点：\r\n			1. 优点：\r\n				1. 耦合性低，方便维护，可以利于分工协作\r\n				2. 重用性高\r\n\r\n			2. 缺点：\r\n				1. 使得项目架构变得复杂，对开发人员要求高\r\n\r\n\r\n\r\n\r\n\r\n## EL表达式\r\n	1. 概念：Expression Language 表达式语言\r\n	2. 作用：替换和简化jsp页面中java代码的编写\r\n	3. 语法：${表达式}\r\n	4. 注意：\r\n		* jsp默认支持el表达式的。如果要忽略el表达式\r\n			1. 设置jsp中page指令中：isELIgnored=\"true\" 忽略当前jsp页面中所有的el表达式\r\n			2. \\${表达式} ：忽略当前这个el表达式\r\n\r\n\r\n	5. 使用：\r\n		1. 运算：\r\n			* 运算符：\r\n				1. 算数运算符： + - * /(div) %(mod)\r\n				2. 比较运算符： > < >= <= == !=\r\n				3. 逻辑运算符： &&(and) ||(or) !(not)\r\n				4. 空运算符： empty\r\n					* 功能：用于判断字符串、集合、数组对象是否为null或者长度是否为0\r\n					* ${empty list}:判断字符串、集合、数组对象是否为null或者长度为0\r\n					* ${not empty str}:表示判断字符串、集合、数组对象是否不为null 并且 长度>0\r\n		2. 获取值\r\n			1. el表达式只能从域对象中获取值\r\n			2. 语法：\r\n				1. ${域名称.键名}：从指定域中获取指定键的值\r\n					* 域名称：\r\n						1. pageScope		--> pageContext\r\n						2. requestScope 	--> request\r\n						3. sessionScope 	--> session\r\n						4. applicationScope --> application（ServletContext）\r\n					* 举例：在request域中存储了name=张三\r\n					* 获取：${requestScope.name}\r\n\r\n				2. ${键名}：表示依次从最小的域中查找是否有该键对应的值，直到找到为止。\r\n\r\n				\r\n				\r\n				3. 获取对象、List集合、Map集合的值\r\n					1. 对象：${域名称.键名.属性名}\r\n						* 本质上会去调用对象的getter方法\r\n\r\n					2. List集合：${域名称.键名[索引]}\r\n\r\n					3. Map集合：\r\n						* ${域名称.键名.key名称}\r\n						* ${域名称.键名[\"key名称\"]}\r\n\r\n\r\n		3. 隐式对象：\r\n			* el表达式中有11个隐式对象\r\n			* pageContext：\r\n				* 获取jsp其他八个内置对象\r\n					* ${pageContext.request.contextPath}：动态获取虚拟目录\r\n					\r\n	\r\n## JSTL\r\n	1. 概念：JavaServer Pages Tag Library  JSP标准标签库\r\n		* 是由Apache组织提供的开源的免费的jsp标签		<标签>\r\n\r\n	2. 作用：用于简化和替换jsp页面上的java代码		\r\n\r\n	3. 使用步骤：\r\n		1. 导入jstl相关jar包\r\n		2. 引入标签库：taglib指令：  <%@ taglib %>\r\n		3. 使用标签\r\n	\r\n	4. 常用的JSTL标签\r\n		1. if:相当于java代码的if语句\r\n			1. 属性：\r\n	            * test 必须属性，接受boolean表达式\r\n	                * 如果表达式为true，则显示if标签体内容，如果为false，则不显示标签体内容\r\n	                * 一般情况下，test属性值会结合el表达式一起使用\r\n       		 2. 注意：\r\n	       		 * c:if标签没有else情况，想要else情况，则可以在定义一个c:if标签\r\n		2. choose:相当于java代码的switch语句\r\n			1. 使用choose标签声明         			相当于switch声明\r\n            2. 使用when标签做判断         			相当于case\r\n            3. 使用otherwise标签做其他情况的声明    	相当于default\r\n\r\n		3. foreach:相当于java代码的for语句\r\n\r\n	5. 练习：\r\n		* 需求：在request域中有一个存有User对象的List集合。需要使用jstl+el将list集合数据展示到jsp页面的表格table中\r\n\r\n\r\n\r\n\r\n\r\n## 三层架构：软件设计架构\r\n	1. 界面层(表示层)：用户看的得界面。用户可以通过界面上的组件和服务器进行交互\r\n	2. 业务逻辑层：处理业务逻辑的。\r\n	3. 数据访问层：操作数据存储文件。\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n## 案例：用户信息列表展示\r\n	1. 需求：用户信息的增删改查操作\r\n	2. 设计：\r\n		1. 技术选型：Servlet+JSP+MySQL+JDBCTempleat+Duird+BeanUtilS+tomcat\r\n		2. 数据库设计：\r\n			create database day17; -- 创建数据库\r\n			use day17; 			   -- 使用数据库\r\n			create table user(   -- 创建表\r\n				id int primary key auto_increment,\r\n				name varchar(20) not null,\r\n				gender varchar(5),\r\n				age int,\r\n				address varchar(32),\r\n				qq	varchar(20),\r\n				email varchar(50)\r\n			);\r\n\r\n	3. 开发：\r\n		1. 环境搭建\r\n			1. 创建数据库环境\r\n			2. 创建项目，导入需要的jar包\r\n\r\n		2. 编码\r\n	\r\n\r\n	4. 测试\r\n	5. 部署运维',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2020-03-05 12:25:29','2020-11-29 11:45:11',0),(55,'综合练习笔记','# 今日内容\r\n	1. 综合练习\r\n		1. 简单功能\r\n			1. 列表查询\r\n			2. 登录\r\n			3. 添加\r\n			4. 删除\r\n			5. 修改\r\n			\r\n		2. 复杂功能\r\n			1. 删除选中\r\n			2. 分页查询\r\n				* 好处：\r\n					1. 减轻服务器内存的开销\r\n					2. 提升用户体验\r\n			3. 复杂条件查询\r\n\r\n\r\n\r\n\r\n## 2. 登录\r\n	1. 调整页面，加入验证码功能\r\n	2. 代码实现',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2020-01-17 16:14:03','2020-11-29 11:45:11',0),(56,'JQuery基础笔记','## 今日内容\r\n	1. JQuery 基础：\r\n		1. 概念\r\n		2. 快速入门\r\n		3. JQuery对象和JS对象区别与转换\r\n		4. 选择器\r\n		5. DOM操作\r\n		6. 案例\r\n\r\n\r\n\r\n\r\n# JQuery 基础：\r\n	1. 概念： 一个JavaScript框架。简化JS开发\r\n		* jQuery是一个快速、简洁的JavaScript框架，是继Prototype之后又一个优秀的JavaScript代码库（或JavaScript框架）。jQuery设计的宗旨	是“write Less，Do More”，即倡导写更少的代码，做更多的事情。它封装JavaScript常用的功能代码，提供一种简便的JavaScript设计模式，优	化HTML文档操作、事件处理、动画设计和Ajax交互。\r\n\r\n		* JavaScript框架：本质上就是一些js文件，封装了js的原生代码而已\r\n	2. 快速入门\r\n		1. 步骤：\r\n			1. 下载JQuery\r\n				* 目前jQuery有三个大版本：\r\n					1.x：兼容ie678,使用最为广泛的，官方只做BUG维护，\r\n						 功能不再新增。因此一般项目来说，使用1.x版本就可以了，\r\n						 最终版本：1.12.4 (2016年5月20日)\r\n					2.x：不兼容ie678，很少有人使用，官方只做BUG维护，\r\n						 功能不再新增。如果不考虑兼容低版本的浏览器可以使用2.x，\r\n						 最终版本：2.2.4 (2016年5月20日)\r\n					3.x：不兼容ie678，只支持最新的浏览器。除非特殊要求，\r\n						 一般不会使用3.x版本的，很多老的jQuery插件不支持这个版本。\r\n						 目前该版本是官方主要更新维护的版本。最新版本：3.2.1（2017年3月20日）\r\n				* jquery-xxx.js 与 jquery-xxx.min.js区别：\r\n					1. jquery-xxx.js：开发版本。给程序员看的，有良好的缩进和注释。体积大一些\r\n					2. jquery-xxx.min.js：生产版本。程序中使用，没有缩进。体积小一些。程序加载更快\r\n\r\n			2. 导入JQuery的js文件：导入min.js文件\r\n			3. 使用\r\n				var div1 = $(\"#div1\");\r\n   				alert(div1.html());\r\n\r\n\r\n	3. JQuery对象和JS对象区别与转换\r\n		1. JQuery对象在操作时，更加方便。\r\n        2. JQuery对象和js对象方法不通用的.\r\n        3. 两者相互转换\r\n            * jq -- > js : jq对象[索引] 或者 jq对象.get(索引)\r\n            * js -- > jq : $(js对象)\r\n\r\n\r\n	4. 选择器：筛选具有相似特征的元素(标签)\r\n\r\n		1. 基本操作学习：\r\n			1. 事件绑定\r\n				//1.获取b1按钮\r\n	            $(\"#b1\").click(function(){\r\n	                alert(\"abc\");\r\n	            });\r\n			2. 入口函数\r\n				 $(function () {\r\n		           \r\n       			 });\r\n				 window.onload  和 $(function) 区别\r\n	                 * window.onload 只能定义一次,如果定义多次，后边的会将前边的覆盖掉\r\n	                 * $(function)可以定义多次的。\r\n			3. 样式控制：css方法\r\n				 // $(\"#div1\").css(\"background-color\",\"red\");\r\n          		$(\"#div1\").css(\"backgroundColor\",\"pink\");\r\n\r\n\r\n		2. 分类\r\n			1. 基本选择器\r\n				1. 标签选择器（元素选择器）\r\n					* 语法： $(\"html标签名\") 获得所有匹配标签名称的元素\r\n				2. id选择器 \r\n					* 语法： $(\"#id的属性值\") 获得与指定id属性值匹配的元素\r\n				3. 类选择器\r\n					* 语法： $(\".class的属性值\") 获得与指定的class属性值匹配的元素\r\n				4. 并集选择器：\r\n					* 语法： $(\"选择器1,选择器2....\") 获取多个选择器选中的所有元素\r\n			2. 层级选择器\r\n				1. 后代选择器\r\n					* 语法： $(\"A B \") 选择A元素内部的所有B元素		\r\n				2. 子选择器\r\n					* 语法： $(\"A > B\") 选择A元素内部的所有B子元素\r\n			3. 属性选择器\r\n				1. 属性名称选择器 \r\n					* 语法： $(\"A[属性名]\") 包含指定属性的选择器\r\n				2. 属性选择器\r\n					* 语法： $(\"A[属性名=\'值\']\") 包含指定属性等于指定值的选择器\r\n				3. 复合属性选择器\r\n					* 语法： $(\"A[属性名=\'值\'][]...\") 包含多个属性条件的选择器\r\n			4. 过滤选择器\r\n				1. 首元素选择器 \r\n					* 语法： :first 获得选择的元素中的第一个元素\r\n				2. 尾元素选择器 \r\n					* 语法： :last 获得选择的元素中的最后一个元素\r\n				3. 非元素选择器\r\n					* 语法： :not(selector) 不包括指定内容的元素\r\n				4. 偶数选择器\r\n					* 语法： :even 偶数，从 0 开始计数\r\n				5. 奇数选择器\r\n					* 语法： :odd 奇数，从 0 开始计数\r\n				6. 等于索引选择器\r\n					* 语法： :eq(index) 指定索引元素\r\n				7. 大于索引选择器 \r\n					* 语法： :gt(index) 大于指定索引元素\r\n				8. 小于索引选择器 \r\n					* 语法： :lt(index) 小于指定索引元素\r\n				9. 标题选择器\r\n					* 语法： :header 获得标题（h1~h6）元素，固定写法\r\n			5. 表单过滤选择器\r\n				1. 可用元素选择器 \r\n					* 语法： :enabled 获得可用元素\r\n				2. 不可用元素选择器 \r\n					* 语法： :disabled 获得不可用元素\r\n				3. 选中选择器 \r\n					* 语法： :checked 获得单选/复选框选中的元素\r\n				4. 选中选择器 \r\n					* 语法： :selected 获得下拉框选中的元素\r\n	\r\n	5. DOM操作\r\n		1. 内容操作\r\n			1. html(): 获取/设置元素的标签体内容   <a><font>内容</font></a>  --> <font>内容</font>\r\n			2. text(): 获取/设置元素的标签体纯文本内容   <a><font>内容</font></a> --> 内容\r\n			3. val()： 获取/设置元素的value属性值\r\n		2. 属性操作\r\n			1. 通用属性操作\r\n				1. attr(): 获取/设置元素的属性\r\n				2. removeAttr():删除属性\r\n				3. prop():获取/设置元素的属性\r\n				4. removeProp():删除属性\r\n\r\n				* attr和prop区别？\r\n					1. 如果操作的是元素的固有属性，则建议使用prop\r\n					2. 如果操作的是元素自定义的属性，则建议使用attr\r\n			2. 对class属性操作\r\n				1. addClass():添加class属性值\r\n				2. removeClass():删除class属性值\r\n				3. toggleClass():切换class属性\r\n					* toggleClass(\"one\"): \r\n						* 判断如果元素对象上存在class=\"one\"，则将属性值one删除掉。  如果元素对象上不存在class=\"one\"，则添加\r\n				4. css():\r\n		3. CRUD操作:\r\n			1. append():父元素将子元素追加到末尾\r\n				* 对象1.append(对象2): 将对象2添加到对象1元素内部，并且在末尾\r\n			2. prepend():父元素将子元素追加到开头\r\n				* 对象1.prepend(对象2):将对象2添加到对象1元素内部，并且在开头\r\n			3. appendTo():\r\n				* 对象1.appendTo(对象2):将对象1添加到对象2内部，并且在末尾\r\n			4. prependTo()：\r\n				* 对象1.prependTo(对象2):将对象1添加到对象2内部，并且在开头\r\n\r\n\r\n			5. after():添加元素到元素后边\r\n				* 对象1.after(对象2)： 将对象2添加到对象1后边。对象1和对象2是兄弟关系\r\n			6. before():添加元素到元素前边\r\n				* 对象1.before(对象2)： 将对象2添加到对象1前边。对象1和对象2是兄弟关系\r\n			7. insertAfter()\r\n				* 对象1.insertAfter(对象2)：将对象2添加到对象1后边。对象1和对象2是兄弟关系\r\n			8. insertBefore()\r\n				* 对象1.insertBefore(对象2)： 将对象2添加到对象1前边。对象1和对象2是兄弟关系\r\n\r\n			9. remove():移除元素\r\n				* 对象.remove():将对象删除掉\r\n			10. empty():清空元素的所有后代元素。\r\n				* 对象.empty():将对象的后代元素全部清空，但是保留当前对象以及其属性节点\r\n\r\n\r\n	6. 案例',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2020-01-17 16:08:21','2020-11-29 11:45:11',0),(57,'JQuery高级笔记','## 今日内容：\r\n	1. JQuery 高级\r\n		1. 动画\r\n		2. 遍历\r\n		3. 事件绑定\r\n		4. 案例\r\n		5. 插件\r\n\r\n\r\n\r\n## JQuery 高级\r\n	1. 动画\r\n		1. 三种方式显示和隐藏元素\r\n			1. 默认显示和隐藏方式\r\n				1. show([speed,[easing],[fn]])\r\n					1. 参数：\r\n						1. speed：动画的速度。三个预定义的值(\"slow\",\"normal\", \"fast\")或表示动画时长的毫秒数值(如：1000)\r\n						2. easing：用来指定切换效果，默认是\"swing\"，可用参数\"linear\"\r\n							* swing：动画执行时效果是 先慢，中间快，最后又慢\r\n							* linear：动画执行时速度是匀速的\r\n						3. fn：在动画完成时执行的函数，每个元素执行一次。\r\n	\r\n				2. hide([speed,[easing],[fn]])\r\n				3. toggle([speed],[easing],[fn])\r\n			\r\n			2. 滑动显示和隐藏方式\r\n				1. slideDown([speed],[easing],[fn])\r\n				2. slideUp([speed,[easing],[fn]])\r\n				3. slideToggle([speed],[easing],[fn])\r\n	\r\n			3. 淡入淡出显示和隐藏方式\r\n				1. fadeIn([speed],[easing],[fn])\r\n				2. fadeOut([speed],[easing],[fn])\r\n				3. fadeToggle([speed,[easing],[fn]])\r\n\r\n	2. 遍历\r\n		1. js的遍历方式\r\n			* for(初始化值;循环结束条件;步长)\r\n		2. jq的遍历方式\r\n			1. jq对象.each(callback)\r\n				1. 语法：\r\n					jquery对象.each(function(index,element){});\r\n						* index:就是元素在集合中的索引\r\n						* element：就是集合中的每一个元素对象\r\n	\r\n						* this：集合中的每一个元素对象\r\n				2. 回调函数返回值：\r\n					* true:如果当前function返回为false，则结束循环(break)。\r\n					* false:如果当前function返回为true，则结束本次循环，继续下次循环(continue)\r\n			2. $.each(object, [callback])\r\n			3. for..of: jquery 3.0 版本之后提供的方式\r\n				for(元素对象 of 容器对象)\r\n		\r\n	3. 事件绑定\r\n		1. jquery标准的绑定方式\r\n			* jq对象.事件方法(回调函数)；\r\n			* 注：如果调用事件方法，不传递回调函数，则会触发浏览器默认行为。\r\n				* 表单对象.submit();//让表单提交\r\n		2. on绑定事件/off解除绑定\r\n			* jq对象.on(\"事件名称\",回调函数)\r\n			* jq对象.off(\"事件名称\")\r\n				* 如果off方法不传递任何参数，则将组件上的所有事件全部解绑\r\n		3. 事件切换：toggle\r\n			* jq对象.toggle(fn1,fn2...)\r\n				* 当单击jq对象对应的组件后，会执行fn1.第二次点击会执行fn2.....\r\n				\r\n			* 注意：1.9版本 .toggle() 方法删除,jQuery Migrate（迁移）插件可以恢复此功能。\r\n				 <script src=\"../js/jquery-migrate-1.0.0.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\r\n\r\n	4. 案例\r\n		1. 广告显示和隐藏\r\n			<!DOCTYPE html>\r\n			<html>\r\n			<head>\r\n			    <meta charset=\"UTF-8\">\r\n			    <title>广告的自动显示与隐藏</title>\r\n			    <style>\r\n			        #content{width:100%;height:500px;background:#999}\r\n			    </style>\r\n			\r\n			    <!--引入jquery-->\r\n			    <script type=\"text/javascript\" src=\"../js/jquery-3.3.1.min.js\"></script>\r\n			    <script>\r\n			        /*\r\n			            需求：\r\n			                1. 当页面加载完，3秒后。自动显示广告\r\n			                2. 广告显示5秒后，自动消失。\r\n			\r\n			            分析：\r\n			                1. 使用定时器来完成。setTimeout (执行一次定时器)\r\n			                2. 分析发现JQuery的显示和隐藏动画效果其实就是控制display\r\n			                3. 使用  show/hide方法来完成广告的显示\r\n			         */\r\n			\r\n			        //入口函数，在页面加载完成之后，定义定时器，调用这两个方法\r\n			        $(function () {\r\n			           //定义定时器，调用adShow方法 3秒后执行一次\r\n			           setTimeout(adShow,3000);\r\n			           //定义定时器，调用adHide方法，8秒后执行一次\r\n			            setTimeout(adHide,8000);\r\n			        });\r\n			        //显示广告\r\n			        function adShow() {\r\n			            //获取广告div，调用显示方法\r\n			            $(\"#ad\").show(\"slow\");\r\n			        }\r\n			        //隐藏广告\r\n			        function adHide() {\r\n			            //获取广告div，调用隐藏方法\r\n			            $(\"#ad\").hide(\"slow\");\r\n			        }\r\n\r\n\r\n​			\r\n			    </script>\r\n			</head>\r\n			<body>\r\n			<!-- 整体的DIV -->\r\n			<div>\r\n			    <!-- 广告DIV -->\r\n			    <div id=\"ad\" style=\"display: none;\">\r\n			        <img style=\"width:100%\" src=\"../img/adv.jpg\" />\r\n			    </div>\r\n			\r\n			    <!-- 下方正文部分 -->\r\n			    <div id=\"content\">\r\n			        正文部分\r\n			    </div>\r\n			</div>\r\n			</body>\r\n			</html>\r\n\r\n\r\n		2. 抽奖\r\n			<!DOCTYPE html>\r\n			<html>\r\n			<head>\r\n			    <meta charset=\"UTF-8\">\r\n			    <title>jquery案例之抽奖</title>\r\n			    <script type=\"text/javascript\" src=\"../js/jquery-3.3.1.min.js\"></script>\r\n			\r\n			    <script language=\'javascript\' type=\'text/javascript\'>\r\n			\r\n			        /*\r\n			            分析：\r\n			                1. 给开始按钮绑定单击事件\r\n			                    1.1 定义循环定时器\r\n			                    1.2 切换小相框的src属性\r\n			                        * 定义数组，存放图片资源路径\r\n			                        * 生成随机数。数组索引\r\n\r\n\r\n			                2. 给结束按钮绑定单击事件\r\n			                    1.1 停止定时器\r\n			                    1.2 给大相框设置src属性\r\n			\r\n			         */\r\n			        var imgs = [\"../img/man00.jpg\",\r\n			                    \"../img/man01.jpg\",\r\n			                    \"../img/man02.jpg\",\r\n			                    \"../img/man03.jpg\",\r\n			                    \"../img/man04.jpg\",\r\n			                    \"../img/man05.jpg\",\r\n			                    \"../img/man06.jpg\",\r\n			                    ];\r\n			        var startId;//开始定时器的id\r\n			        var index;//随机角标\r\n			        $(function () {\r\n			            //处理按钮是否可以使用的效果\r\n			            $(\"#startID\").prop(\"disabled\",false);\r\n			            $(\"#stopID\").prop(\"disabled\",true);\r\n\r\n\r\n			           //1. 给开始按钮绑定单击事件\r\n			            $(\"#startID\").click(function () {\r\n			                // 1.1 定义循环定时器 20毫秒执行一次\r\n			                startId = setInterval(function () {\r\n			                    //处理按钮是否可以使用的效果\r\n			                    $(\"#startID\").prop(\"disabled\",true);\r\n			                    $(\"#stopID\").prop(\"disabled\",false);\r\n\r\n\r\n			                    //1.2生成随机角标 0-6\r\n			                    index = Math.floor(Math.random() * 7);//0.000--0.999 --> * 7 --> 0.0-----6.9999\r\n			                    //1.3设置小相框的src属性\r\n			                    $(\"#img1ID\").prop(\"src\",imgs[index]);\r\n			\r\n			                },20);\r\n			            });\r\n\r\n\r\n			            //2. 给结束按钮绑定单击事件\r\n			            $(\"#stopID\").click(function () {\r\n			                //处理按钮是否可以使用的效果\r\n			                $(\"#startID\").prop(\"disabled\",false);\r\n			                $(\"#stopID\").prop(\"disabled\",true);\r\n\r\n\r\n			               // 1.1 停止定时器\r\n			                clearInterval(startId);\r\n			               // 1.2 给大相框设置src属性\r\n			                $(\"#img2ID\").prop(\"src\",imgs[index]).hide();\r\n			                //显示1秒之后\r\n			                $(\"#img2ID\").show(1000);\r\n			            });\r\n			        });\r\n\r\n\r\n​			\r\n​			\r\n			    </script>\r\n			\r\n			</head>\r\n			<body>\r\n			\r\n			<!-- 小像框 -->\r\n			<div style=\"border-style:dotted;width:160px;height:100px\">\r\n			    <img id=\"img1ID\" src=\"../img/man00.jpg\" style=\"width:160px;height:100px\"/>\r\n			</div>\r\n			\r\n			<!-- 大像框 -->\r\n			<div\r\n			        style=\"border-style:double;width:800px;height:500px;position:absolute;left:500px;top:10px\">\r\n			    <img id=\"img2ID\" src=\"../img/man00.jpg\" width=\"800px\" height=\"500px\"/>\r\n			</div>\r\n			\r\n			<!-- 开始按钮 -->\r\n			<input\r\n			        id=\"startID\"\r\n			        type=\"button\"\r\n			        value=\"点击开始\"\r\n			        style=\"width:150px;height:150px;font-size:22px\">\r\n			\r\n			<!-- 停止按钮 -->\r\n			<input\r\n			        id=\"stopID\"\r\n			        type=\"button\"\r\n			        value=\"点击停止\"\r\n			        style=\"width:150px;height:150px;font-size:22px\">\r\n\r\n\r\n			</body>\r\n			</html>\r\n	\r\n	5. 插件：增强JQuery的功能\r\n		1. 实现方式：\r\n			1. $.fn.extend(object) \r\n				* 增强通过Jquery获取的对象的功能  $(\"#id\")\r\n			2. $.extend(object)\r\n				* 增强JQeury对象自身的功能  $/jQuery',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2020-01-17 16:06:13','2020-11-29 11:45:11',0),(58,'maven language level 问题','language level：限定项目编译检查时最低要求的 JDK 特性<br>\r\n修改 安装目录\\maven2\\conf\\settings.xml \r\n```xml\r\n<profiles>   \r\n      <profile>     \r\n           <id>jdk-1.6</id>     \r\n           <activation>     \r\n               <activeByDefault>true</activeByDefault>     \r\n               <jdk>1.6</jdk>     \r\n           </activation>     \r\n           <properties>     \r\n               <maven.compiler.source>1.6</maven.compiler.source>     \r\n               <maven.compiler.target>1.6</maven.compiler.target>     \r\n               <maven.compiler.compilerVersion>1.6</maven.compiler.compilerVersion>     \r\n           </properties>     \r\n   </profile>    \r\n</profiles>  \r\n ```',1,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2020-04-08 20:11:02','2020-11-29 11:45:11',0),(59,'Maven使用jdk1','```xml\n<properties>\n    <maven.compiler.target>1.8</maven.compiler.target>\n    <maven.compiler.source>1.8</maven.compiler.source>\n</properties>\n```',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2020-06-23 11:53:58','2020-11-29 11:45:11',0),(60,'Mybatis多表查询','[TOC]\n==Windows下MySQL不区分大小写，但在Linux下区分==\n## 一对一（多对一）\n### 需要被封装的POJO\nPOJO（Plain Ordinary Java Object）简单的Java对象<br>\n```java\nclass{\n    <T> 主对象;\n    <G> 连接的对象;\n}\n```\n### xml配置\n语句的返回值需要被设置为resultMap，在其中设置对象与表中列的对应关系以解决复杂映射关系<br>\n这些元素是结果映射的基础。id 和 result 元素都将一个列的值映射到一个简单数据类型（String, int, double, Date 等）的属性或字段。<br>\n这两者之间的唯一不同是，id元素对应的属性会被标记为对象的标识符，在比较对象实例时使用。这样可以提高整体的性能，尤其是进行缓存和嵌套结果映射（也就是连接映射）的时候<br>\n```xml\n<resultMap id=\"accountUserMap\" type=\"domain.Account\">\n    <id property=\"id\" column=\"ID\"/>\n    <result property=\"被封装属性的名称\" column=\"数据库中的列名\"/>\n    <result property=\"money\" column=\"MONEY\"/>\n    <!--有关联的数据-->\n    <association property=\"user\" column=\"UID\">\n        <id property=\"id\" column=\"UID\"/>\n        <result property=\"被封装属性的名称\" column=\"数据库中的列名\"/>\n        <result property=\"birthday\" column=\"birthday\"/>\n    </association>\n</resultMap>\n```\n关联的不同之处是，你需要告诉 MyBatis 如何加载关联。MyBatis 有两种不同的方式加载关联：<br>\n嵌套 Select 查询：通过执行另外一个 SQL 映射语句来加载期望的复杂类型。<br>\n嵌套结果映射：使用嵌套的结果映射来处理连接结果的重复子集。<br>\n\n### SQL\n```xml\n<select id=\"findAll\" resultMap=\"accountUserMap\">\n    select account.*, user.username, user.birthday, user.sex, user.address FROM account, user where account.UID = user.id\n</select>\n```\n\n## 一对多\n### 需要被封装的POJO\n```java\nclass{\n    <T> 主对象;\n    List<G> 连接的列表;\n}\n```\n### xml配置\n要配置关联的集合的resultMap<br>\n```xml\n<resultMap id=\"userAccountMap\" type=\"domain.User\">\n    <id property=\"id\" column=\"id\"/>\n    <result property=\"username\" column=\"username\"/>\n    <result property=\"birthday\" column=\"birthday\"/>\n    <result property=\"sex\" column=\"sex\"/>\n    <result property=\"address\" column=\"address\"/>\n    <!--accountList集合-->\n    <collection property=\"accountList\" ofType=\"domain.Account\">\n        <result property=\"uid\" column=\"UID\"/>\n        <result property=\"money\" column=\"MONEY\"/>\n    </collection>\n</resultMap>\n```\nofType这个属性非常重要，它用来将JavaBean（或字段）属性的类型和集合存储的类型区分开来。在一般情况下，MyBatis 可以推断 javaType 属性，因此并不需要填写，但是没有select之间进行联系就需要填写。<br>\n### SQL\n使用左外连接，即便右表没有映射也可以查出左表中的所有数据<br>\n换行要注意空格问题<br>\n```xml\n<select id=\"findAllUserWithAccount\" resultMap=\"userAccountMap\">\n    SELECT * FROM USER LEFT OUTER JOIN account ON user.id = account.UID\n</select>\n```\n\n## 总结\nassociation可以不用写javaType，但是collection必须要写ofType才能完成封装，或者通过select连接<br>',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2020-04-02 21:37:03','2020-11-29 11:45:11',0),(61,'Mybatis延时查询','[TOC]\n## 作用\n在做一段sql的查询时，延时一部分sql的查询，当需要数据时再进行查询<br>\n延时查询可以较少对于数据库的压力<br>\n一对一：通常立即查询<br>\n一对多：通常延时查询<br>\n## 开启延时查询功能\n设置名 | 	描述\n---|---\nlazyLoadingEnabled | 延迟加载的全局开关。当开启时，所有关联对象都会延迟加载。 特定关联关系中可通过设置 fetchType 属性来覆盖该项的开关状态。\naggressiveLazyLoading | 	开启时，任一方法的调用都会加载该对象的所有延迟加载属性。 否则，每个延迟加载属性会按需加载（参考 lazyLoadTriggerMethods)。\n## xml配置\n首先查询主表信息，然后在association中获取colum（作为附表查询sql的参数），select里面写附表的接口中的查询方法，Mybatis自动完成封装<br>\n### 一对一\n```xml\n<resultMap id=\"accountUserMap\" type=\"domain.Account\">\n    <id property=\"id\" column=\"ID\"/>\n    <result property=\"uid\" column=\"UID\"/>\n    <result property=\"money\" column=\"MONEY\"/>\n    <!--有关联的-->\n    <!--<association property=\"user\" column=\"UID\">\n        <id property=\"id\" column=\"UID\"/>&lt;!&ndash;做了id的封装&ndash;&gt;\n        <result property=\"username\" column=\"username\"/>\n        <result property=\"birthday\" column=\"birthday\"/>\n        <result property=\"sex\" column=\"sex\"/>\n        <result property=\"address\" column=\"address\"/>\n    </association>-->\n    <!--通过UID查找User的信息-->\n    <association property=\"user\" column=\"UID\" select=\"dao.UserDao.findUserById\"><!--一对一延时加载-->\n        <id property=\"id\" column=\"UID\"/>\n        <result property=\"username\" column=\"username\"/>\n        <result property=\"birthday\" column=\"birthday\"/>\n        <result property=\"sex\" column=\"sex\"/>\n        <result property=\"address\" column=\"address\"/>\n    </association>\n</resultMap>\n```\nsql语句<br>\n```xml\n<select id=\"findAll\" resultMap=\"accountUserMap\">\n    select * from account\n</select>\n\n<select id=\"findAccountListById\" resultType=\"domain.Account\">\n    select * from account where uid=#{uid};\n</select>\n```\n### 一对多\n都差不多\n```xml\n    <resultMap id=\"userAccountMap\" type=\"domain.User\">\n        <id property=\"id\" column=\"id\"/>\n        <result property=\"username\" column=\"username\"/>\n        <result property=\"birthday\" column=\"birthday\"/>\n        <result property=\"sex\" column=\"sex\"/>\n        <result property=\"address\" column=\"address\"/>\n        <!--accountList集合-->\n        <collection property=\"accountList\" column=\"id\" ofType=\"domain.Account\" select=\"dao.AccountDao.findAccountListById\"><!--多对多-->\n            <id property=\"id\" column=\"account_id\"/>\n            <result property=\"uid\" column=\"UID\"/>\n            <result property=\"money\" column=\"MONEY\"/>\n        </collection>\n    </resultMap>\n```\nsql\n```xml\n    <select id=\"findUserById\" parameterType=\"int\" resultType=\"domain.User\">\n        select * from user where id=#{id}\n    </select>\n\n    <!--<select id=\"findAllUserWithAccount\" resultMap=\"userAccountMap\">\n        SELECT user.*, account.ID AS account_id, account.UID, account.MONEY FROM USER LEFT OUTER JOIN account ON user.id = account.UID\n    </select>-->\n\n    <select id=\"findAllUserWithAccount\" resultMap=\"userAccountMap\">\n        select * from user\n    </select>\n```',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2020-04-02 21:30:21','2020-11-29 11:45:11',0),(62,'redis笔记','## 今日内容\r\n	1. redis\r\n		1. 概念\r\n		2. 下载安装\r\n		3. 命令操作\r\n			1. 数据结构\r\n		4. 持久化操作\r\n		5. 使用Java客户端操作redis\r\n\r\n\r\n\r\n# Redis\r\n	1. 概念： redis是一款高性能的NOSQL系列的非关系型数据库\r\n\r\n\r\n		1.1.什么是NOSQL\r\n			NoSQL(NoSQL = Not Only SQL)，意即“不仅仅是SQL”，是一项全新的数据库理念，泛指非关系型的数据库。\r\n			随着互联网web2.0网站的兴起，传统的关系数据库在应付web2.0网站，特别是超大规模和高并发的SNS类型的web2.0纯动态网站已经显得力不从心，暴露了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题。\r\n\r\n			1.1.1.	NOSQL和关系型数据库比较\r\n				优点：\r\n					1）成本：nosql数据库简单易部署，基本都是开源软件，不需要像使用oracle那样花费大量成本购买使用，相比关系型数据库价格便宜。\r\n					2）查询速度：nosql数据库将数据存储于缓存之中，关系型数据库将数据存储在硬盘中，自然查询速度远不及nosql数据库。\r\n					3）存储数据的格式：nosql的存储格式是key,value形式、文档形式、图片形式等等，所以可以存储基础类型以及对象或者是集合等各种格式，而数据库则只支持基础类型。\r\n					4）扩展性：关系型数据库有类似join这样的多表查询机制的限制导致扩展很艰难。\r\n\r\n				缺点：\r\n					1）维护的工具和资料有限，因为nosql是属于新的技术，不能和关系型数据库10几年的技术同日而语。\r\n					2）不提供对sql的支持，如果不支持sql这样的工业标准，将产生一定用户的学习和使用成本。\r\n					3）不提供关系型数据库对事务的处理。\r\n\r\n			1.1.2.	非关系型数据库的优势：\r\n				1）性能NOSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。\r\n				2）可扩展性同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。\r\n\r\n			1.1.3.	关系型数据库的优势：\r\n				1）复杂查询可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。\r\n				2）事务支持使得对于安全性能很高的数据访问要求得以实现。对于这两类数据库，对方的优势就是自己的弱势，反之亦然。\r\n\r\n			1.1.4.	总结\r\n				关系型数据库与NoSQL数据库并非对立而是互补的关系，即通常情况下使用关系型数据库，在适合使用NoSQL的时候使用NoSQL数据库，\r\n				让NoSQL数据库对关系型数据库的不足进行弥补。\r\n				一般会将数据存储在关系型数据库中，在nosql数据库中备份存储关系型数据库的数据\r\n\r\n		1.2.主流的NOSQL产品\r\n			•	键值(Key-Value)存储数据库\r\n					相关产品： Tokyo Cabinet/Tyrant、Redis、Voldemort、Berkeley DB\r\n					典型应用： 内容缓存，主要用于处理大量数据的高访问负载。 \r\n					数据模型： 一系列键值对\r\n					优势： 快速查询\r\n					劣势： 存储的数据缺少结构化\r\n			•	列存储数据库\r\n					相关产品：Cassandra, HBase, Riak\r\n					典型应用：分布式的文件系统\r\n					数据模型：以列簇式存储，将同一列数据存在一起\r\n					优势：查找速度快，可扩展性强，更容易进行分布式扩展\r\n					劣势：功能相对局限\r\n			•	文档型数据库\r\n					相关产品：CouchDB、MongoDB\r\n					典型应用：Web应用（与Key-Value类似，Value是结构化的）\r\n					数据模型： 一系列键值对\r\n					优势：数据结构要求不严格\r\n					劣势： 查询性能不高，而且缺乏统一的查询语法\r\n			•	图形(Graph)数据库\r\n					相关数据库：Neo4J、InfoGrid、Infinite Graph\r\n					典型应用：社交网络\r\n					数据模型：图结构\r\n					优势：利用图结构相关算法。\r\n					劣势：需要对整个图做计算才能得出结果，不容易做分布式的集群方案。\r\n		1.3 什么是Redis\r\n			Redis是用C语言开发的一个开源的高性能键值对（key-value）数据库，官方提供测试数据，50个并发执行100000个请求,读的速度是110000次/s,写的速度是81000次/s ，且Redis通过提供多种键值数据类型来适应不同场景下的存储需求，目前为止Redis支持的键值数据类型如下：\r\n				1) 字符串类型 string\r\n				2) 哈希类型 hash\r\n				3) 列表类型 list\r\n				4) 集合类型 set\r\n				5) 有序集合类型 sortedset\r\n			1.3.1 redis的应用场景\r\n				•	缓存（数据查询、短连接、新闻内容、商品内容等等）\r\n				•	聊天室的在线好友列表\r\n				•	任务队列。（秒杀、抢购、12306等等）\r\n				•	应用排行榜\r\n				•	网站访问统计\r\n				•	数据过期处理（可以精确到毫秒\r\n				•	分布式集群架构中的session分离\r\n\r\n\r\n	2. 下载安装\r\n		1. 官网：https://redis.io\r\n		2. 中文网：http://www.redis.net.cn/\r\n		3. 解压直接可以使用：\r\n			* redis.windows.conf：配置文件\r\n			* redis-cli.exe：redis的客户端\r\n			* redis-server.exe：redis服务器端\r\n		\r\n	3. 命令操作\r\n		1. redis的数据结构：\r\n			* redis存储的是：key,value格式的数据，其中key都是字符串，value有5种不同的数据结构\r\n				* value的数据结构：\r\n					1) 字符串类型 string\r\n					2) 哈希类型 hash ： map格式  \r\n					3) 列表类型 list ： linkedlist格式。支持重复元素\r\n					4) 集合类型 set  ： 不允许重复元素\r\n					5) 有序集合类型 sortedset：不允许重复元素，且元素有顺序\r\n		\r\n		2. 字符串类型 string\r\n			1. 存储： set key value\r\n				127.0.0.1:6379> set username zhangsan\r\n				OK\r\n			2. 获取： get key\r\n				127.0.0.1:6379> get username\r\n				\"zhangsan\"\r\n			3. 删除： del key\r\n				127.0.0.1:6379> del age\r\n				(integer) 1\r\n		3. 哈希类型 hash\r\n			1. 存储： hset key field value\r\n				127.0.0.1:6379> hset myhash username lisi\r\n				(integer) 1\r\n				127.0.0.1:6379> hset myhash password 123\r\n				(integer) 1\r\n			2. 获取： \r\n				* hget key field: 获取指定的field对应的值\r\n					127.0.0.1:6379> hget myhash username\r\n					\"lisi\"\r\n				* hgetall key：获取所有的field和value\r\n					127.0.0.1:6379> hgetall myhash\r\n					1) \"username\"\r\n					2) \"lisi\"\r\n					3) \"password\"\r\n					4) \"123\"\r\n					\r\n			3. 删除： hdel key field\r\n				127.0.0.1:6379> hdel myhash username\r\n				(integer) 1\r\n		\r\n		4. 列表类型 list:可以添加一个元素到列表的头部（左边）或者尾部（右边）\r\n			1. 添加：\r\n				1. lpush key value: 将元素加入列表左表\r\n					\r\n				2. rpush key value：将元素加入列表右边\r\n					\r\n					127.0.0.1:6379> lpush myList a\r\n					(integer) 1\r\n					127.0.0.1:6379> lpush myList b\r\n					(integer) 2\r\n					127.0.0.1:6379> rpush myList c\r\n					(integer) 3\r\n			2. 获取：\r\n				* lrange key start end ：范围获取\r\n					127.0.0.1:6379> lrange myList 0 -1\r\n					1) \"b\"\r\n					2) \"a\"\r\n					3) \"c\"\r\n			3. 删除：\r\n				* lpop key： 删除列表最左边的元素，并将元素返回\r\n				* rpop key： 删除列表最右边的元素，并将元素返回\r\n\r\n\r\n		5. 集合类型 set ： 不允许重复元素\r\n			1. 存储：sadd key value\r\n				127.0.0.1:6379> sadd myset a\r\n				(integer) 1\r\n				127.0.0.1:6379> sadd myset a\r\n				(integer) 0\r\n			2. 获取：smembers key:获取set集合中所有元素\r\n				127.0.0.1:6379> smembers myset\r\n				1) \"a\"\r\n			3. 删除：srem key value:删除set集合中的某个元素	\r\n				127.0.0.1:6379> srem myset a\r\n				(integer) 1\r\n		6. 有序集合类型 sortedset：不允许重复元素，且元素有顺序.每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。\r\n\r\n			1. 存储：zadd key score value\r\n				127.0.0.1:6379> zadd mysort 60 zhangsan\r\n				(integer) 1\r\n				127.0.0.1:6379> zadd mysort 50 lisi\r\n				(integer) 1\r\n				127.0.0.1:6379> zadd mysort 80 wangwu\r\n				(integer) 1\r\n			2. 获取：zrange key start end [withscores]\r\n				127.0.0.1:6379> zrange mysort 0 -1\r\n				1) \"lisi\"\r\n				2) \"zhangsan\"\r\n				3) \"wangwu\"\r\n\r\n				127.0.0.1:6379> zrange mysort 0 -1 withscores\r\n				1) \"zhangsan\"\r\n				2) \"60\"\r\n				3) \"wangwu\"\r\n				4) \"80\"\r\n				5) \"lisi\"\r\n				6) \"500\"\r\n			3. 删除：zrem key value\r\n				127.0.0.1:6379> zrem mysort lisi\r\n				(integer) 1\r\n\r\n		7. 通用命令\r\n			1. keys * : 查询所有的键\r\n			2. type key ： 获取键对应的value的类型\r\n			3. del key：删除指定的key value\r\n\r\n\r\n	4. 持久化\r\n		1. redis是一个内存数据库，当redis服务器重启，获取电脑重启，数据会丢失，我们可以将redis内存中的数据持久化保存到硬盘的文件中。\r\n		2. redis持久化机制：\r\n			1. RDB：默认方式，不需要进行配置，默认就使用这种机制\r\n				* 在一定的间隔时间中，检测key的变化情况，然后持久化数据\r\n				1. 编辑redis.windwos.conf文件\r\n					#   after 900 sec (15 min) if at least 1 key changed\r\n					save 900 1\r\n					#   after 300 sec (5 min) if at least 10 keys changed\r\n					save 300 10\r\n					#   after 60 sec if at least 10000 keys changed\r\n					save 60 10000\r\n					\r\n				2. 重新启动redis服务器，并指定配置文件名称\r\n					D:\\JavaWeb2018\\day23_redis\\资料\\redis\\windows-64\\redis-2.8.9>redis-server.exe redis.windows.conf	\r\n				\r\n			2. AOF：日志记录的方式，可以记录每一条命令的操作。可以每一次命令操作后，持久化数据\r\n				1. 编辑redis.windwos.conf文件\r\n					appendonly no（关闭aof） --> appendonly yes （开启aof）\r\n					\r\n					# appendfsync always ： 每一次操作都进行持久化\r\n					appendfsync everysec ： 每隔一秒进行一次持久化\r\n					# appendfsync no	 ： 不进行持久化\r\n\r\n	5. Java客户端 Jedis\r\n		* Jedis: 一款java操作redis数据库的工具.\r\n		* 使用步骤：\r\n			1. 下载jedis的jar包\r\n			2. 使用\r\n				//1. 获取连接\r\n        		Jedis jedis = new Jedis(\"localhost\",6379);\r\n       			//2. 操作\r\n       			jedis.set(\"username\",\"zhangsan\");\r\n        		//3. 关闭连接\r\n        		jedis.close();\r\n\r\n		\r\n		* Jedis操作各种redis中的数据结构\r\n			1) 字符串类型 string\r\n				set\r\n				get\r\n				\r\n				 //1. 获取连接\r\n		        Jedis jedis = new Jedis();//如果使用空参构造，默认值 \"localhost\",6379端口\r\n		        //2. 操作\r\n		        //存储\r\n		        jedis.set(\"username\",\"zhangsan\");\r\n		        //获取\r\n		        String username = jedis.get(\"username\");\r\n		        System.out.println(username);\r\n		\r\n		        //可以使用setex()方法存储可以指定过期时间的 key value\r\n		        jedis.setex(\"activecode\",20,\"hehe\");//将activecode：hehe键值对存入redis，并且20秒后自动删除该键值对\r\n		\r\n		        //3. 关闭连接\r\n		        jedis.close();\r\n\r\n			2) 哈希类型 hash ： map格式  \r\n				hset\r\n				hget\r\n				hgetAll\r\n				//1. 获取连接\r\n		        Jedis jedis = new Jedis();//如果使用空参构造，默认值 \"localhost\",6379端口\r\n		        //2. 操作\r\n		        // 存储hash\r\n		        jedis.hset(\"user\",\"name\",\"lisi\");\r\n		        jedis.hset(\"user\",\"age\",\"23\");\r\n		        jedis.hset(\"user\",\"gender\",\"female\");\r\n		\r\n		        // 获取hash\r\n		        String name = jedis.hget(\"user\", \"name\");\r\n		        System.out.println(name);\r\n		\r\n		\r\n		        // 获取hash的所有map中的数据\r\n		        Map<String, String> user = jedis.hgetAll(\"user\");\r\n		\r\n		        // keyset\r\n		        Set<String> keySet = user.keySet();\r\n		        for (String key : keySet) {\r\n		            //获取value\r\n		            String value = user.get(key);\r\n		            System.out.println(key + \":\" + value);\r\n		        }\r\n		\r\n		        //3. 关闭连接\r\n		        jedis.close();\r\n\r\n\r\n			3) 列表类型 list ： linkedlist格式。支持重复元素\r\n				lpush / rpush\r\n				lpop / rpop\r\n				lrange start end : 范围获取\r\n				\r\n				 //1. 获取连接\r\n		        Jedis jedis = new Jedis();//如果使用空参构造，默认值 \"localhost\",6379端口\r\n		        //2. 操作\r\n		        // list 存储\r\n		        jedis.lpush(\"mylist\",\"a\",\"b\",\"c\");//从左边存\r\n		        jedis.rpush(\"mylist\",\"a\",\"b\",\"c\");//从右边存\r\n		\r\n		        // list 范围获取\r\n		        List<String> mylist = jedis.lrange(\"mylist\", 0, -1);\r\n		        System.out.println(mylist);\r\n		        \r\n		        // list 弹出\r\n		        String element1 = jedis.lpop(\"mylist\");//c\r\n		        System.out.println(element1);\r\n		\r\n		        String element2 = jedis.rpop(\"mylist\");//c\r\n		        System.out.println(element2);\r\n		\r\n		        // list 范围获取\r\n		        List<String> mylist2 = jedis.lrange(\"mylist\", 0, -1);\r\n		        System.out.println(mylist2);\r\n		\r\n		        //3. 关闭连接\r\n		        jedis.close();\r\n\r\n\r\n			4) 集合类型 set  ： 不允许重复元素\r\n				sadd\r\n				smembers:获取所有元素\r\n\r\n				//1. 获取连接\r\n		        Jedis jedis = new Jedis();//如果使用空参构造，默认值 \"localhost\",6379端口\r\n		        //2. 操作\r\n		\r\n		\r\n		        // set 存储\r\n		        jedis.sadd(\"myset\",\"java\",\"php\",\"c++\");\r\n		\r\n		        // set 获取\r\n		        Set<String> myset = jedis.smembers(\"myset\");\r\n		        System.out.println(myset);\r\n		\r\n		        //3. 关闭连接\r\n		        jedis.close();\r\n			5) 有序集合类型 sortedset：不允许重复元素，且元素有顺序\r\n				zadd\r\n				zrange\r\n\r\n				//1. 获取连接\r\n		        Jedis jedis = new Jedis();//如果使用空参构造，默认值 \"localhost\",6379端口\r\n		        //2. 操作\r\n		        // sortedset 存储\r\n		        jedis.zadd(\"mysortedset\",3,\"亚瑟\");\r\n		        jedis.zadd(\"mysortedset\",30,\"后裔\");\r\n		        jedis.zadd(\"mysortedset\",55,\"孙悟空\");\r\n		\r\n		        // sortedset 获取\r\n		        Set<String> mysortedset = jedis.zrange(\"mysortedset\", 0, -1);\r\n		\r\n		        System.out.println(mysortedset);\r\n		\r\n		\r\n		        //3. 关闭连接\r\n		        jedis.close();\r\n\r\n\r\n		\r\n		* jedis连接池： JedisPool\r\n			* 使用：\r\n				1. 创建JedisPool连接池对象\r\n				2. 调用方法 getResource()方法获取Jedis连接\r\n					//0.创建一个配置对象\r\n			        JedisPoolConfig config = new JedisPoolConfig();\r\n			        config.setMaxTotal(50);\r\n			        config.setMaxIdle(10);\r\n			\r\n			        //1.创建Jedis连接池对象\r\n			        JedisPool jedisPool = new JedisPool(config,\"localhost\",6379);\r\n			\r\n			        //2.获取连接\r\n			        Jedis jedis = jedisPool.getResource();\r\n			        //3. 使用\r\n			        jedis.set(\"hehe\",\"heihei\");\r\n			\r\n			\r\n			        //4. 关闭 归还到连接池中\r\n			        jedis.close();\r\n			\r\n			* 连接池工具类\r\n				public class JedisPoolUtils {\r\n\r\n				    private static JedisPool jedisPool;\r\n				\r\n				    static{\r\n				        //读取配置文件\r\n				        InputStream is = JedisPoolUtils.class.getClassLoader().getResourceAsStream(\"jedis.properties\");\r\n				        //创建Properties对象\r\n				        Properties pro = new Properties();\r\n				        //关联文件\r\n				        try {\r\n				            pro.load(is);\r\n				        } catch (IOException e) {\r\n				            e.printStackTrace();\r\n				        }\r\n				        //获取数据，设置到JedisPoolConfig中\r\n				        JedisPoolConfig config = new JedisPoolConfig();\r\n				        config.setMaxTotal(Integer.parseInt(pro.getProperty(\"maxTotal\")));\r\n				        config.setMaxIdle(Integer.parseInt(pro.getProperty(\"maxIdle\")));\r\n				\r\n				        //初始化JedisPool\r\n				        jedisPool = new JedisPool(config,pro.getProperty(\"host\"),Integer.parseInt(pro.getProperty(\"port\")));\r\n				\r\n				\r\n				\r\n				    }\r\n				\r\n				\r\n				    /**\r\n				     * 获取连接方法\r\n				     */\r\n				    public static Jedis getJedis(){\r\n				        return jedisPool.getResource();\r\n				    }\r\n				}\r\n\r\n\r\n\r\n\r\n## 案例：\r\n	案例需求：\r\n		1. 提供index.html页面，页面中有一个省份 下拉列表\r\n		2. 当 页面加载完成后 发送ajax请求，加载所有省份\r\n\r\n\r\n	* 注意：使用redis缓存一些不经常发生变化的数据。\r\n		* 数据库的数据一旦发生改变，则需要更新缓存。\r\n			* 数据库的表执行 增删改的相关操作，需要将redis缓存数据情况，再次存入\r\n			* 在service对应的增删改方法中，将redis数据删除。',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2020-01-17 16:02:28','2020-11-29 11:45:11',0),(63,'SpringAOP','[TOC]\n## 概念\nAOP（Aspect Oriented Programming）不是spring独有的，spring只是将其变得更加易于使用<br>\n本质上就是使用了代理模式，通过代理模式将被代理的某些方法或全部方法进行增强<br>\n(1)横切关注点：对哪些方法进行拦截，拦截后怎么处理，这些关注点称之为横切关注点<br>\n(2)Aspect(切面):通常是一个类，里面可以定义切入点和通知<br>\n(3)JointPoint(连接点):程序执行过程中明确的点，一般是方法的调用。被拦截到的点，因为Spring只支持方法类型的连接点，所以在Spring中连接点指的就是被拦截到的方法，实际上连接点还可以是字段或者构造器<br>\n(4)Advice(通知):AOP在特定的切入点上执行的增强处理，有before(前置),after(后置),afterReturning(最终),afterThrowing(异常),around(环绕)<br>\n(5)Pointcut(切入点):就是带有通知的连接点，在程序中主要体现为书写切入点表达式<br>\n(6)weave(织入)：将切面应用到目标对象并导致代理对象创建的过程<br>\n(7)introduction(引入)：在不修改代码的前提下，引入可以在运行期为类动态地添加一些方法或字段<br>\n(8)AOP代理(AOP Proxy)：AOP框架创建的对象，代理就是目标对象的加强。Spring中的AOP代理可以使JDK动态代理，也可以是CGLIB代理，前者基于接口，后者基于子类<br>\n(9)目标对象（Target Object）: 包含连接点的对象。也被称作被通知或被代理对象。POJO<br>\n\n==切入点一定是连接点==\n\n## xml\n这个东西基于ioc所以，ioc是必须的<br>\n```xml\n    <aop:config>\n        <aop:pointcut id=\"pointcut1\" expression=\"execution(* proxy.AccountAOP.*(..))\"/>\n\n        <aop:aspect id=\"logAdvise\" ref=\"loggerAOP\">\n            <aop:before method=\"printLog\" pointcut-ref=\"pointcut1\"/>\n        </aop:aspect>\n\n    </aop:config>\n```\n\n## 环绕通知\n本质上就是写一个动态代理<br>\n通过编码的方法实现不同位置的通知（方法增强）<br>\n\n```\ngraph LR\nA[被代理对象]-->|方法增强|B[切面]\nA[被代理对象]-->|不使用动态代理|C[被代理对象执行方法]\nB[切面]-->C[被代理对象执行方法]\n```\n实现环绕通知切面要执行的方法：<br>\n```java\n    public Object aroundAdviser(ProceedingJoinPoint proceedingJoinPoint) {\n        Object value = null;\n        try {\n            Object[] args = proceedingJoinPoint.getArgs();\n            System.out.println(\"前置通知\");\n            value = proceedingJoinPoint.proceed(args);\n            System.out.println(\"后置通知\");\n            return value；\n        } catch (Throwable throwable) {\n            System.out.println(\"异常通知\");\n            throwable.printStackTrace();\n        } finally {\n            System.out.println(\"最终通知\");\n        }\n        return null;\n    }\n```\n本质上就是再写一遍代理模式<br>',1,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2020-05-06 11:14:00','2020-11-29 11:45:11',0),(64,'SpringIOC','## 概念\n通过spring框架为我们进行解耦操作，直接创建对象<br>\n方式有注解和xml<br>\n需要映射的Javabean都会储存在springIoc容器中，可以将容器比做一张map，键为id，值为封装的对象。在使用注解的@Autowired时，就是通过查找相同类型进行赋值的操作<br>\n\nkey | value\n---|---\nid | object implement interface\nid2 | object2 implement interface2\n\nspring的ioc运用了工厂模式，以达到解耦的效果<br>\n\n\n## xml\n使用xml文件便于后续管理<br>\n```java\nApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"bean.xml\");\nObject object = applicatonContext.getBean(\"beanId\");\n```\n\n## 注解\n\n使用纯注解要自己写一个配置类，当然也可以配合xml使用<br>\n```java\nimport config.SpringConfiguration;\nimport domain.Account;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.test.context.ContextConfiguration;\nimport org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\nimport service.AccountService;\n\nimport java.util.List;\n\n@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration(classes = SpringConfiguration.class)\npublic class MainTest {\n\n    @Autowired\n    private AccountService accountService;\n\n    @Test\n    public void test() {\n        List<Account> accountList = accountService.showAllAccount();\n        System.out.println(accountList);\n    }\n}\n```',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2020-04-11 11:28:34','2020-11-29 11:45:11',0),(65,'Spring实现事务控制','## 概念\n通过spring框架实现对于数据库的事务控制，也是通过AOP实现的<br>\n\n## 导包\n```xml\n    <dependency>\n        <groupId>org.springframework</groupId>\n        <artifactId>spring-tx</artifactId>\n        <version>5.2.5.RELEASE</version>\n    </dependency>\n    <dependency>\n        <groupId>org.aspectj</groupId><!--解析切入点表达式，没有导包xml过不去-->\n        <artifactId>aspectjweaver</artifactId>\n        <version>1.9.5</version>\n    </dependency>\n```\n\n\n## xml\n要有对于tx的支持<br>\n```xml\n<beans>\n    <!--accountService-->\n    <bean id=\"accountService\" class=\"service.impl.AccountServiceImpl\">\n        <property name=\"accountDao\" ref=\"accountDao\"/>\n    </bean>\n    <!-- 配置事务管理器 -->\n    <bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n        <property name=\"dataSource\" ref=\"dataSource\"/>\n    </bean>\n\n    <!--配置事务的通知-->\n    <tx:advice id=\"txAdviser\" transaction-manager=\"transactionManager\">\n        <!-- 配置事务的属性\n        isolation：用于指定事务的隔离级别。默认值是DEFAULT，表示使用数据库的默认隔离级别。\n        propagation：用于指定事务的传播行为。默认值是REQUIRED，表示一定会有事务，增删改的选择。查询方法可以选择SUPPORTS。\n        read-only：用于指定事务是否只读。只有查询方法才能设置为true。默认值是false，表示读写。\n        timeout：用于指定事务的超时时间，默认值是-1，表示永不超时。如果指定了数值，以秒为单位。\n        rollback-for：用于指定一个异常，当产生该异常时，事务回滚，产生其他异常时，事务不回滚。没有默认值。表示任何异常都回滚。\n        no-rollback-for：用于指定一个异常，当产生该异常时，事务不回滚，产生其他异常时事务回滚。没有默认值。表示任何异常都回滚。\n-->\n        <tx:attributes>\n            <tx:method name=\"transferAccount\" propagation=\"REQUIRED\" read-only=\"false\" />\n        </tx:attributes>\n    </tx:advice>\n\n    <!--AOP配置-->\n    <aop:config>\n        <aop:pointcut id=\"pc1\" expression=\"execution(* service.impl.AccountServiceImpl.transferAccount(..))\"/>\n        <aop:advisor advice-ref=\"txAdviser\" pointcut-ref=\"pc1\"/>\n    </aop:config>\n</beans>\n```',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2020-04-14 20:59:11','2020-11-29 11:45:11',0),(66,'jasypt防止显示明文密码','## 导包\n```xml\n<!--加密组件-->\n<dependency>\n    <groupId>com.github.ulisesbocchio</groupId>\n    <artifactId>jasypt-spring-boot-starter</artifactId>\n    <version>3.0.2</version>\n</dependency>\n```\n\n## 配置\n使用一个字符串作为解密密码\n```yml\njasypt:\n  encryptor:\n    password: Roderick  # 明文密码接管\n```\n\n## 获取加密字符\n```java\n@Autowired\nStringEncryptor stringEncryptor;\n\n@Test\npublic void encryptTest() {\n    String admin = stringEncryptor.encrypt(\"admin\");    //加密\n    System.out.println(stringEncryptor.decrypt(admin)); //解密\n}\n```\n开始运行（配置了解密密码），可以直接从配置文件中获取解密的密码\n```java\n@Value(\"${baidu.SECRET_KEY}\")\nprivate String SECRET_KEY;\n```\n如果没有配置解密密码会导致无法解析ApplicationContext文件<br>\n// todo 使用密码参数启动',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2020-06-16 17:21:49','2020-11-29 11:45:12',0),(67,'MyBatis+SpringBoot','[TOC]\n## 导包\n```xml\n<dependency>\n    <groupId>org.mybatis.spring.boot</groupId>\n    <artifactId>mybatis-spring-boot-starter</artifactId>\n    <version>2.1.2</version>\n</dependency>\n``` \n\n## 配置\n### application.properties/yaml\n在application中配置mapperlocation（使用xml的配置）\n```yaml\nspring:\n  datasource:\n    url: jdbc:mysql://localhost:3306/laptime_page?serverTimezone=Asia/Shanghai\n    username: \n    password: \n    driver-class-name: com.mysql.cj.jdbc.Driver\nmybatis:\n  type-aliases-package: com.roderick.pojo\n  mapper-locations: classpath:mybatis/*.xml\n```\n### Dao接口\n如果打算sql打算使用注解完成就可以不写mapper的配置，但是接口上要使用@Mapper的注解（用xml写上也无妨）\n```java\n@Mapper\n@Repository\npublic interface VehicleDao {\n    List<Vehicle> listVehicle();\n}\n```\n### Mapper\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n<mapper namespace=\"com.roderick.dao.VehicleDao\">\n    <select id=\"listVehicle\" resultType=\"com.roderick.pojo.Vehicle\">\n        select * from vehicle\n    </select>\n</mapper>\n```\n\n## parameterType有多个参数的解决办法\n使用@param\nDao接口\n```java\n@Mapper\n@Repository\npublic interface ImageDao {\n\n//    @Select(\"insert into image (vehicle_id,image_path) value (#{vehicle_id},#{image_path})\")\n    void insertImage(@Param(\"vehicle_id\") int vehicle_id, @Param(\"image_path\") String image_path);\n}\n```\nMapper配置文件就可以不用写parameterType\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n<!DOCTYPE mapper\n        PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n<mapper namespace=\"com.roderick.dao.ImageDao\">\n    <insert id=\"insertImage\">\n        insert into image (vehicle_id,image_path)\n        value (#{vehicle_id},#{image_path})\n    </insert>\n</mapper>\n```\n还可以使用HashMap或者LIst进行封装\n## 获取刚在数据库中主键自增生成的id（自增）\nDao接口：\n```java\nvoid insertAuthor(Author author);\n```\nmybatis官方文档办法：<br>\n首先，如果你的数据库支持自动生成主键的字段（比如 MySQL 和 SQL Server），那么你可以设置 useGeneratedKeys=”true”，然后再把 keyProperty 设置为目标属性就 OK 了。例如，如果上面的 Author 表已经在 id 列上使用了自动生成，那么语句可以修改为：\n```xml\n<insert id=\"insertAuthor\" useGeneratedKeys=\"true\"\n    keyProperty=\"id\">\n  insert into Author (username,password,email,bio)\n  values (#{username},#{password},#{email},#{bio})\n</insert>\n```\n调用：\n```java\nAuthor author = new Author;\ninsertAuthor(author);\nint id = author.getId();\n```',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2020-05-12 11:25:41','2020-11-29 11:45:12',0),(68,'Redis+SpringBoot','## 导包\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-data-redis</artifactId>\n</dependency>\n```\n\n## 配置\napplication的配置文件进行配置（有默认的配置，默认没有密码）<br>\nRedisAutoConfiguration会在没有名为redisTemplate自动注入RedisTemplate<br>\n```java\n@Bean\n@ConditionalOnMissingBean(name = \"redisTemplate\")\npublic RedisTemplate<Object, Object> redisTemplate(RedisConnectionFactory redisConnectionFactory)\n		throws UnknownHostException {\n	RedisTemplate<Object, Object> template = new RedisTemplate<>();\n	template.setConnectionFactory(redisConnectionFactory);\n	return template;\n}\n```\n所以只需要用自己的配置覆盖一下就能生效<br>\n在使用redis的时候会有一些序列化导致的问题，在自己的配置文件中设置一下完成序列化的对象，redis存放对象可以使用json存放<br>\n```java\n@Configuration\npublic class RedisConfig {\n    @Bean\n    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory redisConnectionFactory)\n            throws UnknownHostException {\n        RedisTemplate<String, Object> template = new RedisTemplate<>();\n        template.setConnectionFactory(redisConnectionFactory);\n        //配置\n        template.setKeySerializer(new StringRedisSerializer());\n        template.setHashKeySerializer(new StringRedisSerializer());\n        template.setHashValueSerializer(new Jackson2JsonRedisSerializer<Object>(Object.class));\n        template.setValueSerializer(new StringRedisSerializer());\n        template.afterPropertiesSet();\n        return template;\n    }\n}\n```\n\n## 使用\n```java\n@Controller\npublic class MyBatisController {\n    @Autowired\n    RedisTemplate<Object, Object> redisTemplate;\n    \n    public void so() {\n        redisTemplate.opsForValue().set(\"hello\", \"hi\");\n        redisTemplate.opsForValue().get(\"hello\");\n    }\n}\n```',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2020-05-09 14:29:17','2020-11-29 11:45:12',0),(69,'SpringSecurity','[TOC]\n## 概念\n通过AOP的方式对请求的资源进行拦截，只有用户含有特定的权限才能被放行<br>\n\n## 导包（基于springboot）\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-security</artifactId>\n</dependency>\n```\n后期使用mysql数据库进行认证<br>\n```xml\n<dependency>\n    <groupId>mysql</groupId>\n    <artifactId>mysql-connector-java</artifactId>\n</dependency>\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-jdbc</artifactId>\n</dependency>\n```\n\n\n## 基于内存中的用户管理\n首先因该自己写一个类继承WebSecurityConfigurerAdapter，加上@EnableWebSecurity注解，表明这是一个springsecurity的配置类<br>\n```java\n@EnableWebSecurity\npublic class SpringSecurityConfig extends WebSecurityConfigurerAdapter {\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        //首页都可以访问\n        http.authorizeRequests()\n                .antMatchers(\"/\", \"/index\").permitAll()\n                .antMatchers(\"/level1/**\").hasRole(\"vip1\");\n        http.formLogin();\n        http.logout().logoutSuccessUrl(\"/\");\n    }\n}\n```\n### 添加用户\n可以通过重写WebSecurityConfigurerAdapter方法或者是添加bean的方法来添加用户对象<br>\n```java\n@Bean\npublic UserDetailsService users() {\n    UserDetails user = User.builder()  //withDefaultPasswordEncoder不加密的方式（明文账号密码）\n            .username(\"user\")\n            .password(\"{bcrypt}$2a$10$s41u/ZpT9Xe208wjPIsh4eFQsBzBnEblNDxVKxQvvbr2vCnkMsCp2\")   //加密方式，防止泄露源码\n            .roles(\"vip1\")\n            .build();\n    return new InMemoryUserDetailsManager(user);\n}\n```\n由于防止在反编译的时候获取密码，所以要使用加密，默认使用BCryptPasswordEncoder这个类实现加密，在设置密码的时候加上加密方式<br>\n在使用页面进行登入的时候就能实现自动识别和授权操作<br>\n\n\n## 基于数据库的认证(jdbc)\n\n### 创建数据库(MySql)\n通过更改脚本\n```sql\nCREATE TABLE `users` (\n  `username` varchar(50) NOT NULL,\n  `password` varchar(128) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,\n  `enabled` tinyint(1) NOT NULL,\n  PRIMARY KEY (`username`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci\n\n\nCREATE TABLE `authorities` (\n  `username` varchar(50) NOT NULL,\n  `authority` varchar(50) NOT NULL,\n  UNIQUE KEY `ix_auth_username` (`username`,`authority`),\n  CONSTRAINT `fk_authorities_users` FOREIGN KEY (`username`) REFERENCES `users` (`username`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci\n```\n### 添加用户\n可以直接使用JdbcUserDetailsManager(datasource)进行添加<br>\n```java\nUserDetails user = User.builder()  //withDefaultPasswordEncoder不加密的方式（明文账号密码）\n        .username(\"test\")\n        .password(\"{bcrypt}$2a$10$s41u/ZpT9Xe208wjPIsh4eFQsBzBnEblNDxVKxQvvbr2vCnkMsCp2\")   //加密方式，防止泄露源码\n        .roles(\"vip1\")\n        .build();\nJdbcUserDetailsManager jdbcUserDetailsManager = new JdbcUserDetailsManager(dataSource);\njdbcUserDetailsManager.createUser(user);\n```\n### 验证用户\n```java\n@EnableWebSecurity\npublic class SpringSecurityConfig extends WebSecurityConfigurerAdapter {\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        //首页都可以访问\n        http.authorizeRequests()\n                .antMatchers(\"/\", \"/index\",\"/addUser\").permitAll()\n                .antMatchers(\"/level1/**\").hasRole(\"vip1\");\n        http.formLogin();\n        http.logout().logoutSuccessUrl(\"/\");\n    }\n\n    @Bean\n    public UserDetailsService users() { //内存中验证\n        UserDetails user = User.builder()  //withDefaultPasswordEncoder不加密的方式（明文账号密码）\n                .username(\"user\")\n                .password(\"{bcrypt}$2a$10$s41u/ZpT9Xe208wjPIsh4eFQsBzBnEblNDxVKxQvvbr2vCnkMsCp2\")   //加密方式，防止泄露源码\n                .roles(\"vip1\")\n                .build();\n        return new InMemoryUserDetailsManager(user);\n    }\n\n    @Bean\n    public UserDetailsService users(@Autowired DataSource dataSource) { //数据库验证\n        return new JdbcUserDetailsManager(dataSource);  //读取来自数据库的数据（同时可以添加用户）\n    }\n}\n```',2,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2020-06-16 15:59:20','2020-11-29 11:45:12',0),(70,'文件上传','[TOC]\n## 导包\n```xml\n<!--文件上传-->\n<dependency>\n    <groupId>commons-fileupload</groupId>\n    <artifactId>commons-fileupload</artifactId>\n    <version>1.3.3</version>\n</dependency>\n```\n\n## 前端发送数据\n1. 使用post提交数据\n2. enctype=\"multipart/form-data\"\n3. input标签 type=\"file\" \n\n```html\n<form id=\"uploadForm\" method=\"post\" enctype=\"multipart/form-data\">\n    <div class=\"form-group insertFrom\">\n        <label for=\"file\">上传图片</label>\n        <input type=\"file\" name=\"file\" id=\"file\">\n    </div>\n    <button id=\"submit-btn\" class=\"btn btn-primary\" type=\"button\">提交</button>\n</form>\n```\n\n## 后端接收数据\n后端接收：\n```java\n@PostMapping(\"/management/vehicleIdentification\")\n@ResponseBody\npublic String vehicleIdentification(@RequestParam(\"file\") MultipartFile file) throws IOException {\n    file.transferTo(new File(\"PATH\"))   //储存文件\n    return null;\n}\n```\n\n## 前端回显图片（不经过后端）\n获取图片的src：\n```javascript\nfunction getObjectURL(file) {   //获取上传图片的地址生成零时文件（名称为uuid）\n    let url = null;\n    if (window.createObjectURL !== undefined) { // basic\n        url = window.createObjectURL(file);\n    } else if (window.URL !== undefined) { // mozilla(firefox)\n        url = window.URL.createObjectURL(file)\n    } else if (window.webkitURL !== undefined) { // webkit or chrome\n        url = window.webkitURL.createObjectURL(file);\n    }\n    return url;\n}\n```\n修改图片：\n```javascript\nlet $file = $(\"#file\");    //获取表单数据\nlet src = getObjectURL($file[0].files[0]);  //转化为DOM对象后，获取文件（使用jQuery对象无法进行操作）\n$(\"#image\").attr(\"src\", src)    //修改图片的src属性\n```',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2020-06-23 11:38:39','2020-11-29 11:45:12',0),(71,'Hystrix熔断管理','[TOC]\n## 概念\n通过一些举措防止分布式应用发生雪崩\n\n## 导包\n```xml\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-netflix-hystrix</artifactId>\n</dependency>\n```\n## 熔断器（CircuitBreaker）\n通常加在提供者方，当某个方法出错抛出异常时调用其它方法，防止服务直接抛出错误或是造成阻塞\n### 配置\ncontroller：\n```java\n@RestController\npublic class MainController {\n    @GetMapping(\"/test/{id}\")\n    @HystrixCommand(fallbackMethod = \"error\")   //出错时的回调方法\n    public String getUser(@PathVariable(\"id\") String id) {\n        if (\"0\".equals(id))\n            throw new RuntimeException(\"运行时出错\");\n        return \"getUser\" + id;\n    }\n\n    public String error(String id) {    //参数列表必须与为原方法相同\n        return \"ERROR-HYSTRIX\";\n    }\n}\n```\n启动类：\n```java\n@SpringBootApplication\n@EnableEurekaClient\n@EnableCircuitBreaker   //开启熔断器\npublic class ProviderHystrixApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(ProviderHystrixApplication.class);\n    }\n}\n```\n\n## 监控面板（Hystrix Dashboard）\n通常加在提供者方，但是只是提供一个网页进行查询，为了实现查询还需要在消费方配置**Hystrix Metrics Stream**\n### 服务提供者\n导入包：\n```xml\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-netflix-hystrix-dashboard</artifactId>\n</dependency>\n```\n配置主启动类：\n```java\n@SpringBootApplication\n@EnableEurekaClient\n@EnableHystrixDashboard //开启hystrix监控面板\npublic class ProviderHystrixApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(ProviderHystrixApplication.class);\n    }\n}\n```\n### 消费者\n配置Hystrix Metrics Stream\n导入包：\n```xml\n<!--显示info信息-->\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-actuator</artifactId>\n</dependency>\n```\napplication：\n```yml\nmanagement:\n  endpoints:\n    web:\n      exposure:\n        include: hystrix.stream\n```\n配置主启动类：\n```java\n@SpringBootApplication\n@EnableEurekaClient\n@EnableCircuitBreaker\npublic class ProviderApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(ProviderApplication.class);\n    }\n}\n```',1,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2020-05-28 18:51:57','2020-11-29 11:45:12',0),(72,'Ribbon负载均衡','[TOC]\n## 概念\nRibbon是基于客户端的负载均衡，与nginx这种反向代理的负载均衡不同\n\n## 导包\n```xml\n<!--实现负载均衡-->\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-netflix-ribbon</artifactId>\n</dependency>\n```\n\n## 配置\n由于ribbon负载均衡基于消费者，所以提供者无需更改\n### 消费者\n配置类：\n```java\n@Configuration\npublic class MainConfig {\n    @Bean\n    @LoadBalanced\n    public RestTemplate restTemplate() {\n        return new RestTemplate();\n    }\n}\n```\n启动类：\n```java\n@SpringBootApplication\n@EnableDiscoveryClient\npublic class ConsumerApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(ConsumerApplication.class);\n    }\n}\n```\n\n## 修改负载均衡算法\n默认为轮询\n```yml\nPROVIDER: # 服务id\n  ribbon:\n    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule # 轮询（负载均衡算法类）\n```\n\n## 写一个自己负载均衡算法\n写自己的负载均衡算法因该实现IRule接口，然后在application配置中修改算法，此算法类不需要注入spring容器<br>\n照葫芦画瓢随机算法（public class RandomRule extends AbstractLoadBalancerRule）<br>\n### 算法类\n**特别注意的点**：我们这里直接实现IRule，为了获取ILoadBalancer必须要写setLoadBalancer方法，不然无法获取服务列表\n```java\npackage com.roderick.config;\n\nimport com.netflix.loadbalancer.*;\n\nimport java.util.List;\n\n/**\n * 轮流访问每个服务5次\n */\npublic class MyRule implements IRule {\n    private int count = 0;\n    private int currentIndex = 0;\n    private ILoadBalancer loadBalancer;\n\n    public Server choose(ILoadBalancer lb, Object key) {\n        if (lb == null) {\n            return null;\n        }\n        Server server = null;\n\n        while (server == null) {\n            if (Thread.interrupted()) {\n                return null;\n            }\n            List<Server> upList = lb.getReachableServers(); //可用的服务列表\n            List<Server> allList = lb.getAllServers();  //所有的服务列表\n\n            int serverCount = allList.size();\n            if (serverCount == 0) {\n                /*\n                 * No servers. End regardless of pass, because subsequent passes\n                 * only get more restrictive.\n                 */\n                return null;\n            }\n\n            if (count < 5) {\n                server = upList.get(currentIndex);\n                count++;    \n            } else {\n                count = 0;\n                currentIndex++; \n                if (currentIndex >= upList.size()) { \n                    currentIndex = 0;\n                }\n                server = upList.get(currentIndex);\n            }\n\n\n            if (server == null) {\n                /*\n                 * The only time this should happen is if the server list were\n                 * somehow trimmed. This is a transient condition. Retry after\n                 * yielding.\n                 */\n                Thread.yield();\n                continue;\n            }\n\n            if (server.isAlive()) {\n                return (server);\n            }\n\n            // Shouldn\'t actually happen.. but must be transient or a bug.\n            server = null;\n            Thread.yield();\n        }\n        return server;\n    }\n\n    @Override\n    public Server choose(Object key) {\n        return choose(getLoadBalancer(), key);\n    }\n\n    @Override\n    public void setLoadBalancer(ILoadBalancer lb) {\n        this.loadBalancer = lb; //注意这里要设置，不然无法获取服务列表\n    }\n\n    @Override\n    public ILoadBalancer getLoadBalancer() {\n        return loadBalancer;\n    }\n}\n```\n### 测试\n```java\n@SpringBootTest(classes = ConsumerApplication.class)\npublic class RibbonLoadBalanceTest {\n\n    @Autowired\n    LoadBalancerClient client;\n\n    @Test\n    public void loadBalance() {\n        for (int i = 0; i < 20; i++) {\n            ServiceInstance consumer = client.choose(\"PROVIDER\");\n            System.out.println(consumer.getPort());\n        }\n    }\n}\n```',1,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2020-05-27 17:29:39','2020-11-29 11:45:12',0),(73,'SpringCloudNetfilx入门','[TOC]\n## 整体框架\n由于整个微服务使用springcloud进行管理，所以采用maven聚合工程<br>\n## 导包\n最好使用父项目进行版本控制<br>\n```xml\n<dependencyManagement>\n    <dependencies>\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-dependencies</artifactId>\n            <version>Hoxton.SR4</version>\n            <type>pom</type>\n            <scope>import</scope>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-dependencies</artifactId>\n            <version>2.2.5.RELEASE</version>\n            <type>pom</type>\n            <scope>import</scope>\n        </dependency>\n    </dependencies>\n</dependencyManagement>\n```\n**注意点**：maven中和Java类似没有多继承这个概念，间接实现多继承就可以使用import对包进行导入，这样子包就能继承版本控制<br>\n### 注册中心\n```xml\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.cloud</groupId>\n        <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>\n    </dependency>\n</dependencies>\n```\n### 客户端（服务提供者也是客户端）\n```xml\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-web</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-test</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.cloud</groupId>\n        <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\n    </dependency>\n    <!--实现负载均衡-->\n    <dependency>\n        <groupId>org.springframework.cloud</groupId>\n        <artifactId>spring-cloud-starter-netflix-ribbon</artifactId>\n    </dependency>\n    <!--显示info信息-->\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-actuator</artifactId>\n    </dependency>\n</dependencies>\n```\n\n## application配置\n### 注册中心\n```yml\nserver:\n  port: 8000\neureka:\n  client:\n    register-with-eureka: false # 不讲自己注册进注册中心\n    fetch-registry: false # 不拉取服务\n```\n在springboot应用中开启EurekaServer\n```java\n@SpringBootApplication\n@EnableEurekaServer\npublic class RegistryApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(RegistryApplication.class);\n    }\n}\n```\n### 服务提供者或消费者\n```yml\nserver:\n  port: 8081\neureka:\n  client:\n    service-url:\n      defaultZone: http://localhost:8000/eureka # 服务中心的地址，\',\'隔开可以写多个实现集群\n  instance:\n    instance-id: consumer-port:8081 # status的名称\nspring:\n  application:\n    name: consumer # 服务的名称\ndebug: true\n# 配置自己的信息\ninfo:\n  app.name: roderick\n```\n在springboot应用中开启EurekaServer\n```java\n@SpringBootApplication\n@EnableEurekaClient\npublic class ProviderApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(ProviderApplication.class);\n    }\n}\n```\n## 消费者调用提供者Rest接口\n这里使用RestTemplate连接客户端\n```java\n@RestController\npublic class MainController {\n    RestTemplate restTemplate;\n    DiscoveryClient discoveryClient;\n    private static final String URL = \"http://localhost:8100\";\n    private static final String ID_URL = \"http://CONSUMER\"; //通过id直接获取（内部玩法）\n\n    @Autowired\n    public void setRestTemplate(RestTemplate restTemplate) {\n        this.restTemplate = restTemplate;\n    }\n\n    @Autowired\n    public void setDiscoveryClient(DiscoveryClient discoveryClient) {\n        this.discoveryClient = discoveryClient;\n    }\n\n    @GetMapping(\"/get/{id}\")\n    public String getUser(@PathVariable(\"id\") String id) {\n        return restTemplate.getForObject(ID_URL + \"/test/\" + id, String.class);\n    }\n\n    @GetMapping(\"/services\")\n    public String getService() {    //获取服务列表\n        Map<String, List<ServiceInstance>> map = new HashMap<>();\n        List<String> services = discoveryClient.getServices();\n        for (String service : services) {\n            List<ServiceInstance> instances = discoveryClient.getInstances(service);\n            map.put(service, instances);\n        }\n        return map.toString();\n    }\n}\n```\n代码中将URL写死是不行的，我们可以使用DiscoveryClient获取或者直接将服务名作为url，通过解析可以获取到服务的真实地址<br>',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2020-05-26 23:25:36','2020-11-29 11:45:12',0),(74,'Zuul网关','## 概念\nZuul就是一个网关或者说是一个路由组件，可以用于修改注册中心不同服务的访问地址，防止将核心服务地址暴露\n## 导包\n```xml\n<!--zuul网关-->\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-netflix-zuul</artifactId>\n</dependency>\n```\n## 配置\n通常Zuul作为一个单独的组件运行，只需Zuul的端口就能访问所有的微服务\napplication：\n```yml\nserver:\n  port: 8200\nspring:\n  application:\n    name: zuul-gateway\neureka:\n  client:\n    service-url:\n      defaultZone: http://localhost:8000/eureka\ninfo:\n  name: roderick\n  version: 1.0\nzuul:\n  routes: # 配置路由规则\n    provider-hystrix:\n      path: /provider/**  # url样式The path (pattern) for the route, e.g. /foo/**\n      serviceId: provider-hystrix # 服务Id名称\n  ignored-services: \'*\' # 屏蔽所有服务名\n ```\n 配置启动类：\n ```java\n@SpringBootApplication\n@EnableZuulProxy    //开启Zuul网关代理\npublic class ZuulApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(ZuulApplication.class, args);\n    }\n}\n```',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2020-05-29 16:11:51','2020-11-29 11:45:12',0),(75,'SpringMVC入门','[TOC]\n## 概念\n三层架构ssm浮出水面，而MVC（Model Viev Controler）就是一个位于试图层的框架<br>\n\n## 环境配置\n### web.xml\n整个springMVC都是围绕前端控制器展开的，而springMVC的前端控制器正是一个主控的servlet，所以为了让springMVC，必须要在web.xml中配置springMVC特有的servlet<br>\n```xml\n<!DOCTYPE web-app PUBLIC\n        \"-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN\"\n        \"http://java.sun.com/dtd/web-app_2_3.dtd\" >\n\n<web-app>\n    <display-name>Archetype Created Web Application</display-name>\n\n    <!--springMVC前端控制器-->\n    <servlet>\n        <servlet-name>dispatcherServlet</servlet-name>\n        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n        <init-param>\n            <param-name>contextConfigLocation</param-name>\n            <param-value>classpath:bean.xml</param-value>\n        </init-param>\n        <load-on-startup>1</load-on-startup>\n    </servlet>\n\n    <servlet-mapping>\n        <servlet-name>dispatcherServlet</servlet-name>\n        <url-pattern>/</url-pattern>\n    </servlet-mapping>\n    <servlet-mapping>\n        <servlet-name>default</servlet-name>\n        <url-pattern>*.html</url-pattern>\n    </servlet-mapping>\n    <servlet-mapping>\n        <servlet-name>default</servlet-name>\n        <url-pattern>/css/*</url-pattern>\n    </servlet-mapping>\n    <servlet-mapping>\n        <servlet-name>default</servlet-name>\n        <url-pattern>/front/*</url-pattern>\n    </servlet-mapping>\n    <servlet-mapping>\n        <servlet-name>default</servlet-name>\n        <url-pattern>/js/*</url-pattern>\n    </servlet-mapping>\n\n</web-app>\n```\n### springmvc.xml\nspringMVC还是基于spring，所以基本的spring还是要配置的<br>\n扫包，试图解析器，注册springMVC注解的驱动<br>\n注解：<br>\n    1.Controller<br>\n    2.Servcie <br>\n    3.Repository <br>\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:mvc=\"http://www.springframework.org/schema/mvc\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\n       http://www.springframework.org/schema/mvc\n       http://www.springframework.org/schema/mvc/spring-mvc.xsd\n       http://www.springframework.org/schema/context\n       http://www.springframework.org/schema/context/spring-context.xsd\">\n\n    <!--springIOC扫描-->\n    <context:component-scan base-package=\"roderick\"/>\n\n    <bean id=\"projectService\" class=\"roderick.service.Impl.ProjectServiceImpl\"/>\n\n    <!--试图解析对象-->\n    <bean id=\"internalResourceViewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\">\n        <property name=\"prefix\" value=\"/\"/>\n        <property name=\"suffix\" value=\".html\"/>\n    </bean>\n\n    <mvc:resources mapping=\"/js/**\" location=\"/js/\"/>\n\n    <!--注册驱动-->\n    <mvc:annotation-driven/>\n<!--    <mvc:default-servlet-handler/>-->\n\n</beans>\n```\n## 对于url-pattern的深入了解\nurl-pattern是对于请求路径的映射，但是对于不同的格式有着不同的优先级<br>\nServlet的匹配权重:<br>\n　　1. 精确路径匹配(/ab高于/*)<br>\n　　2. 最长路径匹配(/ab/cd高于/ab；/ab/cd/*高于/ab/*)<br>\n　　3. 扩展匹配(*.xxx)<br>\n　　4. 默认匹配(\"url-pattern /\" --> defaultServlet) <br>\n\n在我们使用/去做匹配的时候，当请求的路径没有比配的时候，会选择我们自己配置的servlet<br>\n在使用/*去做匹配的时候，会匹配所有的请求路径，造成请求只会由springMVC的servlet处理，但是springMVC的servlet没有集成一些静态资源的解析，导致一些静态页面无法解析，比如html，所以对于一些静态资源的相应还是应该交给defaultservlet<br>\n\n## DefaultServlet\n我们同样可以通过链接来访问应用内的资源文件。例如.jpg,.html,.js这类的静态文件。这就是DefaultServlet的作用了。它在tomat的安装目录下的conf/web.xml中有定义。该web.xml对于所有tomcat加载的的web application都会应用，会和application本身指定的web.xml进行合并。<br>\nDefaultServlet的servlet-mapping配置的为/,很多帖子或者书籍上都说/的URL映射符会映射除了*.xxx类带后缀的地址URL，事实上/映射可以处理所有的请求，一般只有defaultServlet会配置为/,如果自定义的Servlet也配置为/,那么将会覆盖defaultservlet的配置。<br>',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2020-04-20 21:39:11','2020-11-29 11:45:12',0),(76,'SSM整合','[TOC]\n## 概念\n通过整合可以减少在使用IOC容器中和Mybatis管理的代理对象的代码量<br>\n在不进行整合的情况下：<br>\n### springframwork\n1.首先必须读取配置文件或是配置类，才能在spingIOC的容器中有对应的类<br>\n2.在需要对象的时候通过注解（Autowired）或是从配置文件中请求对应的对象（application.getBean）<br>\n### springMVC\n这个本来就是在项目开始运行时进行加载<br>\n### MyBatis\n有两个配置文件，一个对于项目的总配置文件，还有对于某个特定Dao接口的实现(daoMapper.xml)，当然也可以使用注解完成<br>\n&emsp;&emsp;1.首先使用inputStream读取配置文件<br>\n&emsp;&emsp;2.SqlSessionFactoryBuilder得到SqlSessionFactory<br>\n&emsp;&emsp;3.SqlSessionFactory得到Session<br>\n&emsp;&emsp;4.通过Session获取Dao代理对象<br>\n\n## 整合\n&emsp;&emsp;1.最重要的就是在项目开始运行的时候加载spring(applicationContext)配置文件和springMVC前端控制器(springmvc)<br>\n&emsp;&emsp;2.在spring中整合Mybatis<br>\n### web.xml\n在服务器启动的时候就加载spring（applicationContext.xml）和springMVC（springmvc.xml）的配置文件<br>\n==加载spring的配置文件的时候默认位置是WEB-INF下，所以要进行更改一下==<br>\n```xml\n<web-app version=\"2.4\"\n         xmlns=\"http://java.sun.com/xml/ns/j2ee\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd\">\n    <display-name>Archetype Created Web Application</display-name>\n\n    <!--加载spring框架-->\n    <listener>\n        <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>\n    </listener>\n    <context-param>\n        <param-name>contextConfigLocation</param-name>\n        <param-value>classpath:applicationContext.xml</param-value>\n    </context-param>\n\n    <!--springMVC编码过滤器-->\n    <filter>\n        <filter-name>characterEncodingFilter</filter-name>\n        <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>\n        <init-param>\n            <param-name>encoding</param-name>\n            <param-value>UTF-8</param-value>\n        </init-param>\n    </filter>\n    <filter-mapping>\n        <filter-name>characterEncodingFilter</filter-name>\n        <url-pattern>/*</url-pattern>\n    </filter-mapping>\n\n    <!--springMVC前端控制器-->\n    <servlet>\n        <servlet-name>dispatcherServlet</servlet-name>\n        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n        <init-param>\n            <param-name>contextConfigLocation</param-name>\n            <param-value>classpath:springmvc.xml</param-value>\n        </init-param>\n        <load-on-startup>1</load-on-startup>\n    </servlet>\n\n    <servlet-mapping>\n        <servlet-name>dispatcherServlet</servlet-name>\n        <url-pattern>/</url-pattern>\n    </servlet-mapping>\n    <servlet-mapping>\n        <servlet-name>default</servlet-name>\n        <url-pattern>*.html</url-pattern>\n    </servlet-mapping>\n    <servlet-mapping>\n        <servlet-name>default</servlet-name>\n        <url-pattern>/css/*</url-pattern>\n    </servlet-mapping>\n    <servlet-mapping>\n        <servlet-name>default</servlet-name>\n        <url-pattern>/front/*</url-pattern>\n    </servlet-mapping>\n    <servlet-mapping>\n        <servlet-name>default</servlet-name>\n        <url-pattern>/js/*</url-pattern>\n    </servlet-mapping>\n\n</web-app>\n```\n### springmvc.xml\n这个基本没有什么变化，就是在扫包的时候可以只扫描controller下的文件<br>\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\n       http://www.springframework.org/schema/mvc\n       http://www.springframework.org/schema/mvc/spring-mvc.xsd\n       http://www.springframework.org/schema/context\n       http://www.springframework.org/schema/context/spring-context.xsd\">\n\n    <!--扫包-->\n    <context:component-scan base-package=\"roderick.controller\"/>\n\n    <!--视图控制器-->\n    <bean id=\"internalResourceViewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\">\n        <property name=\"prefix\" value=\"/\"/>\n        <property name=\"suffix\" value=\".html\"/>\n    </bean>\n\n    <!--注解支持-->\n    <mvc:annotation-driven/>\n</beans>\n```\n### apllcationContext.xml\n1.扫包的时候可以排除对于接口的扫描<br>\n2.配置MyBatis对于Dao接口的代理，需要SqlSessionFactory和DataSource<br>\n==如果MyBatis使用xml配置还需要配置mapperLoacation==<br>\n```xml\n<!--sqlSessionFactory-->\n<bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\">\n    <property name=\"dataSource\" ref=\"dataSource\"/>\n    <property name=\"mapperLocations\" value=\"classpath:projectMapper.xml\"/>\n</bean>\n```\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n       xmlns:context=\"http://www.springframework.org/schema/context\"\n       xmlns:aop=\"http://www.springframework.org/schema/aop\"\n       xmlns:tx=\"http://www.springframework.org/schema/tx\"\n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n	http://www.springframework.org/schema/beans/spring-beans.xsd\n	http://www.springframework.org/schema/context\n	http://www.springframework.org/schema/context/spring-context.xsd\n	http://www.springframework.org/schema/aop\n	http://www.springframework.org/schema/aop/spring-aop.xsd\n	http://www.springframework.org/schema/tx \n	http://www.springframework.org/schema/tx/spring-tx.xsd\">\n\n    <!--springIOC扫描-->\n    <context:component-scan base-package=\"roderick\">\n        <context:exclude-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/>\n    </context:component-scan>\n\n    <!--整合Mybatis sqlSessionFactory dataSource-->\n    <bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\">\n        <property name=\"basePackage\" value=\"roderick.dao\"/>\n    </bean>\n\n    <!--sqlSessionFactory-->\n    <bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\">\n        <property name=\"dataSource\" ref=\"dataSource\"/>\n        <property name=\"mapperLocations\" value=\"classpath:projectMapper.xml\"/>\n    </bean>\n\n    <!--直接用druid提供的获取链接池，实现了DataSource接口-->\n    <bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\">\n        <property name=\"driverClassName\" value=\"com.mysql.cj.jdbc.Driver\"/>\n        <property name=\"url\" value=\"jdbc:mysql://localhost:3306/my_project?serverTimezone=UTC\"/>\n        <property name=\"username\" value=\"root\"/>\n        <property name=\"password\" value=\"admin\"/>\n    </bean>\n\n</beans>\n```\n\n## controller返回json数据\n使用@ResposeBody注解，表示不是跳转的页面，而是返回的数据，使用ObjectMapper（jackson），封装json数据（当然直接返回字符串也可以）<br>\n```java\n@RequestMapping(value = \"/signUpServlet\")\n    public @ResponseBody\n    String signUp(Project project, Student student) throws JsonProcessingException {\n        HashMap<String, String> hashMap = new HashMap<>();\n        ObjectMapper objectMapper = new ObjectMapper();\n        String json;\n\n        project.setStudent(student);\n        //使用服务层添加数据，封装json\n        try {\n            projectService.addProject(project);\n            hashMap.put(\"msg\", \"success\");\n            json = objectMapper.writeValueAsString(hashMap);    //成功\n        } catch (Exception e) {\n            hashMap.put(\"msg\", \"fail\");\n            json = objectMapper.writeValueAsString(hashMap);   //失败\n            e.printStackTrace();\n        }\n        //返回json数据\n        return json;\n    }\n```',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2020-04-25 17:33:40','2020-11-29 11:45:12',0),(77,'Swagger','```java\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.core.env.Environment;\nimport org.springframework.core.env.Profiles;\nimport springfox.documentation.builders.RequestHandlerSelectors;\nimport springfox.documentation.service.ApiInfo;\nimport springfox.documentation.service.Contact;\nimport springfox.documentation.spi.DocumentationType;\nimport springfox.documentation.spring.web.plugins.Docket;\nimport springfox.documentation.swagger2.annotations.EnableSwagger2;\n\nimport java.util.ArrayList;\n\nimport static springfox.documentation.service.ApiInfo.DEFAULT_CONTACT;\n\n@Configuration\n@EnableSwagger2\npublic class SwaggerConfig {\n    @Bean\n    public Docket docket(Environment environment) {\n        Profiles profiles = Profiles.of(\"dev\");\n        System.out.println(profiles);\n        boolean flag = environment.acceptsProfiles(profiles);\n        return new Docket(DocumentationType.SWAGGER_2)\n                .apiInfo(apiInfo())\n                .enable(flag)//是否启动（自动开启）\n                //配置扫描\n                .select()\n                .apis(RequestHandlerSelectors.basePackage(\"com.roderick.controller.HelloController\"))\n                .build();\n    }\n\n    public ApiInfo apiInfo() {\n        //作者信息\n        Contact contact = new Contact(\"roderick\", \"www.baidu.com\", \"132@qq.com\");\n        return new ApiInfo(\"我的 Documentation\",\n                \"Roderick Api Documentation\",\n                \"5.0\",\n                \"https://www.baidu.com\",\n                contact,\n                \"Apache 2.0\",\n                \"http://www.apache.org/licenses/LICENSE-2.0\",\n                new ArrayList());\n\n    }\n}\n```',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2020-05-08 12:29:22','2020-11-29 11:45:12',0),(78,'Thymeleaf分页条逻辑','Controller：\n```java\n/**\n * 按时间顺序获取文章列表页面\n *\n * @param page 页面\n * @param size 每页数据的条数 default 5\n */\n@GetMapping({\"/{page}/{size}\", \"\"})\npublic String getArticleList(@PathVariable(value = \"page\", required = false) Integer page,\n                             @PathVariable(value = \"size\", required = false) Integer size,\n                             Model model) {\n    Page<Article> articlePage = articleService.getArticleListByPageOrderByTime(page, size);\n\n    model.addAttribute(\"articlePage\", articlePage);\n    model.addAttribute(\"totalPage\", pageUtil.getTotalPage(articlePage.getTotal(), articlePage.getSize()));\n    return \"blog/list\";\n}\n```\n\n包含分页逻辑：\n```html\n<!DOCTYPE html>\n<html xmlns:th=\"http://www.thymeleaf.org\" lang=\"zh\">\n<!--分页 参数：现在的页面 分页条的大小 总页面数-->\n<nav th:fragment=\"page-navigation(currentPage,barSize,totalPage)\" style=\"float: right\">\n    <ul class=\"pagination\">\n        <li class=\"page-item\" th:if=\"${currentPage>1}\">\n            <a class=\"page-link\" th:href=\"@{\'/blog\' + \'/\' + ${currentPage - 1} + \'/\' + \'5\'}\" aria-label=\"Previous\">\n                <span aria-hidden=\"true\">&laquo;</span>\n            </a>\n        </li>\n\n        <!--totalPage小于等于barSize-->\n        <li th:class=\"${currentPage==i ? \'page-item active\' : \'page-item\'}\" th:if=\"${totalPage<=barSize}\"\n            th:each=\"i:${#numbers.sequence(1,totalPage)}\">\n            <a class=\"page-link\" th:href=\"@{\'/blog\' + \'/\' + ${i} + \'/\' + \'5\'}\" th:text=\"${i}\"></a>\n        </li>\n\n        <!--前-->\n        <li th:class=\"${currentPage==i ? \'page-item active\' : \'page-item\'}\"\n            th:if=\"${totalPage>barSize  && currentPage<=(barSize/2 + 1)}\"\n            th:each=\"i:${#numbers.sequence(1,barSize)}\">\n            <a class=\"page-link\" th:href=\"@{\'/blog\' + \'/\' + ${i} + \'/\' + \'5\'}\" th:text=\"${i}\"></a>\n        </li>\n        <!--中-->\n        <li th:class=\"${currentPage==i ? \'page-item active\' : \'page-item\'}\"\n            th:if=\"${totalPage>barSize  && currentPage>=(barSize/2 + 2) && currentPage<=(totalPage - barSize/2)}\"\n            th:each=\"i:${#numbers.sequence(currentPage - barSize/2,currentPage + barSize/2)}\">\n            <a class=\"page-link\" th:href=\"@{\'/blog\' + \'/\' + ${i} + \'/\' + \'5\'}\" th:text=\"${i}\"></a>\n        </li>\n        <!--后-->\n        <li th:class=\"${currentPage==i ? \'page-item active\' : \'page-item\'}\"\n            th:if=\"${totalPage>barSize  && currentPage>=(totalPage - barSize/2 + 1)}\"\n            th:each=\"i:${#numbers.sequence(totalPage - barSize + 1,totalPage)}\">\n            <a class=\"page-link\" th:href=\"@{\'/blog\' + \'/\' + ${i} + \'/\' + \'5\'}\" th:text=\"${i}\"></a>\n        </li>\n\n        <li class=\"page-item\" th:if=\"${currentPage<totalPage}\">\n            <a class=\"page-link\" th:href=\"@{\'/blog\' + \'/\' + ${currentPage + 1} + \'/\' + \'5\'}\" aria-label=\"Next\">\n                <span aria-hidden=\"true\">&raquo;</span>\n            </a>\n        </li>\n    </ul>\n</nav>\n</html>\n```',42,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2020-11-28 09:08:34','2020-11-29 11:45:12',0),(79,'Response笔记','组件	许可证密钥	\r\nVMware vSphere Hypervisor 6 License	J528Q-4UJ15-R8481-0JCAP-00H3P\r\n# 今日内容\r\n	\r\n	1. HTTP协议：响应消息\r\n	2. Response对象\r\n	3. ServletContext对象\r\n\r\n\r\n## HTTP协议：\r\n	1. 请求消息：客户端发送给服务器端的数据\r\n		* 数据格式：\r\n			1. 请求行\r\n			2. 请求头\r\n			3. 请求空行\r\n			4. 请求体\r\n	2. 响应消息：服务器端发送给客户端的数据\r\n		* 数据格式：\r\n			1. 响应行\r\n				1. 组成：协议/版本 响应状态码 状态码描述\r\n				2. 响应状态码：服务器告诉客户端浏览器本次请求和响应的一个状态。\r\n					1. 状态码都是3位数字 \r\n					2. 分类：\r\n						1. 1xx：服务器就收客户端消息，但没有接受完成，等待一段时间后，发送1xx多状态码\r\n						2. 2xx：成功。代表：200\r\n						3. 3xx：重定向。代表：302(重定向)，304(访问缓存)\r\n						4. 4xx：客户端错误。\r\n							* 代表：\r\n								* 404（请求路径没有对应的资源） \r\n								* 405：请求方式没有对应的doXxx方法\r\n						5. 5xx：服务器端错误。代表：500(服务器内部出现异常)\r\n							\r\n					\r\n			2. 响应头：\r\n				1. 格式：头名称： 值\r\n				2. 常见的响应头：\r\n					1. Content-Type：服务器告诉客户端本次响应体数据格式以及编码格式\r\n					2. Content-disposition：服务器告诉客户端以什么格式打开响应体数据\r\n						* 值：\r\n							* in-line:默认值,在当前页面内打开\r\n							* attachment;filename=xxx：以附件形式打开响应体。文件下载\r\n			3. 响应空行\r\n			4. 响应体:传输的数据\r\n\r\n\r\n		* 响应字符串格式\r\n			HTTP/1.1 200 OK\r\n			Content-Type: text/html;charset=UTF-8\r\n			Content-Length: 101\r\n			Date: Wed, 06 Jun 2018 07:08:42 GMT\r\n	\r\n			<html>\r\n			  <head>\r\n			    <title>$Title$</title>\r\n			  </head>\r\n			  <body>\r\n			  hello , response\r\n			  </body>\r\n			</html>\r\n\r\n\r\n\r\n## Response对象\r\n	* 功能：设置响应消息\r\n		1. 设置响应行\r\n			1. 格式：HTTP/1.1 200 ok\r\n			2. 设置状态码：setStatus(int sc) \r\n		2. 设置响应头：setHeader(String name, String value) \r\n			\r\n		3. 设置响应体：\r\n			* 使用步骤：\r\n				1. 获取输出流\r\n					* 字符输出流：PrintWriter getWriter()\r\n\r\n					* 字节输出流：ServletOutputStream getOutputStream()\r\n\r\n				2. 使用输出流，将数据输出到客户端浏览器\r\n\r\n\r\n	* 案例：\r\n		1. 完成重定向\r\n			* 重定向：资源跳转的方式\r\n			* 代码实现：\r\n				//1. 设置状态码为302\r\n		        response.setStatus(302);\r\n		        //2.设置响应头location\r\n		        response.setHeader(\"location\",\"/day15/responseDemo2\");\r\n\r\n\r\n		        //简单的重定向方法\r\n		        response.sendRedirect(\"/day15/responseDemo2\");\r\n\r\n			* 重定向的特点:redirect\r\n				1. 地址栏发生变化\r\n				2. 重定向可以访问其他站点(服务器)的资源\r\n				3. 重定向是两次请求。不能使用request对象来共享数据\r\n			* 转发的特点：forward\r\n				1. 转发地址栏路径不变\r\n				2. 转发只能访问当前服务器下的资源\r\n				3. 转发是一次请求，可以使用request对象来共享数据\r\n			\r\n			* forward 和  redirect 区别\r\n				\r\n			* 路径写法：\r\n				1. 路径分类\r\n					1. 相对路径：通过相对路径不可以确定唯一资源\r\n						* 如：./index.html\r\n						* 不以/开头，以.开头路径\r\n\r\n						* 规则：找到当前资源和目标资源之间的相对位置关系\r\n							* ./：当前目录\r\n							* ../:后退一级目录\r\n					2. 绝对路径：通过绝对路径可以确定唯一资源\r\n						* 如：http://localhost/day15/responseDemo2		/day15/responseDemo2\r\n						* 以/开头的路径\r\n\r\n						* 规则：判断定义的路径是给谁用的？判断请求将来从哪儿发出\r\n							* 给客户端浏览器使用：需要加虚拟目录(项目的访问路径)\r\n								* 建议虚拟目录动态获取：request.getContextPath()\r\n								* <a> , <form> 重定向...\r\n							* 给服务器使用：不需要加虚拟目录\r\n								* 转发路径\r\n								\r\n						\r\n						\r\n\r\n		2. 服务器输出字符数据到浏览器\r\n			* 步骤：\r\n				1. 获取字符输出流\r\n				2. 输出数据\r\n\r\n			* 注意：\r\n				* 乱码问题：\r\n					1. PrintWriter pw = response.getWriter();获取的流的默认编码是ISO-8859-1\r\n					2. 设置该流的默认编码\r\n					3. 告诉浏览器响应体使用的编码\r\n\r\n					//简单的形式，设置编码，是在获取流之前设置\r\n        			response.setContentType(\"text/html;charset=utf-8\");\r\n		3. 服务器输出字节数据到浏览器\r\n			* 步骤：\r\n				1. 获取字节输出流\r\n				2. 输出数据\r\n\r\n		4. 验证码\r\n			1. 本质：图片\r\n			2. 目的：防止恶意表单注册\r\n	\r\n\r\n\r\n## ServletContext对象：\r\n	1. 概念：代表整个web应用，可以和程序的容器(服务器)来通信\r\n	2. 获取：\r\n		1. 通过request对象获取\r\n			request.getServletContext();\r\n		2. 通过HttpServlet获取\r\n			this.getServletContext();\r\n	3. 功能：\r\n		1. 获取MIME类型：\r\n			* MIME类型:在互联网通信过程中定义的一种文件数据类型\r\n				* 格式： 大类型/小类型   text/html		image/jpeg\r\n\r\n			* 获取：String getMimeType(String file)  \r\n		2. 域对象：共享数据\r\n			1. setAttribute(String name,Object value)\r\n			2. getAttribute(String name)\r\n			3. removeAttribute(String name)\r\n\r\n			* ServletContext对象范围：所有用户所有请求的数据\r\n		3. 获取文件的真实(服务器)路径\r\n			1. 方法：String getRealPath(String path)  \r\n				 String b = context.getRealPath(\"/b.txt\");//web目录下资源访问\r\n		         System.out.println(b);\r\n		\r\n		        String c = context.getRealPath(\"/WEB-INF/c.txt\");//WEB-INF目录下的资源访问\r\n		        System.out.println(c);\r\n		\r\n		        String a = context.getRealPath(\"/WEB-INF/classes/a.txt\");//src目录下的资源访问\r\n		        System.out.println(a);\r\n\r\n\r\n\r\n## 案例：\r\n	* 文件下载需求：\r\n		1. 页面显示超链接\r\n		2. 点击超链接后弹出下载提示框\r\n		3. 完成图片文件下载\r\n\r\n\r\n	* 分析：\r\n		1. 超链接指向的资源如果能够被浏览器解析，则在浏览器中展示，如果不能解析，则弹出下载提示框。不满足需求\r\n		2. 任何资源都必须弹出下载提示框\r\n		3. 使用响应头设置资源的打开方式：\r\n			* content-disposition:attachment;filename=xxx\r\n\r\n\r\n	* 步骤：\r\n		1. 定义页面，编辑超链接href属性，指向Servlet，传递资源名称filename\r\n		2. 定义Servlet\r\n			1. 获取文件名称\r\n			2. 使用字节输入流加载文件进内存\r\n			3. 指定response的响应头： content-disposition:attachment;filename=xxx\r\n			4. 将数据写出到response输出流\r\n\r\n\r\n	* 问题：\r\n		* 中文文件问题\r\n			* 解决思路：\r\n				1. 获取客户端使用的浏览器版本信息\r\n				2. 根据不同的版本信息，设置filename的编码方式不同',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2020-02-29 22:09:06','2020-11-29 11:45:12',0),(80,'Servlet&HTTP&Request笔记','# 今日内容：\r\n	1. Servlet\r\n	2. HTTP协议\r\n	3. Request\r\n\r\n\r\n\r\n\r\n## Servlet：\r\n	1. 概念\r\n	2. 步骤\r\n	3. 执行原理\r\n	4. 生命周期\r\n	5. Servlet3.0 注解配置\r\n	6. Servlet的体系结构	\r\n		Servlet -- 接口\r\n			|\r\n		GenericServlet -- 抽象类\r\n			|\r\n		HttpServlet  -- 抽象类\r\n\r\n		* GenericServlet：将Servlet接口中其他的方法做了默认空实现，只将service()方法作为抽象\r\n			* 将来定义Servlet类时，可以继承GenericServlet，实现service()方法即可\r\n\r\n		* HttpServlet：对http协议的一种封装，简化操作\r\n			1. 定义类继承HttpServlet\r\n			2. 复写doGet/doPost方法\r\n	\r\n	7. Servlet相关配置\r\n		1. urlpartten:Servlet访问路径\r\n			1. 一个Servlet可以定义多个访问路径 ： @WebServlet({\"/d4\",\"/dd4\",\"/ddd4\"})\r\n			2. 路径定义规则：\r\n				1. /xxx：路径匹配\r\n				2. /xxx/xxx:多层路径，目录结构\r\n				3. *.do：扩展名匹配\r\n\r\n## HTTP：\r\n	* 概念：Hyper Text Transfer Protocol 超文本传输协议\r\n		* 传输协议：定义了，客户端和服务器端通信时，发送数据的格式\r\n		* 特点：\r\n			1. 基于TCP/IP的高级协议\r\n			2. 默认端口号:80\r\n			3. 基于请求/响应模型的:一次请求对应一次响应\r\n			4. 无状态的：每次请求之间相互独立，不能交互数据\r\n\r\n		* 历史版本：\r\n			* 1.0：每一次请求响应都会建立新的连接\r\n			* 1.1：复用连接\r\n\r\n	* 请求消息数据格式\r\n		1. 请求行\r\n			请求方式 请求url 请求协议/版本\r\n			GET /login.html	HTTP/1.1\r\n\r\n			* 请求方式：\r\n				* HTTP协议有7中请求方式，常用的有2种\r\n					* GET：\r\n						1. 请求参数在请求行中，在url后。\r\n						2. 请求的url长度有限制的\r\n						3. 不太安全\r\n					* POST：\r\n						1. 请求参数在请求体中\r\n						2. 请求的url长度没有限制的\r\n						3. 相对安全\r\n		2. 请求头：客户端浏览器告诉服务器一些信息\r\n			请求头名称: 请求头值\r\n			* 常见的请求头：\r\n				1. User-Agent：浏览器告诉服务器，我访问你使用的浏览器版本信息\r\n					* 可以在服务器端获取该头的信息，解决浏览器的兼容性问题\r\n\r\n				2. Referer：http://localhost/login.html\r\n					* 告诉服务器，我(当前请求)从哪里来？\r\n						* 作用：\r\n							1. 防盗链：\r\n							2. 统计工作：\r\n		3. 请求空行\r\n			空行，就是用于分割POST请求的请求头，和请求体的。\r\n		4. 请求体(正文)：\r\n			* 封装POST请求消息的请求参数的\r\n\r\n		* 字符串格式：\r\n			POST /login.html	HTTP/1.1\r\n			Host: localhost\r\n			User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:60.0) Gecko/20100101 Firefox/60.0\r\n			Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\r\n			Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2\r\n			Accept-Encoding: gzip, deflate\r\n			Referer: http://localhost/login.html\r\n			Connection: keep-alive\r\n			Upgrade-Insecure-Requests: 1\r\n			\r\n			username=zhangsan	\r\n\r\n\r\n	* 响应消息数据格式\r\n\r\n\r\n\r\n\r\n## Request：\r\n	1. request对象和response对象的原理\r\n		1. request和response对象是由服务器创建的。我们来使用它们\r\n		2. request对象是来获取请求消息，response对象是来设置响应消息\r\n	\r\n	2. request对象继承体系结构：	\r\n		ServletRequest		--	接口\r\n			|	继承\r\n		HttpServletRequest	-- 接口\r\n			|	实现\r\n		org.apache.catalina.connector.RequestFacade 类(tomcat)\r\n\r\n	3. request功能：\r\n		1. 获取请求消息数据\r\n			1. 获取请求行数据\r\n				* GET /day14/demo1?name=zhangsan HTTP/1.1\r\n				* 方法：\r\n					1. 获取请求方式 ：GET\r\n						* String getMethod()  \r\n					2. (*)获取虚拟目录：/day14\r\n						* String getContextPath()\r\n					3. 获取Servlet路径: /demo1\r\n						* String getServletPath()\r\n					4. 获取get方式请求参数：name=zhangsan\r\n						* String getQueryString()\r\n					5. (*)获取请求URI：/day14/demo1\r\n						* String getRequestURI():		/day14/demo1\r\n						* StringBuffer getRequestURL()  :http://localhost/day14/demo1\r\n\r\n						* URL:统一资源定位符 ： http://localhost/day14/demo1	中华人民共和国\r\n						* URI：统一资源标识符 : /day14/demo1					共和国\r\n					\r\n					6. 获取协议及版本：HTTP/1.1\r\n						* String getProtocol()\r\n\r\n					7. 获取客户机的IP地址：\r\n						* String getRemoteAddr()\r\n					\r\n			2. 获取请求头数据\r\n				* 方法：\r\n					* (*)String getHeader(String name):通过请求头的名称获取请求头的值\r\n					* Enumeration<String> getHeaderNames():获取所有的请求头名称\r\n				\r\n			3. 获取请求体数据:\r\n				* 请求体：只有POST请求方式，才有请求体，在请求体中封装了POST请求的请求参数\r\n				* 步骤：\r\n					1. 获取流对象\r\n						*  BufferedReader getReader()：获取字符输入流，只能操作字符数据\r\n						*  ServletInputStream getInputStream()：获取字节输入流，可以操作所有类型数据\r\n							* 在文件上传知识点后讲解\r\n\r\n					2. 再从流对象中拿数据\r\n				\r\n				\r\n		2. 其他功能：\r\n			1. 获取请求参数通用方式：不论get还是post请求方式都可以使用下列方法来获取请求参数\r\n				1. String getParameter(String name):根据参数名称获取参数值    username=zs&password=123\r\n				2. String[] getParameterValues(String name):根据参数名称获取参数值的数组  hobby=xx&hobby=game\r\n				3. Enumeration<String> getParameterNames():获取所有请求的参数名称\r\n				4. Map<String,String[]> getParameterMap():获取所有参数的map集合\r\n\r\n				* 中文乱码问题：\r\n					* get方式：tomcat 8 已经将get方式乱码问题解决了\r\n					* post方式：会乱码\r\n						* 解决：在获取参数前，设置request的编码request.setCharacterEncoding(\"utf-8\");\r\n			\r\n					\r\n			2. 请求转发：一种在服务器内部的资源跳转方式\r\n				1. 步骤：\r\n					1. 通过request对象获取请求转发器对象：RequestDispatcher getRequestDispatcher(String path)\r\n					2. 使用RequestDispatcher对象来进行转发：forward(ServletRequest request, ServletResponse response) \r\n\r\n				2. 特点：\r\n					1. 浏览器地址栏路径不发生变化\r\n					2. 只能转发到当前服务器内部资源中。\r\n					3. 转发是一次请求\r\n\r\n\r\n			3. 共享数据：\r\n				* 域对象：一个有作用范围的对象，可以在范围内共享数据\r\n				* request域：代表一次请求的范围，一般用于请求转发的多个资源中共享数据\r\n				* 方法：\r\n					1. void setAttribute(String name,Object obj):存储数据\r\n					2. Object getAttitude(String name):通过键获取值\r\n					3. void removeAttribute(String name):通过键移除键值对\r\n\r\n			4. 获取ServletContext：\r\n				* ServletContext getServletContext()\r\n			\r\n\r\n\r\n\r\n## 案例：用户登录\r\n	* 用户登录案例需求：\r\n		1.编写login.html登录页面\r\n			username & password 两个输入框\r\n		2.使用Druid数据库连接池技术,操作mysql，day14数据库中user表\r\n		3.使用JdbcTemplate技术封装JDBC\r\n		4.登录成功跳转到SuccessServlet展示：登录成功！用户名,欢迎您\r\n		5.登录失败跳转到FailServlet展示：登录失败，用户名或密码错误\r\n\r\n\r\n	* 分析\r\n\r\n	* 开发步骤\r\n		1. 创建项目，导入html页面，配置文件，jar包\r\n		2. 创建数据库环境\r\n			CREATE DATABASE day14;\r\n			USE day14;\r\n			CREATE TABLE USER(\r\n			\r\n				id INT PRIMARY KEY AUTO_INCREMENT,\r\n				username VARCHAR(32) UNIQUE NOT NULL,\r\n				PASSWORD VARCHAR(32) NOT NULL\r\n			);\r\n\r\n		3. 创建包cn.itcast.domain,创建类User\r\n			package cn.itcast.domain;\r\n			/**\r\n			 * 用户的实体类\r\n			 */\r\n			public class User {\r\n			\r\n			    private int id;\r\n			    private String username;\r\n			    private String password;\r\n			\r\n			\r\n			    public int getId() {\r\n			        return id;\r\n			    }\r\n			\r\n			    public void setId(int id) {\r\n			        this.id = id;\r\n			    }\r\n			\r\n			    public String getUsername() {\r\n			        return username;\r\n			    }\r\n			\r\n			    public void setUsername(String username) {\r\n			        this.username = username;\r\n			    }\r\n			\r\n			    public String getPassword() {\r\n			        return password;\r\n			    }\r\n			\r\n			    public void setPassword(String password) {\r\n			        this.password = password;\r\n			    }\r\n			\r\n			    @Override\r\n			    public String toString() {\r\n			        return \"User{\" +\r\n			                \"id=\" + id +\r\n			                \", username=\'\" + username + \'\\\'\' +\r\n			                \", password=\'\" + password + \'\\\'\' +\r\n			                \'}\';\r\n			    }\r\n			}\r\n		4. 创建包cn.itcast.util,编写工具类JDBCUtils\r\n			package cn.itcast.util;\r\n\r\n			import com.alibaba.druid.pool.DruidDataSourceFactory;\r\n			\r\n			import javax.sql.DataSource;\r\n			import javax.xml.crypto.Data;\r\n			import java.io.IOException;\r\n			import java.io.InputStream;\r\n			import java.sql.Connection;\r\n			import java.sql.SQLException;\r\n			import java.util.Properties;\r\n			\r\n			/**\r\n			 * JDBC工具类 使用Durid连接池\r\n			 */\r\n			public class JDBCUtils {\r\n			\r\n			    private static DataSource ds ;\r\n			\r\n			    static {\r\n			\r\n			        try {\r\n			            //1.加载配置文件\r\n			            Properties pro = new Properties();\r\n			            //使用ClassLoader加载配置文件，获取字节输入流\r\n			            InputStream is = JDBCUtils.class.getClassLoader().getResourceAsStream(\"druid.properties\");\r\n			            pro.load(is);\r\n			\r\n			            //2.初始化连接池对象\r\n			            ds = DruidDataSourceFactory.createDataSource(pro);\r\n			\r\n			        } catch (IOException e) {\r\n			            e.printStackTrace();\r\n			        } catch (Exception e) {\r\n			            e.printStackTrace();\r\n			        }\r\n			    }\r\n			\r\n			    /**\r\n			     * 获取连接池对象\r\n			     */\r\n			    public static DataSource getDataSource(){\r\n			        return ds;\r\n			    }\r\n			\r\n			\r\n			    /**\r\n			     * 获取连接Connection对象\r\n			     */\r\n			    public static Connection getConnection() throws SQLException {\r\n			        return  ds.getConnection();\r\n			    }\r\n			}\r\n		5. 创建包cn.itcast.dao,创建类UserDao,提供login方法\r\n			\r\n			package cn.itcast.dao;\r\n\r\n			import cn.itcast.domain.User;\r\n			import cn.itcast.util.JDBCUtils;\r\n			import org.springframework.dao.DataAccessException;\r\n			import org.springframework.jdbc.core.BeanPropertyRowMapper;\r\n			import org.springframework.jdbc.core.JdbcTemplate;\r\n			\r\n			/**\r\n			 * 操作数据库中User表的类\r\n			 */\r\n			public class UserDao {\r\n			\r\n			    //声明JDBCTemplate对象共用\r\n			    private JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource());\r\n			\r\n			    /**\r\n			     * 登录方法\r\n			     * @param loginUser 只有用户名和密码\r\n			     * @return user包含用户全部数据,没有查询到，返回null\r\n			     */\r\n			    public User login(User loginUser){\r\n			        try {\r\n			            //1.编写sql\r\n			            String sql = \"select * from user where username = ? and password = ?\";\r\n			            //2.调用query方法\r\n			            User user = template.queryForObject(sql,\r\n			                    new BeanPropertyRowMapper<User>(User.class),\r\n			                    loginUser.getUsername(), loginUser.getPassword());\r\n			\r\n			\r\n			            return user;\r\n			        } catch (DataAccessException e) {\r\n			            e.printStackTrace();//记录日志\r\n			            return null;\r\n			        }\r\n			    }\r\n			}\r\n		\r\n		6. 编写cn.itcast.web.servlet.LoginServlet类\r\n			package cn.itcast.web.servlet;\r\n\r\n			import cn.itcast.dao.UserDao;\r\n			import cn.itcast.domain.User;\r\n			\r\n			import javax.servlet.ServletException;\r\n			import javax.servlet.annotation.WebServlet;\r\n			import javax.servlet.http.HttpServlet;\r\n			import javax.servlet.http.HttpServletRequest;\r\n			import javax.servlet.http.HttpServletResponse;\r\n			import java.io.IOException;\r\n			\r\n			\r\n			@WebServlet(\"/loginServlet\")\r\n			public class LoginServlet extends HttpServlet {\r\n			\r\n			\r\n			    @Override\r\n			    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\r\n			        //1.设置编码\r\n			        req.setCharacterEncoding(\"utf-8\");\r\n			        //2.获取请求参数\r\n			        String username = req.getParameter(\"username\");\r\n			        String password = req.getParameter(\"password\");\r\n			        //3.封装user对象\r\n			        User loginUser = new User();\r\n			        loginUser.setUsername(username);\r\n			        loginUser.setPassword(password);\r\n			\r\n			        //4.调用UserDao的login方法\r\n			        UserDao dao = new UserDao();\r\n			        User user = dao.login(loginUser);\r\n			\r\n			        //5.判断user\r\n			        if(user == null){\r\n			            //登录失败\r\n			            req.getRequestDispatcher(\"/failServlet\").forward(req,resp);\r\n			        }else{\r\n			            //登录成功\r\n			            //存储数据\r\n			            req.setAttribute(\"user\",user);\r\n			            //转发\r\n			            req.getRequestDispatcher(\"/successServlet\").forward(req,resp);\r\n			        }\r\n			\r\n			    }\r\n			\r\n			    @Override\r\n			    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\r\n			        this.doGet(req,resp);\r\n			    }\r\n			}\r\n\r\n		7. 编写FailServlet和SuccessServlet类\r\n			@WebServlet(\"/successServlet\")\r\n			public class SuccessServlet extends HttpServlet {\r\n			    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\r\n			        //获取request域中共享的user对象\r\n			        User user = (User) request.getAttribute(\"user\");\r\n			\r\n			        if(user != null){\r\n			            //给页面写一句话\r\n			\r\n			            //设置编码\r\n			            response.setContentType(\"text/html;charset=utf-8\");\r\n			            //输出\r\n			            response.getWriter().write(\"登录成功！\"+user.getUsername()+\",欢迎您\");\r\n			        }\r\n			\r\n			\r\n			    }		\r\n\r\n\r\n			@WebServlet(\"/failServlet\")\r\n			public class FailServlet extends HttpServlet {\r\n			    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\r\n			        //给页面写一句话\r\n			\r\n			        //设置编码\r\n			        response.setContentType(\"text/html;charset=utf-8\");\r\n			        //输出\r\n			        response.getWriter().write(\"登录失败，用户名或密码错误\");\r\n			\r\n			    }\r\n			\r\n			    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\r\n			        this.doPost(request,response);\r\n			    }\r\n			}\r\n\r\n\r\n\r\n		8. login.html中form表单的action路径的写法\r\n			* 虚拟目录+Servlet的资源路径\r\n\r\n		9. BeanUtils工具类，简化数据封装\r\n			* 用于封装JavaBean的\r\n			1. JavaBean：标准的Java类\r\n				1. 要求：\r\n					1. 类必须被public修饰\r\n					2. 必须提供空参的构造器\r\n					3. 成员变量必须使用private修饰\r\n					4. 提供公共setter和getter方法\r\n				2. 功能：封装数据\r\n\r\n\r\n			2. 概念：\r\n				成员变量：\r\n				属性：setter和getter方法截取后的产物\r\n					例如：getUsername() --> Username--> username\r\n\r\n\r\n			3. 方法：\r\n				1. setProperty()\r\n				2. getProperty()\r\n				3. populate(Object obj , Map map):将map集合的键值对信息，封装到对应的JavaBean对象中',1,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2020-01-17 16:28:54','2020-11-29 11:45:12',0),(81,'Tomcat&Servlet笔记','# 今日内容\r\n	1. web相关概念回顾\r\n	2. web服务器软件：Tomcat\r\n	3. Servlet入门学习\r\n\r\n\r\n\r\n\r\n## web相关概念回顾\r\n	1. 软件架构\r\n		1. C/S：客户端/服务器端\r\n		2. B/S：浏览器/服务器端\r\n\r\n	2. 资源分类\r\n		1. 静态资源：所有用户访问后，得到的结果都是一样的，称为静态资源.静态资源可以直接被浏览器解析\r\n			* 如： html,css,JavaScript\r\n		2. 动态资源:每个用户访问相同资源后，得到的结果可能不一样。称为动态资源。动态资源被访问后，需要先转换为静态资源，在返回给浏览器\r\n			* 如：servlet/jsp,php,asp....\r\n			\r\n\r\n	3. 网络通信三要素\r\n		1. IP：电子设备(计算机)在网络中的唯一标识。\r\n		2. 端口：应用程序在计算机中的唯一标识。 0~65536\r\n		3. 传输协议：规定了数据传输的规则\r\n			1. 基础协议：\r\n				1. tcp:安全协议，三次握手。 速度稍慢\r\n				2. udp：不安全协议。 速度快\r\n\r\n\r\n## web服务器软件：\r\n	* 服务器：安装了服务器软件的计算机\r\n	* 服务器软件：接收用户的请求，处理请求，做出响应\r\n	* web服务器软件：接收用户的请求，处理请求，做出响应。\r\n		* 在web服务器软件中，可以部署web项目，让用户通过浏览器来访问这些项目\r\n		* web容器\r\n\r\n\r\n	* 常见的java相关的web服务器软件：\r\n		* webLogic：oracle公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。\r\n		* webSphere：IBM公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。\r\n		* JBOSS：JBOSS公司的，大型的JavaEE服务器，支持所有的JavaEE规范，收费的。\r\n		* Tomcat：Apache基金组织，中小型的JavaEE服务器，仅仅支持少量的JavaEE规范servlet/jsp。开源的，免费的。\r\n\r\n\r\n	* JavaEE：Java语言在企业级开发中使用的技术规范的总和，一共规定了13项大的规范\r\n\r\n	* Tomcat：web服务器软件\r\n		1. 下载：http://tomcat.apache.org/\r\n		2. 安装：解压压缩包即可。\r\n			* 注意：安装目录建议不要有中文和空格\r\n		3. 卸载：删除目录就行了\r\n		4. 启动：\r\n			* bin/startup.bat ,双击运行该文件即可\r\n			* 访问：浏览器输入：http://localhost:8080 回车访问自己\r\n							  http://别人的ip:8080 访问别人\r\n			\r\n			* 可能遇到的问题：\r\n				1. 黑窗口一闪而过：\r\n					* 原因： 没有正确配置JAVA_HOME环境变量\r\n					* 解决方案：正确配置JAVA_HOME环境变量\r\n\r\n				2. 启动报错：\r\n					1. 暴力：找到占用的端口号，并且找到对应的进程，杀死该进程\r\n						* netstat -ano\r\n					2. 温柔：修改自身的端口号\r\n						* conf/server.xml\r\n						* <Connector port=\"8888\" protocol=\"HTTP/1.1\"\r\n			               connectionTimeout=\"20000\"\r\n			               redirectPort=\"8445\" />\r\n						* 一般会将tomcat的默认端口号修改为80。80端口号是http协议的默认端口号。\r\n							* 好处：在访问时，就不用输入端口号\r\n		5. 关闭：\r\n			1. 正常关闭：\r\n				* bin/shutdown.bat\r\n				* ctrl+c\r\n			2. 强制关闭：\r\n				* 点击启动窗口的×\r\n		6. 配置:\r\n			* 部署项目的方式：\r\n				1. 直接将项目放到webapps目录下即可。\r\n					* /hello：项目的访问路径-->虚拟目录\r\n					* 简化部署：将项目打成一个war包，再将war包放置到webapps目录下。\r\n						* war包会自动解压缩\r\n\r\n				2. 配置conf/server.xml文件\r\n					在<Host>标签体中配置\r\n					<Context docBase=\"D:\\hello\" path=\"/hehe\" />\r\n					* docBase:项目存放的路径\r\n					* path：虚拟目录\r\n\r\n				3. 在conf\\Catalina\\localhost创建任意名称的xml文件。在文件中编写\r\n					<Context docBase=\"D:\\hello\" />\r\n					* 虚拟目录：xml文件的名称\r\n			\r\n			* 静态项目和动态项目：\r\n				* 目录结构\r\n					* java动态项目的目录结构：\r\n						-- 项目的根目录\r\n							-- WEB-INF目录：\r\n								-- web.xml：web项目的核心配置文件\r\n								-- classes目录：放置字节码文件的目录\r\n								-- lib目录：放置依赖的jar包\r\n\r\n\r\n			* 将Tomcat集成到IDEA中，并且创建JavaEE的项目，部署项目。\r\n\r\n\r\n\r\n\r\n\r\n## Servlet：  server applet\r\n	* 概念：运行在服务器端的小程序\r\n		* Servlet就是一个接口，定义了Java类被浏览器访问到(tomcat识别)的规则。\r\n		* 将来我们自定义一个类，实现Servlet接口，复写方法。\r\n\r\n\r\n	* 快速入门：\r\n		1. 创建JavaEE项目\r\n		2. 定义一个类，实现Servlet接口\r\n			* public class ServletDemo1 implements Servlet\r\n		3. 实现接口中的抽象方法\r\n		4. 配置Servlet\r\n			 在web.xml中配置：\r\n		    <!--配置Servlet -->\r\n		    <servlet>\r\n		        <servlet-name>demo1</servlet-name>\r\n		        <servlet-class>cn.itcast.web.servlet.ServletDemo1</servlet-class>\r\n		    </servlet>\r\n		\r\n		    <servlet-mapping>\r\n		        <servlet-name>demo1</servlet-name>\r\n		        <url-pattern>/demo1</url-pattern>\r\n		    </servlet-mapping>\r\n\r\n	* 执行原理：\r\n		1. 当服务器接受到客户端浏览器的请求后，会解析请求URL路径，获取访问的Servlet的资源路径\r\n		2. 查找web.xml文件，是否有对应的<url-pattern>标签体内容。\r\n		3. 如果有，则在找到对应的<servlet-class>全类名\r\n		4. tomcat会将字节码文件加载进内存，并且创建其对象\r\n		5. 调用其方法\r\n\r\n	* Servlet中的生命周期方法：\r\n		1. 被创建：执行init方法，只执行一次\r\n			* Servlet什么时候被创建？\r\n				* 默认情况下，第一次被访问时，Servlet被创建\r\n				* 可以配置执行Servlet的创建时机。\r\n					* 在<servlet>标签下配置\r\n						1. 第一次被访问时，创建\r\n	                		* <load-on-startup>的值为负数\r\n			            2. 在服务器启动时，创建\r\n			                * <load-on-startup>的值为0或正整数\r\n\r\n\r\n			* Servlet的init方法，只执行一次，说明一个Servlet在内存中只存在一个对象，Servlet是单例的\r\n				* 多个用户同时访问时，可能存在线程安全问题。\r\n				* 解决：尽量不要在Servlet中定义成员变量。即使定义了成员变量，也不要对修改值\r\n\r\n		2. 提供服务：执行service方法，执行多次\r\n			* 每次访问Servlet时，Service方法都会被调用一次。\r\n		3. 被销毁：执行destroy方法，只执行一次\r\n			* Servlet被销毁时执行。服务器关闭时，Servlet被销毁\r\n			* 只有服务器正常关闭时，才会执行destroy方法。\r\n			* destroy方法在Servlet被销毁之前执行，一般用于释放资源\r\n\r\n	* Servlet3.0：\r\n		* 好处：\r\n			* 支持注解配置。可以不需要web.xml了。\r\n\r\n		* 步骤：\r\n			1. 创建JavaEE项目，选择Servlet的版本3.0以上，可以不创建web.xml\r\n			2. 定义一个类，实现Servlet接口\r\n			3. 复写方法\r\n			4. 在类上使用@WebServlet注解，进行配置\r\n				* @WebServlet(\"资源路径\")\r\n\r\n\r\n				@Target({ElementType.TYPE})\r\n				@Retention(RetentionPolicy.RUNTIME)\r\n				@Documented\r\n				public @interface WebServlet {\r\n				    String name() default \"\";//相当于<Servlet-name>\r\n				\r\n				    String[] value() default {};//代表urlPatterns()属性配置\r\n				\r\n				    String[] urlPatterns() default {};//相当于<url-pattern>\r\n				\r\n				    int loadOnStartup() default -1;//相当于<load-on-startup>\r\n				\r\n				    WebInitParam[] initParams() default {};\r\n				\r\n				    boolean asyncSupported() default false;\r\n				\r\n				    String smallIcon() default \"\";\r\n				\r\n				    String largeIcon() default \"\";\r\n				\r\n				    String description() default \"\";\r\n				\r\n				    String displayName() default \"\";\r\n				}\r\n\r\n\r\n\r\n## IDEA与tomcat的相关配置\r\n	1. IDEA会为每一个tomcat部署的项目单独建立一份配置文件\r\n		* 查看控制台的log：Using CATALINA_BASE:   \"C:\\Users\\fqy\\.IntelliJIdea2018.1\\system\\tomcat\\_itcast\"\r\n\r\n	2. 工作空间项目    和     tomcat部署的web项目\r\n		* tomcat真正访问的是“tomcat部署的web项目”，\"tomcat部署的web项目\"对应着\"工作空间项目\" 的web目录下的所有资源\r\n		* WEB-INF目录下的资源不能被浏览器直接访问。\r\n	3. 断点调试：使用\"小虫子\"启动 dubug 启动\r\n## Servlet原理\r\n![image](https://note.youdao.com/yws/api/personal/file/6C8FEC697A994284AA6F98DE44EE30B2?method=download&shareKey=c6af58d4a551a140443c25d6f0dea75b)',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2020-02-25 20:36:03','2020-11-29 11:45:12',0),(82,'防盗链','```java\npackage servlet;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\n@WebServlet(\"/Demo03\")\npublic class Demo03 extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        String referer = req.getHeader(\"referer\");  //获取请求头中的来源\n        System.out.println(referer);\n        if (referer != null) {\n            if (referer.contains(\"hello\")) {\n                System.out.println(\"跳转成功\");\n            } else {\n                System.out.println(\"跳转失败\");\n            }\n        }else{\n            System.out.println(\"失败\");\n        }\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n        super.doPost(req, resp);\n    }\n}\n```',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2020-02-26 15:19:01','2020-11-29 11:45:12',0),(83,'xml笔记','# 今日内容\r\n	1. XML\r\n		1. 概念\r\n		2. 语法\r\n		3. 解析\r\n\r\n\r\n## XML：\r\n	1. 概念：Extensible Markup Language 可扩展标记语言\r\n		* 可扩展：标签都是自定义的。 <user>  <student>\r\n\r\n		* 功能\r\n			* 存储数据\r\n				1. 配置文件\r\n				2. 在网络中传输\r\n		* xml与html的区别\r\n			1. xml标签都是自定义的，html标签是预定义。\r\n			2. xml的语法严格，html语法松散\r\n			3. xml是存储数据的，html是展示数据\r\n\r\n		* w3c:万维网联盟\r\n\r\n	2. 语法：\r\n		* 基本语法：\r\n			1. xml文档的后缀名 .xml\r\n			2. xml第一行必须定义为文档声明\r\n			3. xml文档中有且仅有一个根标签\r\n			4. 属性值必须使用引号(单双都可)引起来\r\n			5. 标签必须正确关闭\r\n			6. xml标签名称区分大小写\r\n		* 快速入门：\r\n			<?xml version=\'1.0\' ?>\r\n			<users>\r\n				<user id=\'1\'>\r\n					<name>zhangsan</name>\r\n					<age>23</age>\r\n					<gender>male</gender>\r\n					<br/>\r\n				</user>\r\n				\r\n				<user id=\'2\'>\r\n					<name>lisi</name>\r\n					<age>24</age>\r\n					<gender>female</gender>\r\n				</user>\r\n			</users>\r\n			\r\n		* 组成部分：\r\n			1. 文档声明\r\n				1. 格式：<?xml 属性列表 ?>\r\n				2. 属性列表：\r\n					* version：版本号，必须的属性\r\n					* encoding：编码方式。告知解析引擎当前文档使用的字符集，默认值：ISO-8859-1\r\n					* standalone：是否独立\r\n						* 取值：\r\n							* yes：不依赖其他文件\r\n							* no：依赖其他文件\r\n			2. 指令(了解)：结合css的\r\n				* <?xml-stylesheet type=\"text/css\" href=\"a.css\" ?>\r\n			3. 标签：标签名称自定义的\r\n				* 规则：\r\n					* 名称可以包含字母、数字以及其他的字符 \r\n					* 名称不能以数字或者标点符号开始 \r\n					* 名称不能以字母 xml（或者 XML、Xml 等等）开始 \r\n					* 名称不能包含空格 \r\n\r\n			4. 属性：\r\n				id属性值唯一\r\n			5. 文本：\r\n				* CDATA区：在该区域中的数据会被原样展示\r\n					* 格式：  <![CDATA[ 数据 ]]>\r\n\r\n	\r\n		* 约束：规定xml文档的书写规则\r\n			* 作为框架的使用者(程序员)：\r\n				1. 能够在xml中引入约束文档\r\n				2. 能够简单的读懂约束文档\r\n			\r\n			* 分类：\r\n				1. DTD:一种简单的约束技术\r\n				2. Schema:一种复杂的约束技术\r\n\r\n\r\n			* DTD：\r\n				* 引入dtd文档到xml文档中\r\n					* 内部dtd：将约束规则定义在xml文档中\r\n					* 外部dtd：将约束的规则定义在外部的dtd文件中\r\n						* 本地：<!DOCTYPE 根标签名 SYSTEM \"dtd文件的位置\">\r\n						* 网络：<!DOCTYPE 根标签名 PUBLIC \"dtd文件名字\" \"dtd文件的位置URL\">\r\n\r\n\r\n			* Schema:\r\n				* 引入：\r\n					1.填写xml文档的根元素\r\n					2.引入xsi前缀.  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n					3.引入xsd文件命名空间.  xsi:schemaLocation=\"http://www.itcast.cn/xml  student.xsd\"\r\n					4.为每一个xsd约束声明一个前缀,作为标识  xmlns=\"http://www.itcast.cn/xml\" \r\n\r\n				<students   xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\r\n					xmlns=\"http://www.itcast.cn/xml\"\r\n					xsi:schemaLocation=\"http://www.itcast.cn/xml  student.xsd\">\r\n	\r\n	\r\n\r\n	3. 解析：操作xml文档，将文档中的数据读取到内存中\r\n		* 操作xml文档\r\n			1. 解析(读取)：将文档中的数据读取到内存中\r\n			2. 写入：将内存中的数据保存到xml文档中。持久化的存储\r\n\r\n		* 解析xml的方式：\r\n			1. DOM：将标记语言文档一次性加载进内存，在内存中形成一颗dom树\r\n				* 优点：操作方便，可以对文档进行CRUD的所有操作\r\n				* 缺点：占内存\r\n			2. SAX：逐行读取，基于事件驱动的。\r\n				* 优点：不占内存。\r\n				* 缺点：只能读取，不能增删改\r\n\r\n\r\n		\r\n		* xml常见的解析器：\r\n			1. JAXP：sun公司提供的解析器，支持dom和sax两种思想\r\n			2. DOM4J：一款非常优秀的解析器\r\n			3. Jsoup：jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。\r\n			4. PULL：Android操作系统内置的解析器，sax方式的。\r\n\r\n\r\n		* Jsoup：jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。\r\n			* 快速入门：\r\n				* 步骤：\r\n					1. 导入jar包\r\n					2. 获取Document对象\r\n					3. 获取对应的标签Element对象\r\n					4. 获取数据\r\n\r\n			* 代码：\r\n				 //2.1获取student.xml的path\r\n		        String path = JsoupDemo1.class.getClassLoader().getResource(\"student.xml\").getPath();\r\n		        //2.2解析xml文档，加载文档进内存，获取dom树--->Document\r\n		        Document document = Jsoup.parse(new File(path), \"utf-8\");\r\n		        //3.获取元素对象 Element\r\n		        Elements elements = document.getElementsByTag(\"name\");\r\n		\r\n		        System.out.println(elements.size());\r\n		        //3.1获取第一个name的Element对象\r\n		        Element element = elements.get(0);\r\n		        //3.2获取数据\r\n		        String name = element.text();\r\n		        System.out.println(name);\r\n\r\n		* 对象的使用：\r\n			1. Jsoup：工具类，可以解析html或xml文档，返回Document\r\n				* parse：解析html或xml文档，返回Document\r\n					* parse​(File in, String charsetName)：解析xml或html文件的。\r\n					* parse​(String html)：解析xml或html字符串\r\n					* parse​(URL url, int timeoutMillis)：通过网络路径获取指定的html或xml的文档对象\r\n			2. Document：文档对象。代表内存中的dom树\r\n				* 获取Element对象\r\n					* getElementById​(String id)：根据id属性值获取唯一的element对象\r\n					* getElementsByTag​(String tagName)：根据标签名称获取元素对象集合\r\n					* getElementsByAttribute​(String key)：根据属性名称获取元素对象集合\r\n					* getElementsByAttributeValue​(String key, String value)：根据对应的属性名和属性值获取元素对象集合\r\n			3. Elements：元素Element对象的集合。可以当做 ArrayList<Element>来使用\r\n			4. Element：元素对象\r\n				1. 获取子元素对象\r\n					* getElementById​(String id)：根据id属性值获取唯一的element对象\r\n					* getElementsByTag​(String tagName)：根据标签名称获取元素对象集合\r\n					* getElementsByAttribute​(String key)：根据属性名称获取元素对象集合\r\n					* getElementsByAttributeValue​(String key, String value)：根据对应的属性名和属性值获取元素对象集合\r\n\r\n				2. 获取属性值\r\n					* String attr(String key)：根据属性名称获取属性值\r\n				3. 获取文本内容\r\n					* String text():获取文本内容\r\n					* String html():获取标签体的所有内容(包括字标签的字符串内容)\r\n			5. Node：节点对象\r\n				* 是Document和Element的父类\r\n\r\n			\r\n		* 快捷查询方式：\r\n			1. selector:选择器\r\n				* 使用的方法：Elements	select​(String cssQuery)\r\n					* 语法：参考Selector类中定义的语法\r\n			2. XPath：XPath即为XML路径语言，它是一种用来确定XML（标准通用标记语言的子集）文档中某部分位置的语言\r\n				* 使用Jsoup的Xpath需要额外导入jar包。\r\n				* 查询w3cshool参考手册，使用xpath的语法完成查询\r\n				* 代码：\r\n					//1.获取student.xml的path\r\n			        String path = JsoupDemo6.class.getClassLoader().getResource(\"student.xml\").getPath();\r\n			        //2.获取Document对象\r\n			        Document document = Jsoup.parse(new File(path), \"utf-8\");\r\n			\r\n			        //3.根据document对象，创建JXDocument对象\r\n			        JXDocument jxDocument = new JXDocument(document);\r\n			\r\n			        //4.结合xpath语法查询\r\n			        //4.1查询所有student标签\r\n			        List<JXNode> jxNodes = jxDocument.selN(\"//student\");\r\n			        for (JXNode jxNode : jxNodes) {\r\n			            System.out.println(jxNode);\r\n			        }\r\n			\r\n			        System.out.println(\"--------------------\");\r\n			\r\n			        //4.2查询所有student标签下的name标签\r\n			        List<JXNode> jxNodes2 = jxDocument.selN(\"//student/name\");\r\n			        for (JXNode jxNode : jxNodes2) {\r\n			            System.out.println(jxNode);\r\n			        }\r\n			\r\n			        System.out.println(\"--------------------\");\r\n			\r\n			        //4.3查询student标签下带有id属性的name标签\r\n			        List<JXNode> jxNodes3 = jxDocument.selN(\"//student/name[@id]\");\r\n			        for (JXNode jxNode : jxNodes3) {\r\n			            System.out.println(jxNode);\r\n			        }\r\n			        System.out.println(\"--------------------\");\r\n			        //4.4查询student标签下带有id属性的name标签 并且id属性值为itcast\r\n			\r\n			        List<JXNode> jxNodes4 = jxDocument.selN(\"//student/name[@id=\'itcast\']\");\r\n			        for (JXNode jxNode : jxNodes4) {\r\n			            System.out.println(jxNode);\r\n			        }\r\n```java\r\npublic class Xpath {\r\n    public static void main(String[] args) throws IOException, XpathSyntaxErrorException {\r\n        Document document = Jsoup.parse(new File(\"src/xml/students.xml\"), \"utf-8\");\r\n        //创建JXdocument\r\n        JXDocument jxDocument = new JXDocument(document);\r\n        List<JXNode> jxNodes = jxDocument.selN(\"//student[@id=\'000\']/age\"); //查看w3c文档就是\r\n        System.out.println(jxNodes);\r\n    }\r\n}\r\n```',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2020-02-24 17:09:49','2020-11-29 11:45:12',0),(84,'跨域问题','[TOC]\r\n## 跨域问题\r\n\r\n跨域：浏览器对于javascript的同源策略的限制 。\r\n\r\n以下情况都属于跨域：\r\n\r\n| 跨域原因说明       | 示例                                   |\r\n| ------------------ | -------------------------------------- |\r\n| 域名不同           | `www.jd.com` 与 `www.taobao.com`       |\r\n| 域名相同，端口不同 | `www.jd.com:8080` 与 `www.jd.com:8081` |\r\n| 二级域名不同       | `item.jd.com` 与 `miaosha.jd.com`      |\r\n\r\n如果**域名和端口都相同，但是请求路径不同**，不属于跨域，如：\r\n\r\n`www.jd.com/item` \r\n\r\n`www.jd.com/goods`\r\n\r\nhttp和https也属于跨域\r\n\r\n而我们刚才是从`manage.leyou.com`去访问`api.leyou.com`，这属于二级域名不同，跨域了。\r\n\r\n\r\n\r\n### 为什么有跨域问题？\r\n\r\n跨域不一定都会有跨域问题。\r\n\r\n因为跨域问题是浏览器对于ajax请求的一种安全限制：**一个页面发起的ajax请求，只能是与当前页域名相同的路径**，这能有效的阻止跨站攻击。\r\n\r\n因此：**跨域问题 是针对ajax的一种限制**。\r\n\r\n但是这却给我们的开发带来了不便，而且在实际生产环境中，肯定会有很多台服务器之间交互，地址和端口都可能不同，怎么办？\r\n\r\n\r\n\r\n## 解决跨域问题的方案\r\n\r\n目前比较常用的跨域解决方案有3种：\r\n\r\n- Jsonp\r\n\r\n  最早的解决方案，利用script标签可以跨域的原理实现。\r\n\r\n  限制：\r\n\r\n  - 需要服务的支持\r\n  - 只能发起GET请求\r\n\r\n- nginx反向代理\r\n\r\n  思路是：利用nginx把跨域反向代理为不跨域，支持各种请求方式\r\n\r\n  缺点：需要在nginx进行额外配置，语义不清晰 \r\n\r\n- CORS\r\n\r\n  规范化的跨域请求解决方案，安全可靠。\r\n\r\n  优势：\r\n\r\n  - 在服务端进行控制是否允许跨域，可自定义规则\r\n  - 支持各种请求方式\r\n\r\n  缺点：\r\n\r\n  - 会产生额外的请求\r\n\r\n我们这里会采用cors的跨域方案。\r\n\r\n\r\n\r\n## cors解决跨域\r\n\r\n### 什么是cors\r\n\r\nCORS是一个W3C标准，全称是\"跨域资源共享\"（Cross-origin resource sharing）。\r\n\r\n它允许浏览器向跨源服务器，发出[`XMLHttpRequest`](http://www.ruanyifeng.com/blog/2012/09/xmlhttprequest_level_2.html)请求，从而克服了AJAX只能[同源](http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html)使用的限制。\r\n\r\nCORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。\r\n\r\n- 浏览器端：\r\n\r\n  目前，所有浏览器都支持该功能（IE10以下不行）。整个CORS通信过程，都是浏览器自动完成，不需要用户参与。\r\n\r\n- 服务端：\r\n\r\n  CORS通信与AJAX没有任何差别，因此你不需要改变以前的业务逻辑。只不过，浏览器会在请求中携带一些头信息，我们需要以此判断是否允许其跨域，然后在响应头中加入一些信息即可。这一般通过过滤器完成即可。\r\n\r\n\r\n\r\n### 原理有点复杂\r\n\r\n浏览器会将ajax请求分为两类，其处理方案略有差异：简单请求、特殊请求。\r\n\r\n#### 简单请求\r\n\r\n只要同时满足以下两大条件，就属于简单请求。：\r\n\r\n（1) 请求方法是以下三种方法之一：\r\n\r\n- HEAD\r\n- GET\r\n- POST\r\n\r\n（2）HTTP的头信息不超出以下几种字段：\r\n\r\n- Accept\r\n- Accept-Language\r\n- Content-Language\r\n- Last-Event-ID\r\n- Content-Type：只限于三个值`application/x-www-form-urlencoded`、`multipart/form-data`、`text/plain`\r\n\r\n\r\n\r\n当浏览器发现发起的ajax请求是简单请求时，会在请求头中携带一个字段：`Origin`.\r\n```http\r\nOrigin: http://manage.leyou.com\r\n```\r\n\r\n\r\nOrigin中会指出当前请求属于哪个域（协议+域名+端口）。服务会根据这个值决定是否允许其跨域。\r\n\r\n如果服务器允许跨域，需要在返回的响应头中携带下面信息：\r\n\r\n```http\r\nAccess-Control-Allow-Origin: http://manage.leyou.com\r\nAccess-Control-Allow-Credentials: true\r\nContent-Type: text/html; charset=utf-8\r\n```\r\n\r\n- Access-Control-Allow-Origin：可接受的域，是一个具体域名或者*（代表任意域名）\r\n- Access-Control-Allow-Credentials：是否允许携带cookie，默认情况下，cors不会携带cookie，除非这个值是true\r\n\r\n> 有关cookie：\r\n\r\n要想操作cookie，需要满足3个条件：\r\n\r\n- 服务的响应头中需要携带Access-Control-Allow-Credentials并且为true。\r\n- 浏览器发起ajax需要指定withCredentials 为true\r\n- 响应头中的Access-Control-Allow-Origin一定不能为*，必须是指定的域名\r\n\r\n\r\n\r\n#### 特殊请求\r\n\r\n不符合简单请求的条件，会被浏览器判定为特殊请求,，例如请求方式为PUT。\r\n\r\n> 预检请求\r\n\r\n特殊请求会在正式通信之前，增加一次HTTP查询请求，称为\"预检\"请求（preflight）。\r\n\r\n浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的`XMLHttpRequest`请求，否则就报错。\r\n\r\n一个“预检”请求的样板：\r\n\r\n```http\r\nOPTIONS /cors HTTP/1.1\r\nOrigin: http://manage.leyou.com\r\nAccess-Control-Request-Method: PUT\r\nAccess-Control-Request-Headers: X-Custom-Header\r\nHost: api.leyou.com\r\nAccept-Language: en-US\r\nConnection: keep-alive\r\nUser-Agent: Mozilla/5.0...\r\n```\r\n\r\n与简单请求相比，除了Origin以外，多了两个头：\r\n\r\n- Access-Control-Request-Method：接下来会用到的请求方式，比如PUT\r\n- Access-Control-Request-Headers：会额外用到的头信息\r\n\r\n> 预检请求的响应\r\n\r\n服务的收到预检请求，如果许可跨域，会发出响应：\r\n\r\n```http\r\nHTTP/1.1 200 OK\r\nDate: Mon, 01 Dec 2008 01:15:39 GMT\r\nServer: Apache/2.0.61 (Unix)\r\nAccess-Control-Allow-Origin: http://manage.leyou.com\r\nAccess-Control-Allow-Credentials: true\r\nAccess-Control-Allow-Methods: GET, POST, PUT\r\nAccess-Control-Allow-Headers: X-Custom-Header\r\nAccess-Control-Max-Age: 1728000\r\nContent-Type: text/html; charset=utf-8\r\nContent-Encoding: gzip\r\nContent-Length: 0\r\nKeep-Alive: timeout=2, max=100\r\nConnection: Keep-Alive\r\nContent-Type: text/plain\r\n```\r\n\r\n除了`Access-Control-Allow-Origin`和`Access-Control-Allow-Credentials`以外，这里又额外多出3个头：\r\n\r\n- Access-Control-Allow-Methods：允许访问的方式\r\n- Access-Control-Allow-Headers：允许携带的头\r\n- Access-Control-Max-Age：本次许可的有效时长，单位是秒，**过期之前的ajax请求就无需再次进行预检了**\r\n\r\n\r\n\r\n如果浏览器得到上述响应，则认定为可以跨域，后续就跟简单请求的处理是一样的了。\r\n\r\n\r\n\r\n### 实现非常简单\r\n\r\n虽然原理比较复杂，但是前面说过：\r\n\r\n- 浏览器端都有浏览器自动完成，我们无需操心\r\n- 服务端可以通过拦截器统一实现，不必每次都去进行跨域判定的编写。\r\n\r\n事实上，SpringMVC已经帮我们写好了CORS的跨域过滤器：CorsFilter ,内部已经实现了刚才所讲的判定逻辑，我们直接用就好了。\r\n\r\n在`leyou-gateway`中编写一个配置类，并且注册CorsFilter：\r\n\r\n```java\r\nimport org.springframework.context.annotation.Bean;\r\nimport org.springframework.context.annotation.Configuration;\r\nimport org.springframework.web.cors.CorsConfiguration;\r\nimport org.springframework.web.cors.UrlBasedCorsConfigurationSource;\r\nimport org.springframework.web.filter.CorsFilter;\r\n\r\n@Configuration\r\npublic class LeyouCorsConfig {\r\n    @Bean\r\n    public CorsFilter corsFilter() {\r\n        //1.添加CORS配置信息\r\n        CorsConfiguration config = new CorsConfiguration();\r\n        //1) 允许的域,不要写*，否则cookie就无法使用了\r\n        config.addAllowedOrigin(\"http://manage.leyou.com\");\r\n        //2) 是否发送Cookie信息\r\n        config.setAllowCredentials(true);\r\n        //3) 允许的请求方式\r\n        config.addAllowedMethod(\"OPTIONS\");\r\n        config.addAllowedMethod(\"HEAD\");\r\n        config.addAllowedMethod(\"GET\");\r\n        config.addAllowedMethod(\"PUT\");\r\n        config.addAllowedMethod(\"POST\");\r\n        config.addAllowedMethod(\"DELETE\");\r\n        config.addAllowedMethod(\"PATCH\");\r\n        // 4）允许的头信息\r\n        config.addAllowedHeader(\"*\");\r\n\r\n        //2.添加映射路径，我们拦截一切请求\r\n        UrlBasedCorsConfigurationSource configSource = new UrlBasedCorsConfigurationSource();\r\n        configSource.registerCorsConfiguration(\"/**\", config);\r\n\r\n        //3.返回新的CorsFilter.\r\n        return new CorsFilter(configSource);\r\n    }\r\n}\r\n```',1,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2020-07-20 22:30:42','2020-11-29 11:45:12',0),(85,'Stream转为其他数据结构','```java\nStream<String> stream = Stream.of(\"a\",\"b\", \"c\");\n\n//转为数组\n\nString[] strArray1 = stream.toArray(String[]::new);\n\n// 转为 Collection 的实现类\n\nList<String> list1 = stream.collect(Collectors.toList());\n\nList<String> list2 = stream.collect(Collectors.toCollection(ArrayList::new));\n\nSet set1 = stream.collect(Collectors.toSet());\n\nStack stack1 = stream.collect(Collectors.toCollection(Stack::new));\n\n// 转为String\n\nString str = stream.collect(Collectors.joining()).toString();\n```',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2020-02-05 16:09:16','2020-11-29 11:45:12',0),(86,'函数式接口','函数式接口在Java中是指：有且仅有一个抽象方法的接口<br>\n>备注：“语法糖”是指使用更加方便，但是原理不变的代码语法。例如在遍历集合时使用的for-each语法，其实 底层的实现原理仍然是迭代器，这便是“语法糖”。从应用层面来讲，Java中的Lambda可以被当做是匿名内部 类的“语法糖”，但是二者在原理上是不同的。\n### 格式\n接口中有且只有一个抽象方法<br>\n```java\n修饰符 interface 接口名称 {    public abstract 返回值类型 方法名称(可选参数信息);  //  其他非抽象方法内容\n}\n```\n接口\n```java\n@FunctionalInterface\npublic interface MyFunctionalInterface {\n    public abstract void method();\n}\n```\n调用函数式接口\n```java\npublic class Main {\n    public static void show(MyFunctionalInterface myFunctionalInterface){\n        myFunctionalInterface.method();\n    }\n\n    public static void main(String[] args) {\n        show(new MyFunctionalInterfaceImpl());  //传递接口的实现类对象\n        show(new MyFunctionalInterface() {\n            @Override\n            public void method() {\n                System.out.println(\"匿名内部类重写接口方法\");\n            }\n        });\n        show(()-> System.out.println(\"Lambada表达式重写接口中的抽象方法\"));\n    }\n}\n```',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2020-02-03 17:13:12','2020-11-29 11:45:12',0),(87,'函数式接口性能优化','Lambada表达式优化性能<br>\nLambda有延迟执行的特性\n```java\npackage functionalinterface;\n\npublic class Main {\n    public static void show(int i, MyFunctionalInterface myFunctionalInterface) {\n        if (i == 1) {\n            System.out.println(myFunctionalInterface.method());\n        }\n    }\n\n    public static void main(String[] args) {\n        String msg1 = \"hello\";\n        String msg2 = \"h\";\n        show(1, () -> {\n            return msg1 + msg2;\n        });\n    }\n}\n```',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2020-02-04 10:38:57','2020-11-29 11:45:12',0),(88,'作用域','```java\r\npublic class Demo03 {\r\n    //类常量\r\n    static final double PI = 3.14159;   //修饰符不存在先后顺序\r\n\r\n    //类变量：从属于类\r\n    static int a = 100;\r\n\r\n    //属性：变量\r\n    //实例变量：从属于对象，如果不初始化会有初始值\r\n    String name = \"Roderick\";\r\n    int i;\r\n\r\n    //main方法\r\n    public static void main(String[] args) {\r\n        //局部变量\r\n        Demo03 demo03 = new Demo03();\r\n        System.out.println(demo03.i);\r\n        System.out.println(a);  //类变量可以直接调用\r\n    }\r\n\r\n    //其他方法\r\n    public void add(){\r\n\r\n    }\r\n}\r\n```',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2020-01-07 21:22:20','2020-11-29 11:45:12',0),(89,'可变参数','一个方法只能指定一个可变参数，它必须是方法的最后一个参数，任何普通参数必须在其前面声明\n```java\npackage method;\n\nimport sun.nio.cs.ArrayEncoder;\n\npublic class Demo02 {\n    public static void main(String[] args) {\n        Demo02 demo02 = new Demo02();\n        System.out.println(demo02.add(1, 2, 3, 4));\n    }\n\n    //可变参数\n    public double add(double... numbers) {\n        double sum = 0;\n        for (double x : numbers) {\n            sum += x;\n        }\n        return sum;\n    }\n}\n\n```',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2020-01-09 10:36:41','2020-11-29 11:45:12',0),(90,'数组','[TOC]\n#### 数组声明创建\n##### 声明数组\n```java\ndataType[] array;  //首选方法\ndataType array[];    //C语言适应方法\n```\n##### 创建数组\n```java\ndataType[] array = new dataType[arraySize]  //一步到位\n```\n\n```java\npackage array;\n\npublic class ArrayDemon01 {\n    public static void main(String[] args) {\n        int[] numbers;\n        numbers = new int[3];\n        numbers[0] = 1;\n        numbers[1] = 2;\n        numbers[2] = 3;\n        for (int x : numbers) {\n            System.out.println(x);\n        }\n    }\n}\n```\n##### 初始化\n1.静态初始化<br>\n2.动态初始化\n```java\npackage array;\n\npublic class Demon02 {\n    public static void main(String[] args) {\n        //静态初始化：创建 + 初始化\n        int[] a = {1, 2, 3, 4, 5};\n\n        //动态初始化：包含默认初始化\n        int[] b = new int[5];\n    }\n}\n```\n##### 数组高级遍历\n```java\nfor (int x : array){\n    System.out.println(x);\n}\n```',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2020-01-09 17:12:13','2020-11-29 11:45:12',0),(91,'方法的重载','#### 方法重载的规则\n1.方法名必须相同<br>\n2.参数列表必须相同（个数不同、或类型不同、参数排列不同）<br>\n3.方法的返回类型可以相同也可以不同<br>\n4.仅仅返回类型不同不能成为方法的重构<br>\n```java\npackage method;\n\npublic class Demo01 {\n    //main方法\n    public static void main(String[] args) {\n        double result = addNum(2, 3);\n        System.out.println(result);\n    }\n\n\n    //类方法\n    public static int addNum(int a, int b) {\n        return a + b;\n    }\n\n    //方法的重载\n    public static double addNum(double a, double b) {\n        return a + b;\n    }\n}\n\n```',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2020-01-08 18:19:24','2020-11-29 11:45:12',0),(92,'类型转换','和C差不多嘛\n```java\npublic class Demo03 {\n    public static void main(String[] args) {\n        int money = 10_0000_0000;\n        int year = 20;\n        int result = money * year;    //发生溢出\n        long result2 = money * year;  //同样发生溢出，两数使用int型进行运算\n        long result3 = ((long) money) * year;  //正确转换\n\n        System.out.println(result);\n        System.out.println(result2);\n        System.out.println(result3);\n    }\n}\n```',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2020-01-07 20:35:53','2020-11-29 11:45:12',0),(93,'自定义注解','```java\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@interface MyAnnotation {\n    String value() default \"\";\n}\n\n@MyAnnotation(\"成功\")\npublic class BranchTest {\n    public static void print(Class<?> c) {\n        System.out.println(c.getName());\n        MyAnnotation myAnnotation= (MyAnnotation) c.getAnnotation(MyAnnotation.class);\n        System.out.println(myAnnotation.value());\n    }\n\n    public static void main(String[] args) {\n        print(BranchTest.class);\n    }\n}\n```\n结果：\n```java\nBranchTest\n成功\n```',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2020-06-11 15:07:47','2020-11-29 11:45:12',0),(94,'多线程','### 创建多线程\n#### 继承Thread重写run方法\n```java\npublic class MyThread extends Thread {\n\n    public MyThread() {\n        //无参构造器\n    }\n\n    public MyThread(String name) {\n        super(name);\n    }\n\n    @Override\n    public void run() {\n        System.out.println(\"开启线程\" + this.getName());\n        for (int i = 0; i <10 ; i++) {\n            System.out.println(i);\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n```java\npublic class Main {\n    public static void main(String[] args) {\n        MyThread mythread = new MyThread();\n        mythread.start();\n    }\n}\n```\n#### 实现Runable接口\n好处：<br>\n1.避免了单继承的局限性<br>\n&emsp;&emsp;实现了多继承<br>\n2.增强了程序的可扩展性，降低了程序的耦合性<br>\n&emsp;&emsp;实现Runnable接口的方式，把设置线程任务和开启新线程进行了分离<br>\n```java\npublic class RunnableImpl implements Runnable {\n    @Override\n    public void run() {\n        System.out.println(\"启动线程：\");\n    }\n}\n```\nThread传入一个接口对象<br>\n```java\npublic class Main{\n    public static void main(String[] args) {\n        RunnableImpl runnableImpl = new RunnableImpl();\n        Thread thread = new Thread(runnableImpl);\n        thread.start();\n        System.out.println(thread.getName());\n    }\n}\n```\n#### 匿名内部类写法\n```java\npublic class Demon02 {\n    public static void main(String[] args) {\n        //匿名内部类创建线程\n        //1.继承Thread  new MyThread.start();\n        new Thread() {\n            @Override\n            public void run() {\n                System.out.println(Thread.currentThread().getName());\n            }\n        }.start();\n\n        //2.实现Runnable接口 new Thread(runnable).start\n        Runnable runnable = new Runnable() {\n            @Override\n            public void run() {\n                System.out.println(Thread.currentThread().getName());\n            }\n        };\n        new Thread(runnable).start();\n\n    }\n}\n```\n### 多线程内存原理\n![image](https://note.youdao.com/yws/api/personal/file/C05E3AD17AFA4E5CBEC9055792DEBA74?method=download&shareKey=bf1b0fd0d9473e49b51438b172030632)\n### 线程的状态\n![image](https://note.youdao.com/yws/api/personal/file/70A137419FD7496EBCA769E3B604916D?method=download&shareKey=dac85794c1bc7904f5aba13a93cc9a1f)',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2020-01-18 17:30:21','2020-11-29 11:45:12',0),(95,'线程安全问题','[TOC]\n当多个线程抢占同一资源是会发生线程安全问题<br>\n```java\npublic class Main{\n    public static void main(String[] args) {\n        RunnableImpl runnable = new RunnableImpl();\n        new Thread(runnable).start();\n        new Thread(runnable).start();\n        new Thread(runnable).start();\n    }\n}\n```\n```java\npublic class RunnableImpl implements Runnable {\n    private static int ticket = 100;\n    Object object = new Object();\n\n    @Override\n    public void run() {\n        while (ticket > 0) {\n              System.out.println(Thread.currentThread().getName() + \"  \" + ticket);\n              ticket--;\n            }\n    }\n}\n```\n### 解决\n#### 使用synchronized\n同步锁<br>\n只有一个线程运行<br>\n静态synchronized方法传入的对象是实现类.class\n```java\npublic class RunnableImpl implements Runnable {\n    private static int ticket = 100;\n    Object object = new Object();\n\n    @Override\n    public void run() {\n        synchronized (object) {\n        while (ticket > 0) {\n\n                System.out.println(Thread.currentThread().getName() + \"  \" + ticket);\n                ticket--;\n            }\n        }\n    }\n}\n```\n```java\n@Override\npublic synchronized void run() {\n    while (ticket > 0) {\n        System.out.println(Thread.currentThread().getName() + \"  \" + ticket);\n        ticket--;\n    }\n}\n```\n### Lock锁接口\n使用实现类 ReentrantLock<br>\n```java\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class RunnableImpl implements Runnable {\n    private static int ticket = 100;\n    Lock lock = new ReentrantLock();\n    @Override\n    public void run() {\n        lock.lock();    //加锁\n        while (ticket > 0) {\n            System.out.println(Thread.currentThread().getName() + \"  \" + ticket);\n            ticket--;\n        }\n        lock.unlock();  //解锁（通常再finally里写）\n    }\n}\n```\n### 线程之间的通信\nObject.wait();<br>\n当多个线程协作时，比如A，B线程，如果A线程在Runnable（可运行）状态中调用了wait()方法那么A线程就进入 了Waiting（无限等待）状态，同时失去了同步锁。假如这个时候B线程获取到了同步锁，在运行状态中调用了 notify()方法，那么就会将无限等待的A线程唤醒。注意是唤醒，如果获取到锁对象，那么A线程唤醒后就进入 Runnable（可运行）状态；如果没有获取锁对象，那么就进入到Blocked（锁阻塞状态）\n多个等待notify();随机唤醒一个，notifyAll();唤醒全部\n```java\npublic class Demon02 {\n    public static void main(String[] args) {\n        Object obj = new Object();\n        //匿名内部类创建线程\n        //1.继承Thread  new MyThread.start();\n        new Thread() {\n            @Override\n            public void run() {\n                synchronized (obj) {\n                    System.out.println(\"说明需要的数量\" + Thread.currentThread().getName());\n                    try {\n                        obj.wait();\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                    System.out.println(\"吃包子\" + Thread.currentThread().getName());\n                }\n            }\n        }.start();\n\n        new Thread() {\n            @Override\n            public void run() {\n                synchronized (obj) {\n                    System.out.println(\"老板制作包子....\" + Thread.currentThread().getName());\n                    try {\n                        Thread.sleep(5000);\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                    System.out.println(\"包子制作完成\" + Thread.currentThread().getName());\n                    obj.notify();   //唤醒顾客\n                }\n            }\n        }.start();\n    }\n}\n```',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2020-01-18 20:54:32','2020-11-29 11:45:12',0),(96,'线程池','线程池中的线程会不停被使用，线程池也不会停止<br>\n```java\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\npublic class Main {\n    public static void main(String[] args) {\n        //创建线程池\n        ExecutorService executorService = Executors.newFixedThreadPool(2);\n        //线程池中的线程会重复利用\n        executorService.submit(new MyThread());\n        executorService.submit(new MyThread());\n        executorService.submit(new MyThread());\n        executorService.submit(new MyThread());\n        executorService.shutdown(); //销毁线程池\n    }\n}\n```\n```java\npublic class MyThread implements Runnable{\n    @Override\n    public void run() {\n        System.out.println(Thread.currentThread().getName());\n    }\n}\n```',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2020-01-19 15:52:33','2020-11-29 11:45:12',0),(97,'Collection、泛型','# 【Collection、泛型】\n\n## 主要内容\n\n- Collection集合\n- 迭代器\n- 增强for\n- 泛型\n\n## 教学目标\n\n- [ ] 能够说出集合与数组的区别\n- [ ] 说出Collection集合的常用功能\n- [ ] 能够使用迭代器对集合进行取元素\n- [ ] 能够说出集合的使用细节\n- [ ] 能够使用集合存储自定义类型\n- [ ] 能够使用foreach循环遍历集合\n- [ ] 能够使用泛型定义集合对象\n- [ ] 能够理解泛型上下限\n- [ ] 能够阐述泛型通配符的作用\n\n\n\n# 第一章 Collection集合\n\n## 1.1 集合概述\n\n在前面基础班我们已经学习过并使用过集合ArrayList<E> ,那么集合到底是什么呢?\n\n* **集合**：集合是java中提供的一种容器，可以用来存储多个数据。\n\n集合和数组既然都是容器，它们有啥区别呢？\n\n* 数组的长度是固定的。集合的长度是可变的。\n* 数组中存储的是同一类型的元素，可以存储基本数据类型值。集合存储的都是对象。而且对象的类型可以不一致。在开发中一般当对象多的时候，使用集合进行存储。\n\n## 1.2  集合框架\n\nJAVASE提供了满足各种需求的API，在使用这些API前，先了解其继承与接口操作架构，才能了解何时采用哪个类，以及类之间如何彼此合作，从而达到灵活应用。\n\n集合按照其存储结构可以分为两大类，分别是单列集合`java.util.Collection`和双列集合`java.util.Map`，今天我们主要学习`Collection`集合，在day04时讲解`Map`集合。\n\n* **Collection**：单列集合类的根接口，用于存储一系列符合某种规则的元素，它有两个重要的子接口，分别是`java.util.List`和`java.util.Set`。其中，`List`的特点是元素有序、元素可重复。`Set`的特点是元素无序，而且不可重复。`List`接口的主要实现类有`java.util.ArrayList`和`java.util.LinkedList`，`Set`接口的主要实现类有`java.util.HashSet`和`java.util.TreeSet`。\n\n从上面的描述可以看出JDK中提供了丰富的集合类库，为了便于初学者进行系统地学习，接下来通过一张图来描述整个集合类的继承体系。\n\n![](img\\Collection集合体系图.png)\n\n其中，橙色框里填写的都是接口类型，而蓝色框里填写的都是具体的实现类。这几天将针对图中所列举的集合类进行逐一地讲解。\n\n集合本身是一个工具，它存放在java.util包中。在`Collection`接口定义着单列集合框架中最最共性的内容。\n\n## 1.3 Collection 常用功能\n\nCollection是所有单列集合的父接口，因此在Collection中定义了单列集合(List和Set)通用的一些方法，这些方法可用于操作所有的单列集合。方法如下：\n\n* `public boolean add(E e)`：  把给定的对象添加到当前集合中 。\n* `public void clear()` :清空集合中所有的元素。\n* `public boolean remove(E e)`: 把给定的对象在当前集合中删除。\n* `public boolean contains(E e)`: 判断当前集合中是否包含给定的对象。\n* `public boolean isEmpty()`: 判断当前集合是否为空。\n* `public int size()`: 返回集合中元素的个数。\n* `public Object[] toArray()`: 把集合中的元素，存储到数组中。\n\n方法演示：\n\n~~~java\nimport java.util.ArrayList;\nimport java.util.Collection;\n\npublic class Demo1Collection {\n    public static void main(String[] args) {\n		// 创建集合对象 \n    	// 使用多态形式\n    	Collection<String> coll = new ArrayList<String>();\n    	// 使用方法\n    	// 添加功能  boolean  add(String s)\n    	coll.add(\"小李广\");\n    	coll.add(\"扫地僧\");\n    	coll.add(\"石破天\");\n    	System.out.println(coll);\n\n    	// boolean contains(E e) 判断o是否在集合中存在\n    	System.out.println(\"判断  扫地僧 是否在集合中\"+coll.contains(\"扫地僧\"));\n\n    	//boolean remove(E e) 删除在集合中的o元素\n    	System.out.println(\"删除石破天：\"+coll.remove(\"石破天\"));\n    	System.out.println(\"操作之后集合中元素:\"+coll);\n    	\n    	// size() 集合中有几个元素\n		System.out.println(\"集合中有\"+coll.size()+\"个元素\");\n\n		// Object[] toArray()转换成一个Object数组\n    	Object[] objects = coll.toArray();\n    	// 遍历数组\n    	for (int i = 0; i < objects.length; i++) {\n			System.out.println(objects[i]);\n		}\n\n		// void  clear() 清空集合\n		coll.clear();\n		System.out.println(\"集合中内容为：\"+coll);\n		// boolean  isEmpty()  判断是否为空\n		System.out.println(coll.isEmpty());  	\n	}\n}\n~~~\n\n> tips: 有关Collection中的方法可不止上面这些，其他方法可以自行查看API学习。\n\n## 第二章 Iterator迭代器\n\n## 2.1 Iterator接口\n\n在程序开发中，经常需要遍历集合中的所有元素。针对这种需求，JDK专门提供了一个接口`java.util.Iterator`。`Iterator`接口也是Java集合中的一员，但它与`Collection`、`Map`接口有所不同，`Collection`接口与`Map`接口主要用于存储元素，而`Iterator`主要用于迭代访问（即遍历）`Collection`中的元素，因此`Iterator`对象也被称为迭代器。\n\n想要遍历Collection集合，那么就要获取该集合迭代器完成迭代操作，下面介绍一下获取迭代器的方法：\n\n* `public Iterator iterator()`: 获取集合对应的迭代器，用来遍历集合中的元素的。\n\n下面介绍一下迭代的概念：\n\n* **迭代**：即Collection集合元素的通用获取方式。在取元素之前先要判断集合中有没有元素，如果有，就把这个元素取出来，继续在判断，如果还有就再取出出来。一直把集合中的所有元素全部取出。这种取出方式专业术语称为迭代。\n\nIterator接口的常用方法如下：\n\n* `public E next()`:返回迭代的下一个元素。\n* `public boolean hasNext()`:如果仍有元素可以迭代，则返回 true。\n\n接下来我们通过案例学习如何使用Iterator迭代集合中元素：\n\n~~~java\npublic class IteratorDemo {\n  	public static void main(String[] args) {\n        // 使用多态方式 创建对象\n        Collection<String> coll = new ArrayList<String>();\n\n        // 添加元素到集合\n        coll.add(\"串串星人\");\n        coll.add(\"吐槽星人\");\n        coll.add(\"汪星人\");\n        //遍历\n        //使用迭代器 遍历   每个集合对象都有自己的迭代器\n        Iterator<String> it = coll.iterator();\n        //  泛型指的是 迭代出 元素的数据类型\n        while(it.hasNext()){ //判断是否有迭代元素\n            String s = it.next();//获取迭代出的元素\n            System.out.println(s);\n        }\n  	}\n}\n~~~\n\n> tips:：在进行集合元素取出时，如果集合中已经没有元素了，还继续使用迭代器的next方法，将会发生java.util.NoSuchElementException没有集合元素的错误。\n\n## 2.2 迭代器的实现原理\n\n我们在之前案例已经完成了Iterator遍历集合的整个过程。当遍历集合时，首先通过调用t集合的iterator()方法获得迭代器对象，然后使用hashNext()方法判断集合中是否存在下一个元素，如果存在，则调用next()方法将元素取出，否则说明已到达了集合末尾，停止遍历元素。\n\nIterator迭代器对象在遍历集合时，内部采用指针的方式来跟踪集合中的元素，为了让初学者能更好地理解迭代器的工作原理，接下来通过一个图例来演示Iterator对象迭代元素的过程：\n\n![](img\\迭代器原理图.bmp)\n\n在调用Iterator的next方法之前，迭代器的索引位于第一个元素之前，不指向任何元素，当第一次调用迭代器的next方法后，迭代器的索引会向后移动一位，指向第一个元素并将该元素返回，当再次调用next方法时，迭代器的索引会指向第二个元素并将该元素返回，依此类推，直到hasNext方法返回false，表示到达了集合的末尾，终止对元素的遍历。\n\n## 2.3 增强for\n\n增强for循环(也称for each循环)是**JDK1.5**以后出来的一个高级for循环，专门用来遍历数组和集合的。它的内部原理其实是个Iterator迭代器，所以在遍历的过程中，不能对集合中的元素进行增删操作。\n\n格式：\n\n~~~java\nfor(元素的数据类型  变量 : Collection集合or数组){ \n  	//写操作代码\n}\n~~~\n\n它用于遍历Collection和数组。通常只进行遍历元素，不要在遍历的过程中对集合元素进行增删操作。\n\n#### 练习1：遍历数组\n\n~~~java\npublic class NBForDemo1 {\n    public static void main(String[] args) {\n		int[] arr = {3,5,6,87};\n       	//使用增强for遍历数组\n		for(int a : arr){//a代表数组中的每个元素\n			System.out.println(a);\n		}\n	}\n}\n~~~\n\n#### 练习2:遍历集合\n\n~~~java\npublic class NBFor {\n    public static void main(String[] args) {        \n    	Collection<String> coll = new ArrayList<String>();\n    	coll.add(\"小河神\");\n    	coll.add(\"老河神\");\n    	coll.add(\"神婆\");\n    	//使用增强for遍历\n    	for(String s :coll){//接收变量s代表 代表被遍历到的集合元素\n    		System.out.println(s);\n    	}\n	}\n}\n~~~\n\n> tips: 新for循环必须有被遍历的目标。目标只能是Collection或者是数组。新式for仅仅作为遍历操作出现。\n\n# 第三章 泛型\n\n## 3.1  泛型概述\n\n在前面学习集合时，我们都知道集合中是可以存放任意对象的，只要把对象存储集合后，那么这时他们都会被提升成Object类型。当我们在取出每一个对象，并且进行相应的操作，这时必须采用类型转换。\n\n大家观察下面代码：\n\n~~~java\npublic class GenericDemo {\n	public static void main(String[] args) {\n		Collection coll = new ArrayList();\n		coll.add(\"abc\");\n		coll.add(\"itcast\");\n		coll.add(5);//由于集合没有做任何限定，任何类型都可以给其中存放\n		Iterator it = coll.iterator();\n		while(it.hasNext()){\n			//需要打印每个字符串的长度,就要把迭代出来的对象转成String类型\n			String str = (String) it.next();\n			System.out.println(str.length());\n		}\n	}\n}\n~~~\n\n程序在运行时发生了问题**java.lang.ClassCastException**。                                                                                             为什么会发生类型转换异常呢？                                                                                                                                       我们来分析下：由于集合中什么类型的元素都可以存储。导致取出时强转引发运行时 ClassCastException。                                                                                                                                                       怎么来解决这个问题呢？                                                                                                                                                           Collection虽然可以存储各种对象，但实际上通常Collection只存储同一类型对象。例如都是存储字符串对象。因此在JDK5之后，新增了**泛型**(**Generic**)语法，让你在设计API时可以指定类或方法支持泛型，这样我们使用API的时候也变得更为简洁，并得到了编译时期的语法检查。\n\n* **泛型**：可以在类或方法中预支地使用未知的类型。\n\n> tips:一般在创建对象时，将未知的类型确定具体的类型。当没有指定泛型时，默认类型为Object类型。\n\n## 3.2  使用泛型的好处\n\n上一节只是讲解了泛型的引入，那么泛型带来了哪些好处呢？\n\n* 将运行时期的ClassCastException，转移到了编译时期变成了编译失败。\n* 避免了类型强转的麻烦。\n\n通过我们如下代码体验一下：\n\n~~~java\npublic class GenericDemo2 {\n	public static void main(String[] args) {\n        Collection<String> list = new ArrayList<String>();\n        list.add(\"abc\");\n        list.add(\"itcast\");\n        // list.add(5);//当集合明确类型后，存放类型不一致就会编译报错\n        // 集合已经明确具体存放的元素类型，那么在使用迭代器的时候，迭代器也同样会知道具体遍历元素类型\n        Iterator<String> it = list.iterator();\n        while(it.hasNext()){\n            String str = it.next();\n            //当使用Iterator<String>控制元素类型后，就不需要强转了。获取到的元素直接就是String类型\n            System.out.println(str.length());\n        }\n	}\n}\n~~~\n\n> tips:泛型是数据类型的一部分，我们将类名与泛型合并一起看做数据类型。\n\n## 3.3  泛型的定义与使用\n\n我们在集合中会大量使用到泛型，这里来完整地学习泛型知识。\n\n泛型，用来灵活地将数据类型应用到不同的类、方法、接口当中。将数据类型作为参数进行传递。\n\n### 定义和使用含有泛型的类\n\n定义格式：\n\n~~~\n修饰符 class 类名<代表泛型的变量> {  }\n~~~\n\n例如，API中的ArrayList集合：\n\n~~~java\nclass ArrayList<E>{ \n    public boolean add(E e){ }\n\n    public E get(int index){ }\n   	....\n}\n~~~\n\n使用泛型： 即什么时候确定泛型。\n\n**在创建对象的时候确定泛型**\n\n 例如，`ArrayList<String> list = new ArrayList<String>();`\n\n此时，变量E的值就是String类型,那么我们的类型就可以理解为：\n\n~~~java \nclass ArrayList<String>{ \n     public boolean add(String e){ }\n\n     public String get(int index){  }\n     ...\n}\n~~~\n\n再例如，`ArrayList<Integer> list = new ArrayList<Integer>();`\n\n此时，变量E的值就是Integer类型,那么我们的类型就可以理解为：\n\n~~~java\nclass ArrayList<Integer> { \n     public boolean add(Integer e) { }\n\n     public Integer get(int index) {  }\n     ...\n}\n~~~\n\n举例自定义泛型类\n\n~~~java\npublic class MyGenericClass<MVP> {\n	//没有MVP类型，在这里代表 未知的一种数据类型 未来传递什么就是什么类型\n	private MVP mvp;\n     \n    public void setMVP(MVP mvp) {\n        this.mvp = mvp;\n    }\n     \n    public MVP getMVP() {\n        return mvp;\n    }\n}\n~~~\n\n使用:\n\n~~~java\npublic class GenericClassDemo {\n  	public static void main(String[] args) {		 \n         // 创建一个泛型为String的类\n         MyGenericClass<String> my = new MyGenericClass<String>();    	\n         // 调用setMVP\n         my.setMVP(\"大胡子登登\");\n         // 调用getMVP\n         String mvp = my.getMVP();\n         System.out.println(mvp);\n         //创建一个泛型为Integer的类\n         MyGenericClass<Integer> my2 = new MyGenericClass<Integer>(); \n         my2.setMVP(123);   	  \n         Integer mvp2 = my2.getMVP();\n    }\n}\n~~~\n\n###  含有泛型的方法\n\n定义格式：\n\n~~~\n修饰符 <代表泛型的变量> 返回值类型 方法名(参数){  }\n~~~\n\n例如，\n\n~~~java\npublic class MyGenericMethod {	  \n    public <MVP> void show(MVP mvp) {\n    	System.out.println(mvp.getClass());\n    }\n    \n    public <MVP> MVP show2(MVP mvp) {	\n    	return mvp;\n    }\n}\n~~~\n\n使用格式：**调用方法时，确定泛型的类型**\n\n~~~java\npublic class GenericMethodDemo {\n    public static void main(String[] args) {\n        // 创建对象\n        MyGenericMethod mm = new MyGenericMethod();\n        // 演示看方法提示\n        mm.show(\"aaa\");\n        mm.show(123);\n        mm.show(12.45);\n    }\n}\n~~~\n\n### 含有泛型的接口\n\n定义格式：\n\n~~~\n修饰符 interface接口名<代表泛型的变量> {  }\n~~~\n\n例如，\n\n~~~java\npublic interface MyGenericInterface<E>{\n	public abstract void add(E e);\n	\n	public abstract E getE();  \n}\n~~~\n\n使用格式：\n\n**1、定义类时确定泛型的类型**\n\n例如\n\n~~~java\npublic class MyImp1 implements MyGenericInterface<String> {\n	@Override\n    public void add(String e) {\n        // 省略...\n    }\n\n	@Override\n	public String getE() {\n		return null;\n	}\n}\n~~~\n\n此时，泛型E的值就是String类型。\n\n **2、始终不确定泛型的类型，直到创建对象时，确定泛型的类型**\n\n 例如\n\n~~~java\npublic class MyImp2<E> implements MyGenericInterface<E> {\n	@Override\n	public void add(E e) {\n       	 // 省略...\n	}\n\n	@Override\n	public E getE() {\n		return null;\n	}\n}\n~~~\n\n确定泛型：\n\n~~~java\n/*\n * 使用\n */\npublic class GenericInterface {\n    public static void main(String[] args) {\n        MyImp2<String>  my = new MyImp2<String>();  \n        my.add(\"aa\");\n    }\n}\n~~~\n\n## 3.4  泛型通配符\n\n当使用泛型类或者接口时，传递的数据中，泛型类型不确定，可以通过通配符<?>表示。但是一旦使用泛型的通配符后，只能使用Object类中的共性方法，集合中元素自身方法无法使用。\n\n#### 通配符基本使用\n\n泛型的通配符:**不知道使用什么类型来接收的时候,此时可以使用?,?表示未知通配符。**\n\n此时只能接受数据,不能往该集合中存储数据。\n\n举个例子大家理解使用即可：\n\n~~~java\npublic static void main(String[] args) {\n    Collection<Intger> list1 = new ArrayList<Integer>();\n    getElement(list1);\n    Collection<String> list2 = new ArrayList<String>();\n    getElement(list2);\n}\npublic static void getElement(Collection<?> coll){}\n//？代表可以接收任意类型\n~~~\n\n> tips:泛型不存在继承关系 Collection<Object> list = new ArrayList<String>();这种是错误的。\n\n#### 通配符高级使用----受限泛型\n\n之前设置泛型的时候，实际上是可以任意设置的，只要是类就可以设置。但是在JAVA的泛型中可以指定一个泛型的**上限**和**下限**。\n\n**泛型的上限**：\n\n* **格式**： `类型名称 <? extends 类 > 对象名称`\n* **意义**： `只能接收该类型及其子类`\n\n**泛型的下限**：\n\n- **格式**： `类型名称 <? super 类 > 对象名称`\n- **意义**： `只能接收该类型及其父类型`\n\n比如：现已知Object类，String 类，Number类，Integer类，其中Number是Integer的父类\n\n~~~java\npublic static void main(String[] args) {\n    Collection<Integer> list1 = new ArrayList<Integer>();\n    Collection<String> list2 = new ArrayList<String>();\n    Collection<Number> list3 = new ArrayList<Number>();\n    Collection<Object> list4 = new ArrayList<Object>();\n    \n    getElement(list1);\n    getElement(list2);//报错\n    getElement(list3);\n    getElement(list4);//报错\n  \n    getElement2(list1);//报错\n    getElement2(list2);//报错\n    getElement2(list3);\n    getElement2(list4);\n  \n}\n// 泛型的上限：此时的泛型?，必须是Number类型或者Number类型的子类\npublic static void getElement1(Collection<? extends Number> coll){}\n// 泛型的下限：此时的泛型?，必须是Number类型或者Number类型的父类\npublic static void getElement2(Collection<? super Number> coll){}\n~~~\n\n# 第四章 集合综合案例\n\n## 4.1 案例介绍\n\n按照斗地主的规则，完成洗牌发牌的动作。\n具体规则：\n\n使用54张牌打乱顺序,三个玩家参与游戏，三人交替摸牌，每人17张牌，最后三张留作底牌。\n\n## 4.2 案例分析\n\n* 准备牌：\n\n  牌可以设计为一个ArrayList<String>,每个字符串为一张牌。\n  每张牌由花色数字两部分组成，我们可以使用花色集合与数字集合嵌套迭代完成每张牌的组装。\n  牌由Collections类的shuffle方法进行随机排序。\n\n* 发牌\n\n  将每个人以及底牌设计为ArrayList<String>,将最后3张牌直接存放于底牌，剩余牌通过对3取模依次发牌。\n\n\n* 看牌\n\n  直接打印每个集合。\n\n## 4.3 代码实现\n\n~~~java\nimport java.util.ArrayList;\nimport java.util.Collections;\n\npublic class Poker {\n    public static void main(String[] args) {\n        /*\n        * 1: 准备牌操作\n        */\n        //1.1 创建牌盒 将来存储牌面的 \n        ArrayList<String> pokerBox = new ArrayList<String>();\n        //1.2 创建花色集合\n        ArrayList<String> colors = new ArrayList<String>();\n\n        //1.3 创建数字集合\n        ArrayList<String> numbers = new ArrayList<String>();\n\n        //1.4 分别给花色 以及 数字集合添加元素\n        colors.add(\"♥\");\n        colors.add(\"♦\");\n        colors.add(\"♠\");\n        colors.add(\"♣\");\n\n        for(int i = 2;i<=10;i++){\n            numbers.add(i+\"\");\n        }\n        numbers.add(\"J\");\n        numbers.add(\"Q\");\n        numbers.add(\"K\");\n        numbers.add(\"A\");\n        //1.5 创造牌  拼接牌操作\n        // 拿出每一个花色  然后跟每一个数字 进行结合  存储到牌盒中\n        for (String color : colors) {\n            //color每一个花色 \n            //遍历数字集合\n            for(String number : numbers){\n                //结合\n                String card = color+number;\n                //存储到牌盒中\n                pokerBox.add(card);\n            }\n        }\n        //1.6大王小王\n        pokerBox.add(\"小☺\");\n        pokerBox.add(\"大☠\");	  \n        // System.out.println(pokerBox);\n        //洗牌 是不是就是将  牌盒中 牌的索引打乱 \n        // Collections类  工具类  都是 静态方法\n        // shuffer方法   \n        /*\n         * static void shuffle(List<?> list) \n         *     使用默认随机源对指定列表进行置换。 \n         */\n        //2:洗牌\n        Collections.shuffle(pokerBox);\n        //3 发牌\n        //3.1 创建 三个 玩家集合  创建一个底牌集合\n        ArrayList<String> player1 = new ArrayList<String>();\n        ArrayList<String> player2 = new ArrayList<String>();\n        ArrayList<String> player3 = new ArrayList<String>();\n        ArrayList<String> dipai = new ArrayList<String>();	  \n\n        //遍历 牌盒  必须知道索引   \n        for(int i = 0;i<pokerBox.size();i++){\n            //获取 牌面\n            String card = pokerBox.get(i);\n            //留出三张底牌 存到 底牌集合中\n            if(i>=51){//存到底牌集合中\n                dipai.add(card);\n            } else {\n                //玩家1   %3  ==0\n                if(i%3==0){\n                  	player1.add(card);\n                }else if(i%3==1){//玩家2\n                  	player2.add(card);\n                }else{//玩家3\n                  	player3.add(card);\n                }\n            }\n        }\n        //看看\n        System.out.println(\"令狐冲：\"+player1);\n        System.out.println(\"田伯光：\"+player2);\n        System.out.println(\"绿竹翁：\"+player3);\n        System.out.println(\"底牌：\"+dipai);  \n	}\n}\n~~~',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2020-01-17 11:52:44','2020-11-29 11:45:12',0),(98,'File类','# 【File类、递归】\n\n## 主要内容\n\n*  File类\n*  递归\n\n\n## 教学目标\n\n- [ ] 能够说出File对象的创建方式\n- [ ] 能够说出File类获取名称的方法名称\n- [ ] 能够说出File类获取绝对路径的方法名称\n- [ ] 能够说出File类获取文件大小的方法名称\n- [ ] 能够说出File类判断是否是文件的方法名称\n- [ ] 能够说出File类判断是否是文件夹的方法名称\n- [ ] 能够辨别相对路径和绝对路径\n- [ ] 能够遍历文件夹\n- [ ] 能够解释递归的含义\n- [ ] 能够使用递归的方式计算5的阶乘\n- [ ] 能够说出使用递归会内存溢出隐患的原因\n\n# 第一章 File类\n\n## 1.1 概述\n\n`java.io.File` 类是文件和目录路径名的抽象表示，主要用于文件和目录的创建、查找和删除等操作。\n\n## 1.2 构造方法\n\n* `public File(String pathname) ` ：通过将给定的**路径名字符串**转换为抽象路径名来创建新的 File实例。  \n* `public File(String parent, String child) ` ：从**父路径名字符串和子路径名字符串**创建新的 File实例。\n* `public File(File parent, String child)` ：从**父抽象路径名和子路径名字符串**创建新的 File实例。  \n\n\n* 构造举例，代码如下：\n\n```java\n// 文件路径名\nString pathname = \"D:\\\\aaa.txt\";\nFile file1 = new File(pathname); \n\n// 文件路径名\nString pathname2 = \"D:\\\\aaa\\\\bbb.txt\";\nFile file2 = new File(pathname2); \n\n// 通过父路径和子路径字符串\n String parent = \"d:\\\\aaa\";\n String child = \"bbb.txt\";\n File file3 = new File(parent, child);\n\n// 通过父级File对象和子路径字符串\nFile parentDir = new File(\"d:\\\\aaa\");\nString child = \"bbb.txt\";\nFile file4 = new File(parentDir, child);\n```\n\n> 小贴士：\n>\n> 1. 一个File对象代表硬盘中实际存在的一个文件或者目录。\n> 2. 无论该路径下是否存在文件或者目录，都不影响File对象的创建。\n\n## 1.3 常用方法\n\n### 获取功能的方法\n\n* `public String getAbsolutePath() ` ：返回此File的绝对路径名字符串。\n\n* ` public String getPath() ` ：将此File转换为路径名字符串。 \n\n* `public String getName()`  ：返回由此File表示的文件或目录的名称。  \n\n* `public long length()`  ：返回由此File表示的文件的长度。 \n\n  方法演示，代码如下：\n\n  ```java\n  public class FileGet {\n      public static void main(String[] args) {\n          File f = new File(\"d:/aaa/bbb.java\");     \n          System.out.println(\"文件绝对路径:\"+f.getAbsolutePath());\n          System.out.println(\"文件构造路径:\"+f.getPath());\n          System.out.println(\"文件名称:\"+f.getName());\n          System.out.println(\"文件长度:\"+f.length()+\"字节\");\n\n          File f2 = new File(\"d:/aaa\");     \n          System.out.println(\"目录绝对路径:\"+f2.getAbsolutePath());\n          System.out.println(\"目录构造路径:\"+f2.getPath());\n          System.out.println(\"目录名称:\"+f2.getName());\n          System.out.println(\"目录长度:\"+f2.length());\n      }\n  }\n  输出结果：\n  文件绝对路径:d:\\aaa\\bbb.java\n  文件构造路径:d:\\aaa\\bbb.java\n  文件名称:bbb.java\n  文件长度:636字节\n\n  目录绝对路径:d:\\aaa\n  目录构造路径:d:\\aaa\n  目录名称:aaa\n  目录长度:4096\n  ```\n\n> API中说明：length()，表示文件的长度。但是File对象表示目录，则返回值未指定。\n\n### 绝对路径和相对路径\n\n* **绝对路径**：从盘符开始的路径，这是一个完整的路径。\n* **相对路径**：相对于项目目录的路径，这是一个便捷的路径，开发中经常使用。\n\n```java\npublic class FilePath {\n    public static void main(String[] args) {\n      	// D盘下的bbb.java文件\n        File f = new File(\"D:\\\\bbb.java\");\n        System.out.println(f.getAbsolutePath());\n      	\n		// 项目下的bbb.java文件\n        File f2 = new File(\"bbb.java\");\n        System.out.println(f2.getAbsolutePath());\n    }\n}\n输出结果：\nD:\\bbb.java\nD:\\idea_project_test4\\bbb.java\n```\n\n### 判断功能的方法\n\n- `public boolean exists()` ：此File表示的文件或目录是否实际存在。\n- `public boolean isDirectory()` ：此File表示的是否为目录。\n- `public boolean isFile()` ：此File表示的是否为文件。\n\n\n方法演示，代码如下：\n\n```java\npublic class FileIs {\n    public static void main(String[] args) {\n        File f = new File(\"d:\\\\aaa\\\\bbb.java\");\n        File f2 = new File(\"d:\\\\aaa\");\n      	// 判断是否存在\n        System.out.println(\"d:\\\\aaa\\\\bbb.java 是否存在:\"+f.exists());\n        System.out.println(\"d:\\\\aaa 是否存在:\"+f2.exists());\n      	// 判断是文件还是目录\n        System.out.println(\"d:\\\\aaa 文件?:\"+f2.isFile());\n        System.out.println(\"d:\\\\aaa 目录?:\"+f2.isDirectory());\n    }\n}\n输出结果：\nd:\\aaa\\bbb.java 是否存在:true\nd:\\aaa 是否存在:true\nd:\\aaa 文件?:false\nd:\\aaa 目录?:true\n```\n\n### 创建删除功能的方法\n\n- `public boolean createNewFile()` ：当且仅当具有该名称的文件尚不存在时，创建一个新的空文件。 \n- `public boolean delete()` ：删除由此File表示的文件或目录。  \n- `public boolean mkdir()` ：创建由此File表示的目录。\n- `public boolean mkdirs()` ：创建由此File表示的目录，包括任何必需但不存在的父目录。\n\n方法演示，代码如下：\n\n```java\npublic class FileCreateDelete {\n    public static void main(String[] args) throws IOException {\n        // 文件的创建\n        File f = new File(\"aaa.txt\");\n        System.out.println(\"是否存在:\"+f.exists()); // false\n        System.out.println(\"是否创建:\"+f.createNewFile()); // true\n        System.out.println(\"是否存在:\"+f.exists()); // true\n		\n     	// 目录的创建\n      	File f2= new File(\"newDir\");	\n        System.out.println(\"是否存在:\"+f2.exists());// false\n        System.out.println(\"是否创建:\"+f2.mkdir());	// true\n        System.out.println(\"是否存在:\"+f2.exists());// true\n\n		// 创建多级目录\n      	File f3= new File(\"newDira\\\\newDirb\");\n        System.out.println(f3.mkdir());// false\n        File f4= new File(\"newDira\\\\newDirb\");\n        System.out.println(f4.mkdirs());// true\n      \n      	// 文件的删除\n       	System.out.println(f.delete());// true\n      \n      	// 目录的删除\n        System.out.println(f2.delete());// true\n        System.out.println(f4.delete());// false\n    }\n}\n```\n\n> API中说明：delete方法，如果此File表示目录，则目录必须为空才能删除。\n\n## 1.4 目录的遍历\n\n* `public String[] list()` ：返回一个String数组，表示该File目录中的所有子文件或目录。\n\n\n* `public File[] listFiles()` ：返回一个File数组，表示该File目录中的所有的子文件或目录。  \n\n```java\npublic class FileFor {\n    public static void main(String[] args) {\n        File dir = new File(\"d:\\\\java_code\");\n      \n      	//获取当前目录下的文件以及文件夹的名称。\n		String[] names = dir.list();\n		for(String name : names){\n			System.out.println(name);\n		}\n        //获取当前目录下的文件以及文件夹对象，只要拿到了文件对象，那么就可以获取更多信息\n        File[] files = dir.listFiles();\n        for (File file : files) {\n            System.out.println(file);\n        }\n    }\n}\n```\n\n> 小贴士：\n>\n> 调用listFiles方法的File对象，表示的必须是实际存在的目录，否则返回null，无法进行遍历。\n\n# 第二章 递归\n\n## 2.1 概述\n\n* **递归**：指在当前方法内调用自己的这种现象。\n\n* **递归的分类:**\n  - 递归分为两种，直接递归和间接递归。\n  - 直接递归称为方法自身调用自己。\n  - 间接递归可以A方法调用B方法，B方法调用C方法，C方法调用A方法。\n\n* **注意事项**：\n  - 递归一定要有条件限定，保证递归能够停止下来，否则会发生栈内存溢出。\n  - 在递归中虽然有限定条件，但是递归次数不能太多。否则也会发生栈内存溢出。\n  - 构造方法,禁止递归\n\n```java\npublic class Demo01DiGui {\n	public static void main(String[] args) {\n		// a();\n		b(1);\n	}\n	\n	/*\n	 * 3.构造方法,禁止递归\n	 * 编译报错:构造方法是创建对象使用的,不能让对象一直创建下去\n	 */\n	public Demo01DiGui() {\n		//Demo01DiGui();\n	}\n\n\n	/*\n	 * 2.在递归中虽然有限定条件，但是递归次数不能太多。否则也会发生栈内存溢出。\n	 * 4993\n	 * 	Exception in thread \"main\" java.lang.StackOverflowError\n	 */\n	private static void b(int i) {\n		System.out.println(i);\n		//添加一个递归结束的条件,i==5000的时候结束\n		if(i==5000){\n			return;//结束方法\n		}\n		b(++i);\n	}\n\n	/*\n	 * 1.递归一定要有条件限定，保证递归能够停止下来，否则会发生栈内存溢出。 Exception in thread \"main\"\n	 * java.lang.StackOverflowError\n	 */\n	private static void a() {\n		System.out.println(\"a方法\");\n		a();\n	}\n}\n```\n\n## 2.2 递归累加求和  \n\n### 计算1 ~ n的和\n\n**分析**：num的累和 = num + (num-1)的累和，所以可以把累和的操作定义成一个方法，递归调用。\n\n**实现代码**：\n\n```java\npublic class DiGuiDemo {\n	public static void main(String[] args) {\n		//计算1~num的和，使用递归完成\n		int num = 5;\n      	// 调用求和的方法\n		int sum = getSum(num);\n      	// 输出结果\n		System.out.println(sum);\n		\n	}\n  	/*\n  	  通过递归算法实现.\n  	  参数列表:int \n  	  返回值类型: int \n  	*/\n	public static int getSum(int num) {\n      	/* \n      	   num为1时,方法返回1,\n      	   相当于是方法的出口,num总有是1的情况\n      	*/\n		if(num == 1){\n			return 1;\n		}\n      	/*\n          num不为1时,方法返回 num +(num-1)的累和\n          递归调用getSum方法\n        */\n		return num + getSum(num-1);\n	}\n}\n```\n\n### 代码执行图解\n\n![](img/day08_01_递归累和.jpg)\n\n> 小贴士：递归一定要有条件限定，保证递归能够停止下来，次数不要太多，否则会发生栈内存溢出。\n\n## 2.3 递归求阶乘\n\n* **阶乘**：所有小于及等于该数的正整数的积。\n\n```java\nn的阶乘：n! = n * (n-1) *...* 3 * 2 * 1 \n```\n\n**分析**：这与累和类似,只不过换成了乘法运算，学员可以自己练习，需要注意阶乘值符合int类型的范围。\n\n```\n推理得出：n! = n * (n-1)!\n```\n\n**代码实现**：\n\n```java\npublic class DiGuiDemo {\n  	//计算n的阶乘，使用递归完成\n    public static void main(String[] args) {\n        int n = 3;\n      	// 调用求阶乘的方法\n        int value = getValue(n);\n      	// 输出结果\n        System.out.println(\"阶乘为:\"+ value);\n    }\n	/*\n  	  通过递归算法实现.\n  	  参数列表:int \n  	  返回值类型: int \n  	*/\n    public static int getValue(int n) {\n      	// 1的阶乘为1\n        if (n == 1) {\n            return 1;\n        }\n      	/*\n      	  n不为1时,方法返回 n! = n*(n-1)!\n          递归调用getValue方法\n      	*/\n        return n * getValue(n - 1);\n    }\n}\n```\n\n## 2.4 递归打印多级目录\n\n**分析**：多级目录的打印，就是当目录的嵌套。遍历之前，无从知道到底有多少级目录，所以我们还是要使用递归实现。\n\n**代码实现**：\n\n```java  \npublic class DiGuiDemo2 {\n    public static void main(String[] args) {\n      	// 创建File对象\n        File dir  = new File(\"D:\\\\aaa\");\n      	// 调用打印目录方法\n        printDir(dir);\n    }\n\n    public static void  printDir(File dir) {\n      	// 获取子文件和目录\n        File[] files = dir.listFiles();\n      	// 循环打印\n      	/*\n      	  判断:\n      	  当是文件时,打印绝对路径.\n      	  当是目录时,继续调用打印目录的方法,形成递归调用.\n      	*/\n        for (File file : files) {\n    		// 判断\n            if (file.isFile()) {\n              	// 是文件,输出文件绝对路径\n                System.out.println(\"文件名:\"+ file.getAbsolutePath());\n            } else {\n              	// 是目录,输出目录绝对路径\n                System.out.println(\"目录:\"+file.getAbsolutePath());\n              	// 继续遍历,调用printDir,形成递归\n                printDir(file);\n            }\n        }\n    }\n}\n```\n\n# 第三章 综合案例	\n\n## 3.1 文件搜索	\n\n搜索`D:\\aaa` 目录中的`.java` 文件。\n\n**分析**：\n\n1. 目录搜索，无法判断多少级目录，所以使用递归，遍历所有目录。\n2. 遍历目录时，获取的子文件，通过文件名称，判断是否符合条件。\n\n**代码实现**：\n\n```java\npublic class DiGuiDemo3 {\n    public static void main(String[] args) {\n        // 创建File对象\n        File dir  = new File(\"D:\\\\aaa\");\n      	// 调用打印目录方法\n        printDir(dir);\n    }\n\n    public static void printDir(File dir) {\n      	// 获取子文件和目录\n        File[] files = dir.listFiles();\n      	\n      	// 循环打印\n        for (File file : files) {\n            if (file.isFile()) {\n              	// 是文件，判断文件名并输出文件绝对路径\n                if (file.getName().endsWith(\".java\")) {\n                    System.out.println(\"文件名:\" + file.getAbsolutePath());\n                }\n            } else {\n                // 是目录，继续遍历,形成递归\n                printDir(file);\n            }\n        }\n    }\n}\n```\n\n## 3.2 文件过滤器优化\n\n`java.io.FileFilter`是一个接口，是File的过滤器。 该接口的对象可以传递给File类的`listFiles(FileFilter)` 作为参数， 接口中只有一个方法。\n\n`boolean accept(File pathname)  ` ：测试pathname是否应该包含在当前File目录中，符合则返回true。\n\n**分析**：\n\n1. 接口作为参数，需要传递子类对象，重写其中方法。我们选择匿名内部类方式，比较简单。\n2. `accept`方法，参数为File，表示当前File下所有的子文件和子目录。保留住则返回true，过滤掉则返回false。保留规则：\n   1. 要么是.java文件。\n   2. 要么是目录，用于继续遍历。\n3. 通过过滤器的作用，`listFiles(FileFilter)`返回的数组元素中，子文件对象都是符合条件的，可以直接打印。\n\n**代码实现：**\n\n```java\npublic class DiGuiDemo4 {\n    public static void main(String[] args) {\n        File dir = new File(\"D:\\\\aaa\");\n        printDir2(dir);\n    }\n  \n    public static void printDir2(File dir) {\n      	// 匿名内部类方式,创建过滤器子类对象\n        File[] files = dir.listFiles(new FileFilter() {\n            @Override\n            public boolean accept(File pathname) {\n                return pathname.getName().endsWith(\".java\")||pathname.isDirectory();\n            }\n        });\n      	// 循环打印\n        for (File file : files) {\n            if (file.isFile()) {\n                System.out.println(\"文件名:\" + file.getAbsolutePath());\n            } else {\n                printDir2(file);\n            }\n        }\n    }\n}      \n```\n\n\n\n## 3.3 Lambda优化\n\n**分析：**`FileFilter`是只有一个方法的接口，因此可以用lambda表达式简写。\n\nlambda格式：\n\n```java\n()->{ }\n```\n\n**代码实现：**\n\n```java\npublic static void printDir3(File dir) {\n  	// lambda的改写\n    File[] files = dir.listFiles(f ->{ \n      	return f.getName().endsWith(\".java\") || f.isDirectory(); \n    });\n  	\n	// 循环打印\n    for (File file : files) {\n        if (file.isFile()) {\n            System.out.println(\"文件名:\" + file.getAbsolutePath());\n      	} else {\n        	printDir3(file);\n      	}\n    }\n}\n```',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2020-01-19 17:41:29','2020-11-29 11:45:12',0),(99,'Object类、常用API','# 【Object类、常用API】\n\n## 主要内容\n\n* Object类\n* Date类\n* DateFormat类\n* Calendar类\n* System类\n* StringBuilder类\n* 包装类\n\n## 教学目标\n\n- [ ] 能够说出Object类的特点\n- [ ] 能够重写Object类的toString方法\n- [ ] 能够重写Object类的equals方法\n- [ ] 能够使用日期类输出当前日期\n- [ ] 能够使用将日期格式化为字符串的方法\n- [ ] 能够使用将字符串转换成日期的方法\n- [ ] 能够使用System类的数组复制方法\n- [ ] 能够使用System类获取当前毫秒时刻值\n- [ ] 能够说出使用StringBuilder类可以解决的问题\n- [ ] 能够使用StringBuilder进行字符串拼接操作\n- [ ] 能够说出8种基本类型对应的包装类名称\n- [ ] 能够说出自动装箱、自动拆箱的概念\n- [ ] 能够将字符串转换为对应的基本类型\n- [ ] 能够将基本类型转换为对应的字符串\n\n# 第一章 Object类\n\n## 1.1 概述\n\n`java.lang.Object`类是Java语言中的根类，即所有类的父类。它中描述的所有方法子类都可以使用。在对象实例化的时候，最终找的父类就是Object。\n\n如果一个类没有特别指定父类，	那么默认则继承自Object类。例如：\n\n```java\npublic class MyClass /*extends Object*/ {\n  	// ...\n}\n```\n\n根据JDK源代码及Object类的API文档，Object类当中包含的方法有11个。今天我们主要学习其中的2个：\n\n* `public String toString()`：返回该对象的字符串表示。\n* `public boolean equals(Object obj)`：指示其他某个对象是否与此对象“相等”。\n\n## 1.2 toString方法\n\n### 方法摘要\n\n* `public String toString()`：返回该对象的字符串表示。\n\ntoString方法返回该对象的字符串表示，其实该字符串内容就是对象的类型+@+内存地址值。\n\n由于toString方法返回的结果是内存地址，而在开发中，经常需要按照对象的属性得到相应的字符串表现形式，因此也需要重写它。\n\n### 覆盖重写\n\n如果不希望使用toString方法的默认行为，则可以对它进行覆盖重写。例如自定义的Person类：\n\n```java\npublic class Person {  \n    private String name;\n    private int age;\n\n    @Override\n    public String toString() {\n        return \"Person{\" + \"name=\'\" + name + \'\\\'\' + \", age=\" + age + \'}\';\n    }\n\n    // 省略构造器与Getter Setter\n}\n```\n\n在IntelliJ IDEA中，可以点击`Code`菜单中的`Generate...`，也可以使用快捷键`alt+insert`，点击`toString()`选项。选择需要包含的成员变量并确定。如下图所示：\n\n![toString方法的自动重写](img\\toString方法的自动重写.bmp)\n\n> 小贴士： 在我们直接使用输出语句输出对象名的时候,其实通过该对象调用了其toString()方法。\n>\n\n## 1.3 equals方法\n\n### 方法摘要\n\n* `public boolean equals(Object obj)`：指示其他某个对象是否与此对象“相等”。\n\n调用成员方法equals并指定参数为另一个对象，则可以判断这两个对象是否是相同的。这里的“相同”有默认和自定义两种方式。\n\n### 默认地址比较\n\n如果没有覆盖重写equals方法，那么Object类中默认进行`==`运算符的对象地址比较，只要不是同一个对象，结果必然为false。\n\n### 对象内容比较\n\n如果希望进行对象的内容比较，即所有或指定的部分成员变量相同就判定两个对象相同，则可以覆盖重写equals方法。例如：\n\n```java\nimport java.util.Objects;\n\npublic class Person {	\n	private String name;\n	private int age;\n	\n    @Override\n    public boolean equals(Object o) {\n        // 如果对象地址一样，则认为相同\n        if (this == o)\n            return true;\n        // 如果参数为空，或者类型信息不一样，则认为不同\n        if (o == null || getClass() != o.getClass())\n            return false;\n        // 转换为当前类型\n        Person person = (Person) o;\n        // 要求基本类型相等，并且将引用类型交给java.util.Objects类的equals静态方法取用结果\n        return age == person.age && Objects.equals(name, person.name);\n    }\n}\n```\n\n这段代码充分考虑了对象为空、类型一致等问题，但方法内容并不唯一。大多数IDE都可以自动生成equals方法的代码内容。在IntelliJ IDEA中，可以使用`Code`菜单中的`Generate…`选项，也可以使用快捷键`alt+insert`，并选择`equals() and hashCode()`进行自动代码生成。如下图所示：\n\n![](img\\equals方法1.png)\n\n![](img\\equals方法2.png)\n\n![](img\\equals方法3.png)\n\n> tips：Object类当中的hashCode等其他方法，今后学习。\n\n## 1.4 Objects类\n\n在刚才IDEA自动重写equals代码中，使用到了`java.util.Objects`类，那么这个类是什么呢？\n\n在**JDK7**添加了一个Objects工具类，它提供了一些方法来操作对象，它由一些静态的实用方法组成，这些方法是null-save（空指针安全的）或null-tolerant（容忍空指针的），用于计算对象的hashcode、返回对象的字符串表示形式、比较两个对象。\n\n在比较两个对象的时候，Object的equals方法容易抛出空指针异常，而Objects类中的equals方法就优化了这个问题。方法如下：\n\n* `public static boolean equals(Object a, Object b)`:判断两个对象是否相等。\n\n我们可以查看一下源码，学习一下：\n\n~~~java\npublic static boolean equals(Object a, Object b) {  \n    return (a == b) || (a != null && a.equals(b));  \n}\n~~~\n\n# 第二章 日期时间类\n\n## 2.1 Date类\n\n### 概述\n\n` java.util.Date`类 表示特定的瞬间，精确到毫秒。\n\n继续查阅Date类的描述，发现Date拥有多个构造函数，只是部分已经过时，但是其中有未过时的构造函数可以把毫秒值转成日期对象。\n\n- `public Date()`：分配Date对象并初始化此对象，以表示分配它的时间（精确到毫秒）。\n- `public Date(long date)`：分配Date对象并初始化此对象，以表示自从标准基准时间（称为“历元（epoch）”，即1970年1月1日00:00:00 GMT）以来的指定毫秒数。\n\n> tips: 由于我们处于东八区，所以我们的基准时间为1970年1月1日8时0分0秒。\n\n简单来说：使用无参构造，可以自动设置当前系统时间的毫秒时刻；指定long类型的构造参数，可以自定义毫秒时刻。例如：\n\n```java\nimport java.util.Date;\n\npublic class Demo01Date {\n    public static void main(String[] args) {\n        // 创建日期对象，把当前的时间\n        System.out.println(new Date()); // Tue Jan 16 14:37:35 CST 2018\n        // 创建日期对象，把当前的毫秒值转成日期对象\n        System.out.println(new Date(0L)); // Thu Jan 01 08:00:00 CST 1970\n    }\n}\n```\n\n> tips:在使用println方法时，会自动调用Date类中的toString方法。Date类对Object类中的toString方法进行了覆盖重写，所以结果为指定格式的字符串。\n>\n\n### 常用方法\n\nDate类中的多数方法已经过时，常用的方法有：\n\n* `public long getTime()` 把日期对象转换成对应的时间毫秒值。\n\n## 2.2 DateFormat类\n\n`java.text.DateFormat` 是日期/时间格式化子类的抽象类，我们通过这个类可以帮我们完成日期和文本之间的转换,也就是可以在Date对象与String对象之间进行来回转换。\n\n* **格式化**：按照指定的格式，从Date对象转换为String对象。\n* **解析**：按照指定的格式，从String对象转换为Date对象。\n\n### 构造方法\n\n由于DateFormat为抽象类，不能直接使用，所以需要常用的子类`java.text.SimpleDateFormat`。这个类需要一个模式（格式）来指定格式化或解析的标准。构造方法为：\n\n* `public SimpleDateFormat(String pattern)`：用给定的模式和默认语言环境的日期格式符号构造SimpleDateFormat。\n\n参数pattern是一个字符串，代表日期时间的自定义格式。\n\n### 格式规则\n\n常用的格式规则为：\n\n| 标识字母（区分大小写） | 含义   |\n| ----------- | ---- |\n| y           | 年    |\n| M           | 月    |\n| d           | 日    |\n| H           | 时    |\n| m           | 分    |\n| s           | 秒    |\n\n> 备注：更详细的格式规则，可以参考SimpleDateFormat类的API文档0。\n\n创建SimpleDateFormat对象的代码如：\n\n```java\nimport java.text.DateFormat;\nimport java.text.SimpleDateFormat;\n\npublic class Demo02SimpleDateFormat {\n    public static void main(String[] args) {\n        // 对应的日期格式如：2018-01-16 15:06:38\n        DateFormat format = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n    }    \n}\n```\n\n### 常用方法\n\nDateFormat类的常用方法有：\n\n- `public String format(Date date)`：将Date对象格式化为字符串。\n- `public Date parse(String source)`：将字符串解析为Date对象。\n\n#### format方法\n\n使用format方法的代码为：\n\n```java\nimport java.text.DateFormat;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n/*\n 把Date对象转换成String\n*/\npublic class Demo03DateFormatMethod {\n    public static void main(String[] args) {\n        Date date = new Date();\n        // 创建日期格式化对象,在获取格式化对象时可以指定风格\n        DateFormat df = new SimpleDateFormat(\"yyyy年MM月dd日\");\n        String str = df.format(date);\n        System.out.println(str); // 2008年1月23日\n    }\n}\n```\n\n#### parse方法\n\n使用parse方法的代码为：\n\n```java\nimport java.text.DateFormat;\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n/*\n 把String转换成Date对象\n*/\npublic class Demo04DateFormatMethod {\n    public static void main(String[] args) throws ParseException {\n        DateFormat df = new SimpleDateFormat(\"yyyy年MM月dd日\");\n        String str = \"2018年12月11日\";\n        Date date = df.parse(str);\n        System.out.println(date); // Tue Dec 11 00:00:00 CST 2018\n    }\n}\n```\n\n## 2.3 练习\n\n请使用日期时间相关的API，计算出一个人已经出生了多少天。\n\n**思路：**\n\n1.获取当前时间对应的毫秒值\n\n2.获取自己出生日期对应的毫秒值\n\n3.两个时间相减（当前时间– 出生日期）\n\n**代码实现：**\n\n```java\npublic static void function() throws Exception {\n	System.out.println(\"请输入出生日期 格式 YYYY-MM-dd\");\n	// 获取出生日期,键盘输入\n	String birthdayString = new Scanner(System.in).next();\n	// 将字符串日期,转成Date对象\n	// 创建SimpleDateFormat对象,写日期模式\n	SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd\");\n	// 调用方法parse,字符串转成日期对象\n	Date birthdayDate = sdf.parse(birthdayString);	\n	// 获取今天的日期对象\n	Date todayDate = new Date();	\n	// 将两个日期转成毫秒值,Date类的方法getTime\n	long birthdaySecond = birthdayDate.getTime();\n	long todaySecond = todayDate.getTime();\n	long secone = todaySecond-birthdaySecond;	\n	if (secone < 0){\n		System.out.println(\"还没出生呢\");\n	} else {\n		System.out.println(secone/1000/60/60/24);\n	}\n}\n```\n\n## 2.4 Calendar类\n\n###  概念\n\n日历我们都见过\n\n![](img\\日历.jpg)\n\n`java.util.Calendar`是日历类，在Date后出现，替换掉了许多Date的方法。该类将所有可能用到的时间信息封装为静态成员变量，方便获取。日历类就是方便获取各个时间属性的。\n\n### 获取方式\n\nCalendar为抽象类，由于语言敏感性，Calendar类在创建对象时并非直接创建，而是通过静态方法创建，返回子类对象，如下：\n\nCalendar静态方法\n\n* `public static Calendar getInstance()`：使用默认时区和语言环境获得一个日历\n\n例如：\n\n```java\nimport java.util.Calendar;\n\npublic class Demo06CalendarInit {\n    public static void main(String[] args) {\n        Calendar cal = Calendar.getInstance();\n    }    \n}\n```\n\n### 常用方法\n\n根据Calendar类的API文档，常用方法有：\n\n- `public int get(int field)`：返回给定日历字段的值。\n- `public void set(int field, int value)`：将给定的日历字段设置为给定值。\n- `public abstract void add(int field, int amount)`：根据日历的规则，为给定的日历字段添加或减去指定的时间量。\n- `public Date getTime()`：返回一个表示此Calendar时间值（从历元到现在的毫秒偏移量）的Date对象。\n\nCalendar类中提供很多成员常量，代表给定的日历字段：\n\n| 字段值          | 含义                   |\n| ------------ | -------------------- |\n| YEAR         | 年                    |\n| MONTH        | 月（从0开始，可以+1使用）       |\n| DAY_OF_MONTH | 月中的天（几号）             |\n| HOUR         | 时（12小时制）             |\n| HOUR_OF_DAY  | 时（24小时制）             |\n| MINUTE       | 分                    |\n| SECOND       | 秒                    |\n| DAY_OF_WEEK  | 周中的天（周几，周日为1，可以-1使用） |\n\n#### get/set方法\n\nget方法用来获取指定字段的值，set方法用来设置指定字段的值，代码使用演示：\n\n```java\nimport java.util.Calendar;\n\npublic class CalendarUtil {\n    public static void main(String[] args) {\n        // 创建Calendar对象\n        Calendar cal = Calendar.getInstance();\n        // 设置年 \n        int year = cal.get(Calendar.YEAR);\n        // 设置月\n        int month = cal.get(Calendar.MONTH) + 1;\n        // 设置日\n        int dayOfMonth = cal.get(Calendar.DAY_OF_MONTH);\n        System.out.print(year + \"年\" + month + \"月\" + dayOfMonth + \"日\");\n    }    \n}\n```\n\n```java\nimport java.util.Calendar;\n\npublic class Demo07CalendarMethod {\n    public static void main(String[] args) {\n        Calendar cal = Calendar.getInstance();\n        cal.set(Calendar.YEAR, 2020);\n        System.out.print(year + \"年\" + month + \"月\" + dayOfMonth + \"日\"); // 2020年1月17日\n    }\n}\n```\n\n#### add方法\n\nadd方法可以对指定日历字段的值进行加减操作，如果第二个参数为正数则加上偏移量，如果为负数则减去偏移量。代码如：\n\n```java\nimport java.util.Calendar;\n\npublic class Demo08CalendarMethod {\n    public static void main(String[] args) {\n        Calendar cal = Calendar.getInstance();\n        System.out.print(year + \"年\" + month + \"月\" + dayOfMonth + \"日\"); // 2018年1月17日\n        // 使用add方法\n        cal.add(Calendar.DAY_OF_MONTH, 2); // 加2天\n        cal.add(Calendar.YEAR, -3); // 减3年\n        System.out.print(year + \"年\" + month + \"月\" + dayOfMonth + \"日\"); // 2015年1月18日; \n    }\n}\n```\n\n#### getTime方法\n\nCalendar中的getTime方法并不是获取毫秒时刻，而是拿到对应的Date对象。\n\n```java\nimport java.util.Calendar;\nimport java.util.Date;\n\npublic class Demo09CalendarMethod {\n    public static void main(String[] args) {\n        Calendar cal = Calendar.getInstance();\n        Date date = cal.getTime();\n        System.out.println(date); // Tue Jan 16 16:03:09 CST 2018\n    }\n}\n```\n\n> 小贴士：\n>\n> ​     西方星期的开始为周日，中国为周一。\n>\n> ​     在Calendar类中，月份的表示是以0-11代表1-12月。\n>\n> ​     日期是有大小关系的，时间靠后，时间越大。\n>\n\n# 第三章 System类\n\n`java.lang.System`类中提供了大量的静态方法，可以获取与系统相关的信息或系统级操作，在System类的API文档中，常用的方法有：\n\n- `public static long currentTimeMillis()`：返回以毫秒为单位的当前时间。\n- `public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)`：将数组中指定的数据拷贝到另一个数组中。\n\n## 3.1 currentTimeMillis方法\n\n实际上，currentTimeMillis方法就是 获取当前系统时间与1970年01月01日00:00点之间的毫秒差值\n\n```java\nimport java.util.Date;\n\npublic class SystemDemo {\n    public static void main(String[] args) {\n       	//获取当前时间毫秒值\n        System.out.println(System.currentTimeMillis()); // 1516090531144\n    }\n}\n```\n\n### 练习\n\n验证for循环打印数字1-9999所需要使用的时间（毫秒）\n\n~~~java\npublic class SystemTest1 {\n    public static void main(String[] args) {\n        long start = System.currentTimeMillis();\n        for (int i = 0; i < 10000; i++) {\n            System.out.println(i);\n        }\n        long end = System.currentTimeMillis();\n        System.out.println(\"共耗时毫秒：\" + (end - start));\n    }\n}\n~~~\n\n## 3.2 arraycopy方法\n\n* `public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)`：将数组中指定的数据拷贝到另一个数组中。\n\n数组的拷贝动作是系统级的，性能很高。System.arraycopy方法具有5个参数，含义分别为：\n\n| 参数序号 | 参数名称    | 参数类型   | 参数含义       |\n| ---- | ------- | ------ | ---------- |\n| 1    | src     | Object | 源数组        |\n| 2    | srcPos  | int    | 源数组索引起始位置  |\n| 3    | dest    | Object | 目标数组       |\n| 4    | destPos | int    | 目标数组索引起始位置 |\n| 5    | length  | int    | 复制元素个数     |\n\n### 练习\n\n将src数组中前3个元素，复制到dest数组的前3个位置上复制元素前：src数组元素[1,2,3,4,5]，dest数组元素[6,7,8,9,10]复制元素后：src数组元素[1,2,3,4,5]，dest数组元素[1,2,3,9,10]\n\n```java\nimport java.util.Arrays;\n\npublic class Demo11SystemArrayCopy {\n    public static void main(String[] args) {\n        int[] src = new int[]{1,2,3,4,5};\n        int[] dest = new int[]{6,7,8,9,10};\n        System.arraycopy( src, 0, dest, 0, 3);\n        /*代码运行后：两个数组中的元素发生了变化\n         src数组元素[1,2,3,4,5]\n         dest数组元素[1,2,3,9,10]\n        */\n    }\n}\n```\n\n# 第四章 StringBuilder类\n\n## 4.1 字符串拼接问题\n\n由于String类的对象内容不可改变，所以每当进行字符串拼接时，总是会在内存中创建一个新的对象。例如：\n\n~~~java\npublic class StringDemo {\n    public static void main(String[] args) {\n        String s = \"Hello\";\n        s += \"World\";\n        System.out.println(s);\n    }\n}\n~~~\n\n在API中对String类有这样的描述：字符串是常量，它们的值在创建后不能被更改。\n\n根据这句话分析我们的代码，其实总共产生了三个字符串，即`\"Hello\"`、`\"World\"`和`\"HelloWorld\"`。引用变量s首先指向`Hello`对象，最终指向拼接出来的新字符串对象，即`HelloWord` 。\n\n![](img\\String拼接问题.bmp)\n\n由此可知，如果对字符串进行拼接操作，每次拼接，都会构建一个新的String对象，既耗时，又浪费空间。为了解决这一问题，可以使用`java.lang.StringBuilder`类。\n\n## 4.2 StringBuilder概述\n\n查阅`java.lang.StringBuilder`的API，StringBuilder又称为可变字符序列，它是一个类似于 String 的字符串缓冲区，通过某些方法调用可以改变该序列的长度和内容。\n\n原来StringBuilder是个字符串的缓冲区，即它是一个容器，容器中可以装很多字符串。并且能够对其中的字符串进行各种操作。\n\n它的内部拥有一个数组用来存放字符串内容，进行字符串拼接时，直接在数组中加入新内容。StringBuilder会自动维护数组的扩容。原理如下图所示：(默认16字符空间，超过自动扩充)\n\n![06-StringBuilder的原理](img\\06-StringBuilder的原理.png)\n\n## 4.3 构造方法\n\n根据StringBuilder的API文档，常用构造方法有2个：\n\n- `public StringBuilder()`：构造一个空的StringBuilder容器。\n- `public StringBuilder(String str)`：构造一个StringBuilder容器，并将字符串添加进去。\n\n```java\npublic class StringBuilderDemo {\n    public static void main(String[] args) {\n        StringBuilder sb1 = new StringBuilder();\n        System.out.println(sb1); // (空白)\n        // 使用带参构造\n        StringBuilder sb2 = new StringBuilder(\"itcast\");\n        System.out.println(sb2); // itcast\n    }\n}\n```\n\n## 4.4 常用方法\n\nStringBuilder常用的方法有2个：\n\n- `public StringBuilder append(...)`：添加任意类型数据的字符串形式，并返回当前对象自身。\n- `public String toString()`：将当前StringBuilder对象转换为String对象。\n\n### append方法\n\nappend方法具有多种重载形式，可以接收任意类型的参数。任何数据作为参数都会将对应的字符串内容添加到StringBuilder中。例如：\n\n```java\npublic class Demo02StringBuilder {\n	public static void main(String[] args) {\n		//创建对象\n		StringBuilder builder = new StringBuilder();\n		//public StringBuilder append(任意类型)\n		StringBuilder builder2 = builder.append(\"hello\");\n		//对比一下\n		System.out.println(\"builder:\"+builder);\n		System.out.println(\"builder2:\"+builder2);\n		System.out.println(builder == builder2); //true\n	    // 可以添加 任何类型\n		builder.append(\"hello\");\n		builder.append(\"world\");\n		builder.append(true);\n		builder.append(100);\n		// 在我们开发中，会遇到调用一个方法后，返回一个对象的情况。然后使用返回的对象继续调用方法。\n        // 这种时候，我们就可以把代码现在一起，如append方法一样，代码如下\n		//链式编程\n		builder.append(\"hello\").append(\"world\").append(true).append(100);\n		System.out.println(\"builder:\"+builder);\n	}\n}\n```\n\n> 备注：StringBuilder已经覆盖重写了Object当中的toString方法。\n\n### toString方法\n\n通过toString方法，StringBuilder对象将会转换为不可变的String对象。如：\n\n```java\npublic class Demo16StringBuilder {\n    public static void main(String[] args) {\n        // 链式创建\n        StringBuilder sb = new StringBuilder(\"Hello\").append(\"World\").append(\"Java\");\n        // 调用方法\n        String str = sb.toString();\n        System.out.println(str); // HelloWorldJava\n    }\n}\n```\n\n# 第五章 包装类\n\n## 5.1 概述\n\nJava提供了两个类型系统，基本类型与引用类型，使用基本类型在于效率，然而很多情况，会创建对象使用，因为对象可以做更多的功能，如果想要我们的基本类型像对象一样操作，就可以使用基本类型对应的包装类，如下：\n\n| 基本类型    | 对应的包装类（位于java.lang包中） |\n| ------- | --------------------- |\n| byte    | Byte                  |\n| short   | Short                 |\n| int     | **Integer**           |\n| long    | Long                  |\n| float   | Float                 |\n| double  | Double                |\n| char    | **Character**         |\n| boolean | Boolean               |\n\n## 5.2 装箱与拆箱\n\n基本类型与对应的包装类对象之间，来回转换的过程称为”装箱“与”拆箱“：\n\n* **装箱**：从基本类型转换为对应的包装类对象。\n\n* **拆箱**：从包装类对象转换为对应的基本类型。\n\n用Integer与 int为例：（看懂代码即可）\n\n基本数值---->包装对象\n\n~~~java\nInteger i = new Integer(4);//使用构造函数函数\nInteger iii = Integer.valueOf(4);//使用包装类中的valueOf方法\n~~~\n\n包装对象---->基本数值\n\n~~~java\nint num = i.intValue();\n~~~\n## 5.3自动装箱与自动拆箱\n\n由于我们经常要做基本类型与包装类之间的转换，从Java 5（JDK 1.5）开始，基本类型与包装类的装箱、拆箱动作可以自动完成。例如：\n\n```java\nInteger i = 4;//自动装箱。相当于Integer i = Integer.valueOf(4);\ni = i + 5;//等号右边：将i对象转成基本数值(自动拆箱) i.intValue() + 5;\n//加法运算完成后，再次装箱，把基本数值转成对象。\n```\n\n## 5.3 基本类型与字符串之间的转换\n\n### 基本类型转换为String\n\n   基本类型转换String总共有三种方式，查看课后资料可以得知，这里只讲最简单的一种方式： \n\n~~~\n基本类型直接与””相连接即可；如：34+\"\"\n~~~\n\nString转换成对应的基本类型 \n\n除了Character类之外，其他所有包装类都具有parseXxx静态方法可以将字符串参数转换为对应的基本类型：\n\n- `public static byte parseByte(String s)`：将字符串参数转换为对应的byte基本类型。\n- `public static short parseShort(String s)`：将字符串参数转换为对应的short基本类型。\n- `public static int parseInt(String s)`：将字符串参数转换为对应的int基本类型。\n- `public static long parseLong(String s)`：将字符串参数转换为对应的long基本类型。\n- `public static float parseFloat(String s)`：将字符串参数转换为对应的float基本类型。\n- `public static double parseDouble(String s)`：将字符串参数转换为对应的double基本类型。\n- `public static boolean parseBoolean(String s)`：将字符串参数转换为对应的boolean基本类型。\n\n代码使用（仅以Integer类的静态方法parseXxx为例）如：\n\n```java\npublic class Demo18WrapperParse {\n    public static void main(String[] args) {\n        int num = Integer.parseInt(\"100\");\n    }\n}\n```\n\n> 注意:如果字符串参数的内容无法正确转换为对应的基本类型，则会抛出`java.lang.NumberFormatException`异常。\n>',3,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2020-01-19 17:47:49','2020-11-29 11:45:12',0),(100,'字节流、字符流','# 【字节流、字符流】\n\n## 主要内容\n\n* IO流\n* 字节流\n* 字符流\n* 异常处理\n* Properties\n\n## 教学目标\n- [ ] 能够说出IO流的分类和功能\n- [ ] 能够使用字节输出流写出数据到文件\n- [ ] 能够使用字节输入流读取数据到程序\n- [ ] 能够理解读取数据read(byte[])方法的原理\n- [ ] 能够使用字节流完成文件的复制\n- [ ] 能够使用FileWirter写数据到文件\n- [ ] 能够说出FileWriter中关闭和刷新方法的区别\n- [ ] 能够使用FileWriter写数据的5个方法\n- [ ] 能够使用FileWriter写数据实现换行和追加写\n- [ ] 能够使用FileReader读数据\n- [ ] 能够使用FileReader读数据一次一个字符数组\n- [ ] 能够使用Properties的load方法加载文件中配置信息\n\n# 第一章 IO概述\n\n## 1.1 什么是IO\n\n生活中，你肯定经历过这样的场景。当你编辑一个文本文件，忘记了`ctrl+s` ，可能文件就白白编辑了。当你电脑上插入一个U盘，可以把一个视频，拷贝到你的电脑硬盘里。那么数据都是在哪些设备上的呢？键盘、内存、硬盘、外接设备等等。\n\n我们把这种数据的传输，可以看做是一种数据的流动，按照流动的方向，以内存为基准，分为`输入input` 和`输出output` ，即流向内存是输入流，流出内存的输出流。\n\nJava中I/O操作主要是指使用`java.io`包下的内容，进行输入、输出操作。**输入**也叫做**读取**数据，**输出**也叫做作**写出**数据。\n\n## 1.2 IO的分类\n\n根据数据的流向分为：**输入流**和**输出流**。\n\n* **输入流** ：把数据从`其他设备`上读取到`内存`中的流。 \n* **输出流** ：把数据从`内存` 中写出到`其他设备`上的流。\n\n格局数据的类型分为：**字节流**和**字符流**。\n\n* **字节流** ：以字节为单位，读写数据的流。\n* **字符流** ：以字符为单位，读写数据的流。\n\n## 1.3 IO的流向说明图解\n\n![](img/1_io.jpg)\n\n## 1.4 顶级父类们\n\n|         |          **输入流**           |             输出流             |\n| :-----: | :------------------------: | :-------------------------: |\n| **字节流** | 字节输入流<br />**InputStream** | 字节输出流<br />**OutputStream** |\n| **字符流** |   字符输入流<br />**Reader**    |    字符输出流<br />**Writer**    |\n\n# 第二章 字节流\n\n## 2.1 一切皆为字节\n\n一切文件数据(文本、图片、视频等)在存储时，都是以二进制数字的形式保存，都一个一个的字节，那么传输时一样如此。所以，字节流可以传输任意文件数据。在操作流的时候，我们要时刻明确，无论使用什么样的流对象，底层传输的始终为二进制数据。\n\n## 2.2 字节输出流【OutputStream】\n\n`java.io.OutputStream `抽象类是表示字节输出流的所有类的超类，将指定的字节信息写出到目的地。它定义了字节输出流的基本共性功能方法。\n\n* `public void close()` ：关闭此输出流并释放与此流相关联的任何系统资源。  \n* `public void flush() ` ：刷新此输出流并强制任何缓冲的输出字节被写出。  \n* `public void write(byte[] b)`：将 b.length字节从指定的字节数组写入此输出流。  \n* `public void write(byte[] b, int off, int len)` ：从指定的字节数组写入 len字节，从偏移量 off开始输出到此输出流。  \n* `public abstract void write(int b)` ：将指定的字节输出流。\n\n> 小贴士：\n>\n> close方法，当完成流的操作时，必须调用此方法，释放系统资源。\n\n## 2.3 FileOutputStream类\n\n`OutputStream`有很多子类，我们从最简单的一个子类开始。\n\n`java.io.FileOutputStream `类是文件输出流，用于将数据写出到文件。\n\n### 构造方法\n\n* `public FileOutputStream(File file)`：创建文件输出流以写入由指定的 File对象表示的文件。 \n* `public FileOutputStream(String name)`： 创建文件输出流以指定的名称写入文件。  \n\n当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有这个文件，会创建该文件。如果有这个文件，会清空这个文件的数据。\n\n* 构造举例，代码如下：\n\n```java\npublic class FileOutputStreamConstructor throws IOException {\n    public static void main(String[] args) {\n   	 	// 使用File对象创建流对象\n        File file = new File(\"a.txt\");\n        FileOutputStream fos = new FileOutputStream(file);\n      \n        // 使用文件名称创建流对象\n        FileOutputStream fos = new FileOutputStream(\"b.txt\");\n    }\n}\n```\n\n### 写出字节数据\n\n1. **写出字节**：`write(int b)` 方法，每次可以写出一个字节数据，代码使用演示：\n\n```java\npublic class FOSWrite {\n    public static void main(String[] args) throws IOException {\n        // 使用文件名称创建流对象\n        FileOutputStream fos = new FileOutputStream(\"fos.txt\");     \n      	// 写出数据\n      	fos.write(97); // 写出第1个字节\n      	fos.write(98); // 写出第2个字节\n      	fos.write(99); // 写出第3个字节\n      	// 关闭资源\n        fos.close();\n    }\n}\n输出结果：\nabc\n```\n\n> 小贴士：\n>\n> 1. 虽然参数为int类型四个字节，但是只会保留一个字节的信息写出。\n> 2. 流操作完毕后，必须释放系统资源，调用close方法，千万记得。\n\n2. **写出字节数组**：`write(byte[] b)`，每次可以写出数组中的数据，代码使用演示：\n\n```java\npublic class FOSWrite {\n    public static void main(String[] args) throws IOException {\n        // 使用文件名称创建流对象\n        FileOutputStream fos = new FileOutputStream(\"fos.txt\");     \n      	// 字符串转换为字节数组\n      	byte[] b = \"黑马程序员\".getBytes();\n      	// 写出字节数组数据\n      	fos.write(b);\n      	// 关闭资源\n        fos.close();\n    }\n}\n输出结果：\n黑马程序员\n```\n\n3. **写出指定长度字节数组**：`write(byte[] b, int off, int len)` ,每次写出从off索引开始，len个字节，代码使用演示：\n\n```java\npublic class FOSWrite {\n    public static void main(String[] args) throws IOException {\n        // 使用文件名称创建流对象\n        FileOutputStream fos = new FileOutputStream(\"fos.txt\");     \n      	// 字符串转换为字节数组\n      	byte[] b = \"abcde\".getBytes();\n		// 写出从索引2开始，2个字节。索引2是c，两个字节，也就是cd。\n        fos.write(b,2,2);\n      	// 关闭资源\n        fos.close();\n    }\n}\n输出结果：\ncd\n```\n\n### 数据追加续写\n\n经过以上的演示，每次程序运行，创建输出流对象，都会清空目标文件中的数据。如何保留目标文件中数据，还能继续添加新数据呢？\n\n- `public FileOutputStream(File file, boolean append)`： 创建文件输出流以写入由指定的 File对象表示的文件。  \n- `public FileOutputStream(String name, boolean append)`： 创建文件输出流以指定的名称写入文件。  \n\n这两个构造方法，参数中都需要传入一个boolean类型的值，`true` 表示追加数据，`false` 表示清空原有数据。这样创建的输出流对象，就可以指定是否追加续写了，代码使用演示：\n\n```java\npublic class FOSWrite {\n    public static void main(String[] args) throws IOException {\n        // 使用文件名称创建流对象\n        FileOutputStream fos = new FileOutputStream(\"fos.txt\"，true);     \n      	// 字符串转换为字节数组\n      	byte[] b = \"abcde\".getBytes();\n		// 写出从索引2开始，2个字节。索引2是c，两个字节，也就是cd。\n        fos.write(b);\n      	// 关闭资源\n        fos.close();\n    }\n}\n文件操作前：cd\n文件操作后：cdabcde\n```\n\n### 写出换行\n\nWindows系统里，换行符号是`\\r\\n` 。把\n\n以指定是否追加续写了，代码使用演示：\n\n```java\npublic class FOSWrite {\n    public static void main(String[] args) throws IOException {\n        // 使用文件名称创建流对象\n        FileOutputStream fos = new FileOutputStream(\"fos.txt\");  \n      	// 定义字节数组\n      	byte[] words = {97,98,99,100,101};\n      	// 遍历数组\n        for (int i = 0; i < words.length; i++) {\n          	// 写出一个字节\n            fos.write(words[i]);\n          	// 写出一个换行, 换行符号转成数组写出\n            fos.write(\"\\r\\n\".getBytes());\n        }\n      	// 关闭资源\n        fos.close();\n    }\n}\n\n输出结果：\na\nb\nc\nd\ne\n```\n\n> * 回车符`\\r`和换行符`\\n` ：\n>   * 回车符：回到一行的开头（return）。\n>   * 换行符：下一行（newline）。\n> * 系统中的换行：\n>   * Windows系统里，每行结尾是 `回车+换行` ，即`\\r\\n`；\n>   * Unix系统里，每行结尾只有 `换行` ，即`\\n`；\n>   * Mac系统里，每行结尾是 `回车` ，即`\\r`。从 Mac OS X开始与Linux统一。\n\n## 2.4 字节输入流【InputStream】\n\n`java.io.InputStream `抽象类是表示字节输入流的所有类的超类，可以读取字节信息到内存中。它定义了字节输入流的基本共性功能方法。\n\n- `public void close()` ：关闭此输入流并释放与此流相关联的任何系统资源。    \n- `public abstract int read()`： 从输入流读取数据的下一个字节。 \n- `public int read(byte[] b)`： 从输入流中读取一些字节数，并将它们存储到字节数组 b中 。\n\n> 小贴士：\n>\n> close方法，当完成流的操作时，必须调用此方法，释放系统资源。\n\n## 2.5 FileInputStream类\n\n`java.io.FileInputStream `类是文件输入流，从文件中读取字节。\n\n### 构造方法\n\n* `FileInputStream(File file)`： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的 File对象 file命名。 \n* `FileInputStream(String name)`： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的路径名 name命名。  \n\n当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有该文件,会抛出`FileNotFoundException` 。\n\n- 构造举例，代码如下：\n\n```java\npublic class FileInputStreamConstructor throws IOException{\n    public static void main(String[] args) {\n   	 	// 使用File对象创建流对象\n        File file = new File(\"a.txt\");\n        FileInputStream fos = new FileInputStream(file);\n      \n        // 使用文件名称创建流对象\n        FileInputStream fos = new FileInputStream(\"b.txt\");\n    }\n}\n```\n\n### 读取字节数据\n\n1. **读取字节**：`read`方法，每次可以读取一个字节的数据，提升为int类型，读取到文件末尾，返回`-1`，代码使用演示：\n\n```java\npublic class FISRead {\n    public static void main(String[] args) throws IOException{\n      	// 使用文件名称创建流对象\n       	FileInputStream fis = new FileInputStream(\"read.txt\");\n      	// 读取数据，返回一个字节\n        int read = fis.read();\n        System.out.println((char) read);\n        read = fis.read();\n        System.out.println((char) read);\n        read = fis.read();\n        System.out.println((char) read);\n        read = fis.read();\n        System.out.println((char) read);\n        read = fis.read();\n        System.out.println((char) read);\n      	// 读取到末尾,返回-1\n       	read = fis.read();\n        System.out.println( read);\n		// 关闭资源\n        fis.close();\n    }\n}\n输出结果：\na\nb\nc\nd\ne\n-1\n```\n\n循环改进读取方式，代码使用演示：\n\n```java\npublic class FISRead {\n    public static void main(String[] args) throws IOException{\n      	// 使用文件名称创建流对象\n       	FileInputStream fis = new FileInputStream(\"read.txt\");\n      	// 定义变量，保存数据\n        int b ；\n        // 循环读取\n        while ((b = fis.read())!=-1) {\n            System.out.println((char)b);\n        }\n		// 关闭资源\n        fis.close();\n    }\n}\n输出结果：\na\nb\nc\nd\ne\n```\n\n> 小贴士：\n>\n> 1. 虽然读取了一个字节，但是会自动提升为int类型。\n> 2. 流操作完毕后，必须释放系统资源，调用close方法，千万记得。\n\n2. **使用字节数组读取**：`read(byte[] b)`，每次读取b的长度个字节到数组中，返回读取到的有效字节个数，读取到末尾时，返回`-1` ，代码使用演示：\n\n```java\npublic class FISRead {\n    public static void main(String[] args) throws IOException{\n      	// 使用文件名称创建流对象.\n       	FileInputStream fis = new FileInputStream(\"read.txt\"); // 文件中为abcde\n      	// 定义变量，作为有效个数\n        int len ；\n        // 定义字节数组，作为装字节数据的容器   \n        byte[] b = new byte[2];\n        // 循环读取\n        while (( len= fis.read(b))!=-1) {\n           	// 每次读取后,把数组变成字符串打印\n            System.out.println(new String(b));\n        }\n		// 关闭资源\n        fis.close();\n    }\n}\n\n输出结果：\nab\ncd\ned\n```\n\n错误数据`d`，是由于最后一次读取时，只读取一个字节`e`，数组中，上次读取的数据没有被完全替换，所以要通过`len` ，获取有效的字节，代码使用演示：\n\n```java\npublic class FISRead {\n    public static void main(String[] args) throws IOException{\n      	// 使用文件名称创建流对象.\n       	FileInputStream fis = new FileInputStream(\"read.txt\"); // 文件中为abcde\n      	// 定义变量，作为有效个数\n        int len ；\n        // 定义字节数组，作为装字节数据的容器   \n        byte[] b = new byte[2];\n        // 循环读取\n        while (( len= fis.read(b))!=-1) {\n           	// 每次读取后,把数组的有效字节部分，变成字符串打印\n            System.out.println(new String(b，0，len));//  len 每次读取的有效字节个数\n        }\n		// 关闭资源\n        fis.close();\n    }\n}\n\n输出结果：\nab\ncd\ne\n```\n\n> 小贴士：\n>\n> 使用数组读取，每次读取多个字节，减少了系统间的IO操作次数，从而提高了读写的效率，建议开发中使用。\n\n## 2.6 字节流练习：图片复制\n\n### 复制原理图解\n\n![](img/2_copy.jpg)\n\n### 案例实现\n\n复制图片文件，代码使用演示：\n\n```java\npublic class Copy {\n    public static void main(String[] args) throws IOException {\n        // 1.创建流对象\n        // 1.1 指定数据源\n        FileInputStream fis = new FileInputStream(\"D:\\\\test.jpg\");\n        // 1.2 指定目的地\n        FileOutputStream fos = new FileOutputStream(\"test_copy.jpg\");\n\n        // 2.读写数据\n        // 2.1 定义数组\n        byte[] b = new byte[1024];\n        // 2.2 定义长度\n        int len;\n        // 2.3 循环读取\n        while ((len = fis.read(b))!=-1) {\n            // 2.4 写出数据\n            fos.write(b, 0 , len);\n        }\n\n        // 3.关闭资源\n        fos.close();\n        fis.close();\n    }\n}\n```\n\n> 小贴士：\n>\n> 流的关闭原则：先开后关，后开先关。\n\n# 第三章 字符流\n\n当使用字节流读取文本文件时，可能会有一个小问题。就是遇到中文字符时，可能不会显示完整的字符，那是因为一个中文字符可能占用多个字节存储。所以Java提供一些字符流类，以字符为单位读写数据，专门用于处理文本文件。\n\n## 3.1 字符输入流【Reader】\n\n`java.io.Reader`抽象类是表示用于读取字符流的所有类的超类，可以读取字符信息到内存中。它定义了字符输入流的基本共性功能方法。\n\n- `public void close()` ：关闭此流并释放与此流相关联的任何系统资源。    \n- `public int read()`： 从输入流读取一个字符。 \n- `public int read(char[] cbuf)`： 从输入流中读取一些字符，并将它们存储到字符数组 cbuf中 。\n\n## 3.2 FileReader类  \n\n`java.io.FileReader `类是读取字符文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。\n\n> 小贴士：\n>\n> 1. 字符编码：字节与字符的对应规则。Windows系统的中文编码默认是GBK编码表。\n>\n>    idea中UTF-8\n>\n> 2. 字节缓冲区：一个字节数组，用来临时存储字节数据。\n\n### 构造方法\n\n- `FileReader(File file)`： 创建一个新的 FileReader ，给定要读取的File对象。   \n- `FileReader(String fileName)`： 创建一个新的 FileReader ，给定要读取的文件的名称。  \n\n当你创建一个流对象时，必须传入一个文件路径。类似于FileInputStream 。\n\n- 构造举例，代码如下：\n\n```java\npublic class FileReaderConstructor throws IOException{\n    public static void main(String[] args) {\n   	 	// 使用File对象创建流对象\n        File file = new File(\"a.txt\");\n        FileReader fr = new FileReader(file);\n      \n        // 使用文件名称创建流对象\n        FileReader fr = new FileReader(\"b.txt\");\n    }\n}\n```\n\n### 读取字符数据\n\n1. **读取字符**：`read`方法，每次可以读取一个字符的数据，提升为int类型，读取到文件末尾，返回`-1`，循环读取，代码使用演示：\n\n```java\npublic class FRRead {\n    public static void main(String[] args) throws IOException {\n      	// 使用文件名称创建流对象\n       	FileReader fr = new FileReader(\"read.txt\");\n      	// 定义变量，保存数据\n        int b ；\n        // 循环读取\n        while ((b = fr.read())!=-1) {\n            System.out.println((char)b);\n        }\n		// 关闭资源\n        fr.close();\n    }\n}\n输出结果：\n黑\n马\n程\n序\n员\n```\n\n> 小贴士：虽然读取了一个字符，但是会自动提升为int类型。\n>\n\n2. **使用字符数组读取**：`read(char[] cbuf)`，每次读取b的长度个字符到数组中，返回读取到的有效字符个数，读取到末尾时，返回`-1` ，代码使用演示：\n\n```java\npublic class FRRead {\n    public static void main(String[] args) throws IOException {\n      	// 使用文件名称创建流对象\n       	FileReader fr = new FileReader(\"read.txt\");\n      	// 定义变量，保存有效字符个数\n        int len ；\n        // 定义字符数组，作为装字符数据的容器\n         char[] cbuf = new char[2];\n        // 循环读取\n        while ((len = fr.read(cbuf))!=-1) {\n            System.out.println(new String(cbuf));\n        }\n		// 关闭资源\n        fr.close();\n    }\n}\n输出结果：\n黑马\n程序\n员序\n```\n\n获取有效的字符改进，代码使用演示：\n\n```java\npublic class FISRead {\n    public static void main(String[] args) throws IOException {\n      	// 使用文件名称创建流对象\n       	FileReader fr = new FileReader(\"read.txt\");\n      	// 定义变量，保存有效字符个数\n        int len ；\n        // 定义字符数组，作为装字符数据的容器\n        char[] cbuf = new char[2];\n        // 循环读取\n        while ((len = fr.read(cbuf))!=-1) {\n            System.out.println(new String(cbuf,0,len));\n        }\n    	// 关闭资源\n        fr.close();\n    }\n}\n\n输出结果：\n黑马\n程序\n员\n```\n\n## 3.3 字符输出流【Writer】\n\n`java.io.Writer `抽象类是表示用于写出字符流的所有类的超类，将指定的字符信息写出到目的地。它定义了字节输出流的基本共性功能方法。\n\n- `void write(int c)` 写入单个字符。\n- `void write(char[] cbuf) `写入字符数组。 \n- `abstract  void write(char[] cbuf, int off, int len) `写入字符数组的某一部分,off数组的开始索引,len写的字符个数。 \n- `void write(String str) `写入字符串。 \n- `void write(String str, int off, int len)` 写入字符串的某一部分,off字符串的开始索引,len写的字符个数。\n- `void flush() `刷新该流的缓冲。  \n- `void close()` 关闭此流，但要先刷新它。 \n\n## 3.4 FileWriter类\n\n`java.io.FileWriter `类是写出字符到文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。\n\n### 构造方法\n\n- `FileWriter(File file)`： 创建一个新的 FileWriter，给定要读取的File对象。   \n- `FileWriter(String fileName)`： 创建一个新的 FileWriter，给定要读取的文件的名称。  \n\n当你创建一个流对象时，必须传入一个文件路径，类似于FileOutputStream。\n\n- 构造举例，代码如下：\n\n```java\npublic class FileWriterConstructor {\n    public static void main(String[] args) throws IOException {\n   	 	// 使用File对象创建流对象\n        File file = new File(\"a.txt\");\n        FileWriter fw = new FileWriter(file);\n      \n        // 使用文件名称创建流对象\n        FileWriter fw = new FileWriter(\"b.txt\");\n    }\n}\n```\n\n### 基本写出数据\n\n**写出字符**：`write(int b)` 方法，每次可以写出一个字符数据，代码使用演示：\n\n```java\npublic class FWWrite {\n    public static void main(String[] args) throws IOException {\n        // 使用文件名称创建流对象\n        FileWriter fw = new FileWriter(\"fw.txt\");     \n      	// 写出数据\n      	fw.write(97); // 写出第1个字符\n      	fw.write(\'b\'); // 写出第2个字符\n      	fw.write(\'C\'); // 写出第3个字符\n      	fw.write(30000); // 写出第4个字符，中文编码表中30000对应一个汉字。\n      \n      	/*\n        【注意】关闭资源时,与FileOutputStream不同。\n      	 如果不关闭,数据只是保存到缓冲区，并未保存到文件。\n        */\n        // fw.close();\n    }\n}\n输出结果：\nabC田\n```\n\n> 小贴士：\n>\n> 1. 虽然参数为int类型四个字节，但是只会保留一个字符的信息写出。\n> 2. 未调用close方法，数据只是保存到了缓冲区，并未写出到文件中。\n\n### 关闭和刷新\n\n因为内置缓冲区的原因，如果不关闭输出流，无法写出字符到文件中。但是关闭的流对象，是无法继续写出数据的。如果我们既想写出数据，又想继续使用流，就需要`flush` 方法了。\n\n* `flush` ：刷新缓冲区，流对象可以继续使用。\n* `close `:先刷新缓冲区，然后通知系统释放资源。流对象不可以再被使用了。\n\n代码使用演示：\n\n```java\npublic class FWWrite {\n    public static void main(String[] args) throws IOException {\n        // 使用文件名称创建流对象\n        FileWriter fw = new FileWriter(\"fw.txt\");\n        // 写出数据，通过flush\n        fw.write(\'刷\'); // 写出第1个字符\n        fw.flush();\n        fw.write(\'新\'); // 继续写出第2个字符，写出成功\n        fw.flush();\n      \n      	// 写出数据，通过close\n        fw.write(\'关\'); // 写出第1个字符\n        fw.close();\n        fw.write(\'闭\'); // 继续写出第2个字符,【报错】java.io.IOException: Stream closed\n        fw.close();\n    }\n}\n```\n\n> 小贴士：即便是flush方法写出了数据，操作的最后还是要调用close方法，释放系统资源。\n\n### 写出其他数据\n\n1. **写出字符数组** ：`write(char[] cbuf)` 和 `write(char[] cbuf, int off, int len)` ，每次可以写出字符数组中的数据，用法类似FileOutputStream，代码使用演示：\n\n```java\npublic class FWWrite {\n    public static void main(String[] args) throws IOException {\n        // 使用文件名称创建流对象\n        FileWriter fw = new FileWriter(\"fw.txt\");     \n      	// 字符串转换为字节数组\n      	char[] chars = \"黑马程序员\".toCharArray();\n      \n      	// 写出字符数组\n      	fw.write(chars); // 黑马程序员\n        \n		// 写出从索引2开始，2个字节。索引2是\'程\'，两个字节，也就是\'程序\'。\n        fw.write(b,2,2); // 程序\n      \n      	// 关闭资源\n        fos.close();\n    }\n}\n```\n\n2. **写出字符串**：`write(String str)` 和 `write(String str, int off, int len)` ，每次可以写出字符串中的数据，更为方便，代码使用演示：\n\n```java\npublic class FWWrite {\n    public static void main(String[] args) throws IOException {\n        // 使用文件名称创建流对象\n        FileWriter fw = new FileWriter(\"fw.txt\");     \n      	// 字符串\n      	String msg = \"黑马程序员\";\n      \n      	// 写出字符数组\n      	fw.write(msg); //黑马程序员\n      \n		// 写出从索引2开始，2个字节。索引2是\'程\'，两个字节，也就是\'程序\'。\n        fw.write(msg,2,2);	// 程序\n      	\n        // 关闭资源\n        fos.close();\n    }\n}\n```\n\n3. **续写和换行**：操作类似于FileOutputStream。\n\n```java\npublic class FWWrite {\n    public static void main(String[] args) throws IOException {\n        // 使用文件名称创建流对象，可以续写数据\n        FileWriter fw = new FileWriter(\"fw.txt\"，true);     \n      	// 写出字符串\n        fw.write(\"黑马\");\n      	// 写出换行\n      	fw.write(\"\\r\\n\");\n      	// 写出字符串\n  		fw.write(\"程序员\");\n      	// 关闭资源\n        fw.close();\n    }\n}\n输出结果:\n黑马\n程序员\n```\n\n> 小贴士：字符流，只能操作文本文件，不能操作图片，视频等非文本文件。\n>\n> 当我们单纯读或者写文本文件时  使用字符流 其他情况使用字节流\n\n# 第四章 IO异常的处理\n\n### JDK7前处理\n\n之前的入门练习，我们一直把异常抛出，而实际开发中并不能这样处理，建议使用`try...catch...finally` 代码块，处理异常部分，代码使用演示：\n\n```java  \npublic class HandleException1 {\n    public static void main(String[] args) {\n      	// 声明变量\n        FileWriter fw = null;\n        try {\n            //创建流对象\n            fw = new FileWriter(\"fw.txt\");\n            // 写出数据\n            fw.write(\"黑马程序员\"); //黑马程序员\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                if (fw != null) {\n                    fw.close();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n\n### JDK7的处理(扩展知识点了解内容)\n\n还可以使用JDK7优化后的`try-with-resource` 语句，该语句确保了每个资源在语句结束时关闭。所谓的资源（resource）是指在程序完成后，必须关闭的对象。\n\n格式：\n\n```java\ntry (创建流对象语句，如果多个,使用\';\'隔开) {\n	// 读写数据\n} catch (IOException e) {\n	e.printStackTrace();\n}\n```\n\n代码使用演示：\n\n```java\npublic class HandleException2 {\n    public static void main(String[] args) {\n      	// 创建流对象\n        try ( FileWriter fw = new FileWriter(\"fw.txt\"); ) {\n            // 写出数据\n            fw.write(\"黑马程序员\"); //黑马程序员\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n### JDK9的改进(扩展知识点了解内容)\n\nJDK9中`try-with-resource` 的改进，对于**引入对象**的方式，支持的更加简洁。被引入的对象，同样可以自动关闭，无需手动close，我们来了解一下格式。\n\n改进前格式：\n\n```java\n// 被final修饰的对象\nfinal Resource resource1 = new Resource(\"resource1\");\n// 普通对象\nResource resource2 = new Resource(\"resource2\");\n// 引入方式：创建新的变量保存\ntry (Resource r1 = resource1;\n     Resource r2 = resource2) {\n     // 使用对象\n}\n```\n\n改进后格式：\n\n```java\n// 被final修饰的对象\nfinal Resource resource1 = new Resource(\"resource1\");\n// 普通对象\nResource resource2 = new Resource(\"resource2\");\n\n// 引入方式：直接引入\ntry (resource1; resource2) {\n     // 使用对象\n}\n```\n\n改进后，代码使用演示：\n\n```java\npublic class TryDemo {\n    public static void main(String[] args) throws IOException {\n       	// 创建流对象\n        final  FileReader fr  = new FileReader(\"in.txt\");\n        FileWriter fw = new FileWriter(\"out.txt\");\n       	// 引入到try中\n        try (fr; fw) {\n          	// 定义变量\n            int b;\n          	// 读取数据\n          	while ((b = fr.read())!=-1) {\n            	// 写出数据\n            	fw.write(b);\n          	}\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n# 第五章 属性集\n\n## 5.1 概述\n\n`java.util.Properties ` 继承于` Hashtable` ，来表示一个持久的属性集。它使用键值结构存储数据，每个键及其对应值都是一个字符串。该类也被许多Java类使用，比如获取系统属性时，`System.getProperties` 方法就是返回一个`Properties`对象。\n\n## 5.2 Properties类\n\n### 构造方法\n\n- `public Properties()` :创建一个空的属性列表。\n\n### 基本的存储方法\n\n- `public Object setProperty(String key, String value)` ： 保存一对属性。  \n- `public String getProperty(String key) ` ：使用此属性列表中指定的键搜索属性值。\n- `public Set<String> stringPropertyNames() ` ：所有键的名称的集合。\n\n```java\npublic class ProDemo {\n    public static void main(String[] args) throws FileNotFoundException {\n        // 创建属性集对象\n        Properties properties = new Properties();\n        // 添加键值对元素\n        properties.setProperty(\"filename\", \"a.txt\");\n        properties.setProperty(\"length\", \"209385038\");\n        properties.setProperty(\"location\", \"D:\\\\a.txt\");\n        // 打印属性集对象\n        System.out.println(properties);\n        // 通过键,获取属性值\n        System.out.println(properties.getProperty(\"filename\"));\n        System.out.println(properties.getProperty(\"length\"));\n        System.out.println(properties.getProperty(\"location\"));\n\n        // 遍历属性集,获取所有键的集合\n        Set<String> strings = properties.stringPropertyNames();\n        // 打印键值对\n        for (String key : strings ) {\n          	System.out.println(key+\" -- \"+properties.getProperty(key));\n        }\n    }\n}\n输出结果：\n{filename=a.txt, length=209385038, location=D:\\a.txt}\na.txt\n209385038\nD:\\a.txt\nfilename -- a.txt\nlength -- 209385038\nlocation -- D:\\a.txt\n```\n\n### 与流相关的方法\n\n- `public void load(InputStream inStream)`： 从字节输入流中读取键值对。 \n\n参数中使用了字节输入流，通过流对象，可以关联到某文件上，这样就能够加载文本中的数据了。文本数据格式:\n\n```\nfilename=a.txt\nlength=209385038\nlocation=D:\\a.txt\n```\n\n加载代码演示：\n\n```java\npublic class ProDemo2 {\n    public static void main(String[] args) throws FileNotFoundException {\n        // 创建属性集对象\n        Properties pro = new Properties();\n        // 加载文本中信息到属性集\n        pro.load(new FileInputStream(\"read.txt\"));\n        // 遍历集合并打印\n        Set<String> strings = pro.stringPropertyNames();\n        for (String key : strings ) {\n          	System.out.println(key+\" -- \"+pro.getProperty(key));\n        }\n     }\n}\n输出结果：\nfilename -- a.txt\nlength -- 209385038\nlocation -- D:\\a.txt\n```\n\n> 小贴士：文本中的数据，必须是键值对形式，可以使用空格、等号、冒号等符号分隔。',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2020-01-20 15:40:43','2020-11-29 11:45:12',0),(101,'缓冲流、转换流、序列化流、打印流','# 【缓冲流、转换流、序列化流】\n\n## 主要内容\n\n*  缓冲流\n*  转换流\n*  序列化流\n*  打印流\n\n\n## 教学目标\n\n- [ ] 能够使用字节缓冲流读取数据到程序\n- [ ] 能够使用字节缓冲流写出数据到文件\n- [ ] 能够明确字符缓冲流的作用和基本用法\n- [ ] 能够使用缓冲流的特殊功能\n- [ ] 能够阐述编码表的意义\n- [ ] 能够使用转换流读取指定编码的文本文件\n- [ ] 能够使用转换流写入指定编码的文本文件\n- [ ] 能够说出打印流的特点\n- [ ] 能够使用序列化流写出对象到文件\n- [ ] 能够使用反序列化流读取文件到程序中\n\n# 第一章 缓冲流\n\n昨天学习了基本的一些流，作为IO流的入门，今天我们要见识一些更强大的流。比如能够高效读写的缓冲流，能够转换编码的转换流，能够持久化存储对象的序列化流等等。这些功能更为强大的流，都是在基本的流对象基础之上创建而来的，就像穿上铠甲的武士一样，相当于是对基本流对象的一种增强。\n\n## 1.1 概述\n\n缓冲流,也叫高效流，是对4个基本的`FileXxx` 流的增强，所以也是4个流，按照数据类型分类：\n\n* **字节缓冲流**：`BufferedInputStream`，`BufferedOutputStream` \n* **字符缓冲流**：`BufferedReader`，`BufferedWriter`\n\n缓冲流的基本原理，是在创建流对象时，会创建一个内置的默认大小的缓冲区数组，通过缓冲区读写，减少系统IO次数，从而提高读写的效率。\n\n## 1.2 字节缓冲流\n\n### 构造方法\n\n* `public BufferedInputStream(InputStream in)` ：创建一个 新的缓冲输入流。 \n* `public BufferedOutputStream(OutputStream out)`： 创建一个新的缓冲输出流。\n\n构造举例，代码如下：\n\n```java\n// 创建字节缓冲输入流\nBufferedInputStream bis = new BufferedInputStream(new FileInputStream(\"bis.txt\"));\n// 创建字节缓冲输出流\nBufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\"bos.txt\"));\n```\n\n### 效率测试\n\n查询API，缓冲流读写方法与基本的流是一致的，我们通过复制大文件（375MB），测试它的效率。\n\n1. 基本流，代码如下：\n\n```java\npublic class BufferedDemo {\n    public static void main(String[] args) throws FileNotFoundException {\n        // 记录开始时间\n      	long start = System.currentTimeMillis();\n		// 创建流对象\n        try (\n        	FileInputStream fis = new FileInputStream(\"jdk9.exe\");\n        	FileOutputStream fos = new FileOutputStream(\"copy.exe\")\n        ){\n        	// 读写数据\n            int b;\n            while ((b = fis.read()) != -1) {\n                fos.write(b);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n		// 记录结束时间\n        long end = System.currentTimeMillis();\n        System.out.println(\"普通流复制时间:\"+(end - start)+\" 毫秒\");\n    }\n}\n\n十几分钟过去了...\n```\n\n2. 缓冲流，代码如下：\n\n```java\npublic class BufferedDemo {\n    public static void main(String[] args) throws FileNotFoundException {\n        // 记录开始时间\n      	long start = System.currentTimeMillis();\n		// 创建流对象\n        try (\n        	BufferedInputStream bis = new BufferedInputStream(new FileInputStream(\"jdk9.exe\"));\n	     BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\"copy.exe\"));\n        ){\n        // 读写数据\n            int b;\n            while ((b = bis.read()) != -1) {\n                bos.write(b);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n		// 记录结束时间\n        long end = System.currentTimeMillis();\n        System.out.println(\"缓冲流复制时间:\"+(end - start)+\" 毫秒\");\n    }\n}\n\n缓冲流复制时间:8016 毫秒\n```\n如何更快呢？\n\n使用数组的方式，代码如下：\n\n```java\npublic class BufferedDemo {\n    public static void main(String[] args) throws FileNotFoundException {\n      	// 记录开始时间\n        long start = System.currentTimeMillis();\n		// 创建流对象\n        try (\n			BufferedInputStream bis = new BufferedInputStream(new FileInputStream(\"jdk9.exe\"));\n		 BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\"copy.exe\"));\n        ){\n          	// 读写数据\n            int len;\n            byte[] bytes = new byte[8*1024];\n            while ((len = bis.read(bytes)) != -1) {\n                bos.write(bytes, 0 , len);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n		// 记录结束时间\n        long end = System.currentTimeMillis();\n        System.out.println(\"缓冲流使用数组复制时间:\"+(end - start)+\" 毫秒\");\n    }\n}\n缓冲流使用数组复制时间:666 毫秒\n```\n\n## 1.3 字符缓冲流\n\n### 构造方法\n\n* `public BufferedReader(Reader in)` ：创建一个 新的缓冲输入流。 \n* `public BufferedWriter(Writer out)`： 创建一个新的缓冲输出流。\n\n构造举例，代码如下：\n\n```java\n// 创建字符缓冲输入流\nBufferedReader br = new BufferedReader(new FileReader(\"br.txt\"));\n// 创建字符缓冲输出流\nBufferedWriter bw = new BufferedWriter(new FileWriter(\"bw.txt\"));\n```\n\n### 特有方法\n\n字符缓冲流的基本方法与普通字符流调用方式一致，不再阐述，我们来看它们具备的特有方法。\n\n* BufferedReader：`public String readLine()`: 读一行文字。 \n* BufferedWriter：`public void newLine()`: 写一行行分隔符,由系统属性定义符号。 \n\n`readLine`方法演示，代码如下：\n\n```java\npublic class BufferedReaderDemo {\n    public static void main(String[] args) throws IOException {\n      	 // 创建流对象\n        BufferedReader br = new BufferedReader(new FileReader(\"in.txt\"));\n		// 定义字符串,保存读取的一行文字\n        String line  = null;\n      	// 循环读取,读取到最后返回null\n        while ((line = br.readLine())!=null) {\n            System.out.print(line);\n            System.out.println(\"------\");\n        }\n		// 释放资源\n        br.close();\n    }\n}\n```\n\n`newLine`方法演示，代码如下：\n\n  ```java\npublic class BufferedWriterDemo throws IOException {\n    public static void main(String[] args) throws IOException  {\n      	// 创建流对象\n		BufferedWriter bw = new BufferedWriter(new FileWriter(\"out.txt\"));\n      	// 写出数据\n        bw.write(\"黑马\");\n      	// 写出换行\n        bw.newLine();\n        bw.write(\"程序\");\n        bw.newLine();\n        bw.write(\"员\");\n        bw.newLine();\n		// 释放资源\n        bw.close();\n    }\n}\n输出效果:\n黑马\n程序\n员\n  ```\n\n## 1.4 练习:文本排序\n\n请将文本信息恢复顺序。\n\n```\n3.侍中、侍郎郭攸之、费祎、董允等，此皆良实，志虑忠纯，是以先帝简拔以遗陛下。愚以为宫中之事，事无大小，悉以咨之，然后施行，必得裨补阙漏，有所广益。\n8.愿陛下托臣以讨贼兴复之效，不效，则治臣之罪，以告先帝之灵。若无兴德之言，则责攸之、祎、允等之慢，以彰其咎；陛下亦宜自谋，以咨诹善道，察纳雅言，深追先帝遗诏，臣不胜受恩感激。\n4.将军向宠，性行淑均，晓畅军事，试用之于昔日，先帝称之曰能，是以众议举宠为督。愚以为营中之事，悉以咨之，必能使行阵和睦，优劣得所。\n2.宫中府中，俱为一体，陟罚臧否，不宜异同。若有作奸犯科及为忠善者，宜付有司论其刑赏，以昭陛下平明之理，不宜偏私，使内外异法也。\n1.先帝创业未半而中道崩殂，今天下三分，益州疲弊，此诚危急存亡之秋也。然侍卫之臣不懈于内，忠志之士忘身于外者，盖追先帝之殊遇，欲报之于陛下也。诚宜开张圣听，以光先帝遗德，恢弘志士之气，不宜妄自菲薄，引喻失义，以塞忠谏之路也。\n9.今当远离，临表涕零，不知所言。\n6.臣本布衣，躬耕于南阳，苟全性命于乱世，不求闻达于诸侯。先帝不以臣卑鄙，猥自枉屈，三顾臣于草庐之中，咨臣以当世之事，由是感激，遂许先帝以驱驰。后值倾覆，受任于败军之际，奉命于危难之间，尔来二十有一年矣。\n7.先帝知臣谨慎，故临崩寄臣以大事也。受命以来，夙夜忧叹，恐付托不效，以伤先帝之明，故五月渡泸，深入不毛。今南方已定，兵甲已足，当奖率三军，北定中原，庶竭驽钝，攘除奸凶，兴复汉室，还于旧都。此臣所以报先帝而忠陛下之职分也。至于斟酌损益，进尽忠言，则攸之、祎、允之任也。\n5.亲贤臣，远小人，此先汉所以兴隆也；亲小人，远贤臣，此后汉所以倾颓也。先帝在时，每与臣论此事，未尝不叹息痛恨于桓、灵也。侍中、尚书、长史、参军，此悉贞良死节之臣，愿陛下亲之信之，则汉室之隆，可计日而待也。\n```\n\n### 案例分析\n\n1. 逐行读取文本信息。\n2. 解析文本信息到集合中。\n3. 遍历集合，按顺序，写出文本信息。\n\n### 案例实现\n\n```java\npublic class BufferedTest {\n    public static void main(String[] args) throws IOException {\n        // 创建map集合,保存文本数据,键为序号,值为文字\n        HashMap<String, String> lineMap = new HashMap<>();\n\n        // 创建流对象\n        BufferedReader br = new BufferedReader(new FileReader(\"in.txt\"));\n        BufferedWriter bw = new BufferedWriter(new FileWriter(\"out.txt\"));\n\n        // 读取数据\n        String line  = null;\n        while ((line = br.readLine())!=null) {\n            // 解析文本\n            String[] split = line.split(\"\\\\.\");\n            // 保存到集合\n            lineMap.put(split[0],split[1]);\n        }\n        // 释放资源\n        br.close();\n\n        // 遍历map集合\n        for (int i = 1; i <= lineMap.size(); i++) {\n            String key = String.valueOf(i);\n            // 获取map中文本\n            String value = lineMap.get(key);\n          	// 写出拼接文本\n            bw.write(key+\".\"+value);\n          	// 写出换行\n            bw.newLine();\n        }\n		// 释放资源\n        bw.close();\n    }\n}\n```\n\n\n\n# 第二章 转换流\n\n## 2.1 字符编码和字符集\n\n### 字符编码\n\n计算机中储存的信息都是用二进制数表示的，而我们在屏幕上看到的数字、英文、标点符号、汉字等字符是二进制数转换之后的结果。按照某种规则，将字符存储到计算机中，称为**编码** 。反之，将存储在计算机中的二进制数按照某种规则解析显示出来，称为**解码** 。比如说，按照A规则存储，同样按照A规则解析，那么就能显示正确的文本符号。反之，按照A规则存储，再按照B规则解析，就会导致乱码现象。\n\n编码:字符(能看懂的)--字节(看不懂的)\n\n解码:字节(看不懂的)-->字符(能看懂的)\n\n* **字符编码`Character Encoding`** : 就是一套自然语言的字符与二进制数之间的对应规则。\n\n  编码表:生活中文字和计算机中二进制的对应规则\n\n### 字符集\n\n* **字符集 `Charset`**：也叫编码表。是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等。\n\n计算机要准确的存储和识别各种字符集符号，需要进行字符编码，一套字符集必然至少有一套字符编码。常见字符集有ASCII字符集、GBK字符集、Unicode字符集等。![](img/1_charset.jpg)\n\n可见，当指定了**编码**，它所对应的**字符集**自然就指定了，所以**编码**才是我们最终要关心的。\n\n* **ASCII字符集** ：\n  * ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）是基于拉丁字母的一套电脑编码系统，用于显示现代英语，主要包括控制字符（回车键、退格、换行键等）和可显示字符（英文大小写字符、阿拉伯数字和西文符号）。\n  * 基本的ASCII字符集，使用7位（bits）表示一个字符，共128字符。ASCII的扩展字符集使用8位（bits）表示一个字符，共256字符，方便支持欧洲常用字符。\n* **ISO-8859-1字符集**：\n  * 拉丁码表，别名Latin-1，用于显示欧洲使用的语言，包括荷兰、丹麦、德语、意大利语、西班牙语等。\n  * ISO-8859-1使用单字节编码，兼容ASCII编码。\n* **GBxxx字符集**：\n  * GB就是国标的意思，是为了显示中文而设计的一套字符集。\n  * **GB2312**：简体中文码表。一个小于127的字符的意义与原来相同。但两个大于127的字符连在一起时，就表示一个汉字，这样大约可以组合了包含7000多个简体汉字，此外数学符号、罗马希腊的字母、日文的假名们都编进去了，连在ASCII里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的\"全角\"字符，而原来在127号以下的那些就叫\"半角\"字符了。\n  * **GBK**：最常用的中文码表。是在GB2312标准基础上的扩展规范，使用了双字节编码方案，共收录了21003个汉字，完全兼容GB2312标准，同时支持繁体汉字以及日韩汉字等。\n  * **GB18030**：最新的中文码表。收录汉字70244个，采用多字节编码，每个字可以由1个、2个或4个字节组成。支持中国国内少数民族的文字，同时支持繁体汉字以及日韩汉字等。\n* **Unicode字符集** ：\n  * Unicode编码系统为表达任意语言的任意字符而设计，是业界的一种标准，也称为统一码、标准万国码。\n  * 它最多使用4个字节的数字来表达每个字母、符号，或者文字。有三种编码方案，UTF-8、UTF-16和UTF-32。最为常用的UTF-8编码。\n  * UTF-8编码，可以用来表示Unicode标准中任何字符，它是电子邮件、网页及其他存储或传送文字的应用中，优先采用的编码。互联网工程工作小组（IETF）要求所有互联网协议都必须支持UTF-8编码。所以，我们开发Web应用，也要使用UTF-8编码。它使用一至四个字节为每个字符编码，编码规则：\n    1. 128个US-ASCII字符，只需一个字节编码。\n    2. 拉丁文等字符，需要二个字节编码。 \n    3. 大部分常用字（含中文），使用三个字节编码。\n    4. 其他极少使用的Unicode辅助字符，使用四字节编码。\n\n## 2.2 编码引出的问题\n\n在IDEA中，使用`FileReader` 读取项目中的文本文件。由于IDEA的设置，都是默认的`UTF-8`编码，所以没有任何问题。但是，当读取Windows系统中创建的文本文件时，由于Windows系统的默认是GBK编码，就会出现乱码。\n\n```java\npublic class ReaderDemo {\n    public static void main(String[] args) throws IOException {\n        FileReader fileReader = new FileReader(\"E:\\\\File_GBK.txt\");\n        int read;\n        while ((read = fileReader.read()) != -1) {\n            System.out.print((char)read);\n        }\n        fileReader.close();\n    }\n}\n输出结果：\n���\n```\n\n那么如何读取GBK编码的文件呢？ \n\n## 2.3 InputStreamReader类  \n\n转换流`java.io.InputStreamReader`，是Reader的子类，是从字节流到字符流的桥梁。它读取字节，并使用指定的字符集将其解码为字符。它的字符集可以由名称指定，也可以接受平台的默认字符集。 \n\n### 构造方法\n\n* `InputStreamReader(InputStream in)`: 创建一个使用默认字符集的字符流。 \n* `InputStreamReader(InputStream in, String charsetName)`: 创建一个指定字符集的字符流。\n\n构造举例，代码如下： \n\n```java\nInputStreamReader isr = new InputStreamReader(new FileInputStream(\"in.txt\"));\nInputStreamReader isr2 = new InputStreamReader(new FileInputStream(\"in.txt\") , \"GBK\");\n```\n\n### 指定编码读取\n\n```java\npublic class ReaderDemo2 {\n    public static void main(String[] args) throws IOException {\n      	// 定义文件路径,文件为gbk编码\n        String FileName = \"E:\\\\file_gbk.txt\";\n      	// 创建流对象,默认UTF8编码\n        InputStreamReader isr = new InputStreamReader(new FileInputStream(FileName));\n      	// 创建流对象,指定GBK编码\n        InputStreamReader isr2 = new InputStreamReader(new FileInputStream(FileName) , \"GBK\");\n		// 定义变量,保存字符\n        int read;\n      	// 使用默认编码字符流读取,乱码\n        while ((read = isr.read()) != -1) {\n            System.out.print((char)read); // ��Һ�\n        }\n        isr.close();\n      \n      	// 使用指定编码字符流读取,正常解析\n        while ((read = isr2.read()) != -1) {\n            System.out.print((char)read);// 大家好\n        }\n        isr2.close();\n    }\n}\n```\n\n## 2.4 OutputStreamWriter类\n\n转换流`java.io.OutputStreamWriter` ，是Writer的子类，是从字符流到字节流的桥梁。使用指定的字符集将字符编码为字节。它的字符集可以由名称指定，也可以接受平台的默认字符集。 \n\n### 构造方法\n\n- `OutputStreamWriter(OutputStream in)`: 创建一个使用默认字符集的字符流。 \n- `OutputStreamWriter(OutputStream in, String charsetName)`: 创建一个指定字符集的字符流。\n\n构造举例，代码如下： \n\n```java\nOutputStreamWriter isr = new OutputStreamWriter(new FileOutputStream(\"out.txt\"));\nOutputStreamWriter isr2 = new OutputStreamWriter(new FileOutputStream(\"out.txt\") , \"GBK\");\n```\n\n### 指定编码写出\n\n```java\npublic class OutputDemo {\n    public static void main(String[] args) throws IOException {\n      	// 定义文件路径\n        String FileName = \"E:\\\\out.txt\";\n      	// 创建流对象,默认UTF8编码\n        OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(FileName));\n        // 写出数据\n      	osw.write(\"你好\"); // 保存为6个字节\n        osw.close();\n      	\n		// 定义文件路径\n		String FileName2 = \"E:\\\\out2.txt\";\n     	// 创建流对象,指定GBK编码\n        OutputStreamWriter osw2 = new OutputStreamWriter(new FileOutputStream(FileName2),\"GBK\");\n        // 写出数据\n      	osw2.write(\"你好\");// 保存为4个字节\n        osw2.close();\n    }\n}\n```\n\n### 转换流理解图解\n\n**转换流是字节与字符间的桥梁！**![](img/2_zhuanhuan.jpg)\n\n## 2.5 练习：转换文件编码\n\n将GBK编码的文本文件，转换为UTF-8编码的文本文件。\n\n### 案例分析\n\n1. 指定GBK编码的转换流，读取文本文件。\n2. 使用UTF-8编码的转换流，写出文本文件。\n\n### 案例实现\n\n```java\npublic class TransDemo {\n   public static void main(String[] args) {      \n    	// 1.定义文件路径\n     	String srcFile = \"file_gbk.txt\";\n        String destFile = \"file_utf8.txt\";\n		// 2.创建流对象\n    	// 2.1 转换输入流,指定GBK编码\n        InputStreamReader isr = new InputStreamReader(new FileInputStream(srcFile) , \"GBK\");\n    	// 2.2 转换输出流,默认utf8编码\n        OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(destFile));\n		// 3.读写数据\n    	// 3.1 定义数组\n        char[] cbuf = new char[1024];\n    	// 3.2 定义长度\n        int len;\n    	// 3.3 循环读取\n        while ((len = isr.read(cbuf))!=-1) {\n            // 循环写出\n          	osw.write(cbuf,0,len);\n        }\n    	// 4.释放资源\n        osw.close();\n        isr.close();\n  	}\n}\n```\n\n# 第三章 序列化\n\n## 3.1 概述\n\nJava 提供了一种对象**序列化**的机制。用一个字节序列可以表示一个对象，该字节序列包含该`对象的数据`、`对象的类型`和`对象中存储的属性`等信息。字节序列写出到文件之后，相当于文件中**持久保存**了一个对象的信息。 \n\n反之，该字节序列还可以从文件中读取回来，重构对象，对它进行**反序列化**。`对象的数据`、`对象的类型`和`对象中存储的数据`信息，都可以用来在内存中创建对象。看图理解序列化： ![](img/3_xuliehua.jpg)\n\n## 3.2 ObjectOutputStream类\n\n`java.io.ObjectOutputStream ` 类，将Java对象的原始数据类型写出到文件,实现对象的持久存储。\n\n### 构造方法\n\n* `public ObjectOutputStream(OutputStream out) `： 创建一个指定OutputStream的ObjectOutputStream。\n\n构造举例，代码如下：  \n\n```java\nFileOutputStream fileOut = new FileOutputStream(\"employee.txt\");\nObjectOutputStream out = new ObjectOutputStream(fileOut);\n```\n\n### 序列化操作\n\n1. 一个对象要想序列化，必须满足两个条件:\n\n* 该类必须实现`java.io.Serializable ` 接口，`Serializable` 是一个标记接口，不实现此接口的类将不会使任何状态序列化或反序列化，会抛出`NotSerializableException` 。\n* 该类的所有属性必须是可序列化的。如果有一个属性不需要可序列化的，则该属性必须注明是瞬态的，使用`transient` 关键字修饰。\n\n```java\npublic class Employee implements java.io.Serializable {\n    public String name;\n    public String address;\n    public transient int age; // transient瞬态修饰成员,不会被序列化\n    public void addressCheck() {\n      	System.out.println(\"Address  check : \" + name + \" -- \" + address);\n    }\n}\n```\n\n2.写出对象方法\n\n* `public final void writeObject (Object obj)` : 将指定的对象写出。\n\n```java\npublic class SerializeDemo{\n   	public static void main(String [] args)   {\n    	Employee e = new Employee();\n    	e.name = \"zhangsan\";\n    	e.address = \"beiqinglu\";\n    	e.age = 20; \n    	try {\n      		// 创建序列化流对象\n          ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(\"employee.txt\"));\n        	// 写出对象\n        	out.writeObject(e);\n        	// 释放资源\n        	out.close();\n        	fileOut.close();\n        	System.out.println(\"Serialized data is saved\"); // 姓名，地址被序列化，年龄没有被序列化。\n        } catch(IOException i)   {\n            i.printStackTrace();\n        }\n   	}\n}\n输出结果：\nSerialized data is saved\n```\n\n## 3.3 ObjectInputStream类\n\nObjectInputStream反序列化流，将之前使用ObjectOutputStream序列化的原始数据恢复为对象。 \n\n### 构造方法\n\n* `public ObjectInputStream(InputStream in) `： 创建一个指定InputStream的ObjectInputStream。\n\n### 反序列化操作1\n\n如果能找到一个对象的class文件，我们可以进行反序列化操作，调用`ObjectInputStream`读取对象的方法：\n\n- `public final Object readObject ()` : 读取一个对象。\n\n```java\npublic class DeserializeDemo {\n   public static void main(String [] args)   {\n        Employee e = null;\n        try {		\n             // 创建反序列化流\n             FileInputStream fileIn = new FileInputStream(\"employee.txt\");\n             ObjectInputStream in = new ObjectInputStream(fileIn);\n             // 读取一个对象\n             e = (Employee) in.readObject();\n             // 释放资源\n             in.close();\n             fileIn.close();\n        }catch(IOException i) {\n             // 捕获其他异常\n             i.printStackTrace();\n             return;\n        }catch(ClassNotFoundException c)  {\n        	// 捕获类找不到异常\n             System.out.println(\"Employee class not found\");\n             c.printStackTrace();\n             return;\n        }\n        // 无异常,直接打印输出\n        System.out.println(\"Name: \" + e.name);	// zhangsan\n        System.out.println(\"Address: \" + e.address); // beiqinglu\n        System.out.println(\"age: \" + e.age); // 0\n    }\n}\n```\n\n**对于JVM可以反序列化对象，它必须是能够找到class文件的类。如果找不到该类的class文件，则抛出一个 `ClassNotFoundException` 异常。**  \n\n### **反序列化操作2**\n\n**另外，当JVM反序列化对象时，能找到class文件，但是class文件在序列化对象之后发生了修改，那么反序列化操作也会失败，抛出一个`InvalidClassException`异常。**发生这个异常的原因如下：\n\n* 该类的序列版本号与从流中读取的类描述符的版本号不匹配 \n* 该类包含未知数据类型 \n* 该类没有可访问的无参数构造方法 \n\n`Serializable` 接口给需要序列化的类，提供了一个序列版本号。`serialVersionUID` 该版本号的目的在于验证序列化的对象和对应类是否版本匹配。\n\n```java\npublic class Employee implements java.io.Serializable {\n     // 加入序列版本号\n     private static final long serialVersionUID = 1L;\n     public String name;\n     public String address;\n     // 添加新的属性 ,重新编译, 可以反序列化,该属性赋为默认值.\n     public int eid; \n\n     public void addressCheck() {\n         System.out.println(\"Address  check : \" + name + \" -- \" + address);\n     }\n}\n```\n\n\n\n## 3.4 练习：序列化集合\n\n1. 将存有多个自定义对象的集合序列化操作，保存到`list.txt`文件中。\n2. 反序列化`list.txt` ，并遍历集合，打印对象信息。\n\n### 案例分析\n\n1. 把若干学生对象 ，保存到集合中。\n2. 把集合序列化。\n3. 反序列化读取时，只需要读取一次，转换为集合类型。\n4. 遍历集合，可以打印所有的学生信息\n\n### 案例实现\n\n```java\npublic class SerTest {\n	public static void main(String[] args) throws Exception {\n		// 创建 学生对象\n		Student student = new Student(\"老王\", \"laow\");\n		Student student2 = new Student(\"老张\", \"laoz\");\n		Student student3 = new Student(\"老李\", \"laol\");\n\n		ArrayList<Student> arrayList = new ArrayList<>();\n		arrayList.add(student);\n		arrayList.add(student2);\n		arrayList.add(student3);\n		// 序列化操作\n		// serializ(arrayList);\n		\n		// 反序列化  \n		ObjectInputStream ois  = new ObjectInputStream(new FileInputStream(\"list.txt\"));\n		// 读取对象,强转为ArrayList类型\n		ArrayList<Student> list  = (ArrayList<Student>)ois.readObject();\n		\n      	for (int i = 0; i < list.size(); i++ ){\n          	Student s = list.get(i);\n        	System.out.println(s.getName()+\"--\"+ s.getPwd());\n      	}\n	}\n\n	private static void serializ(ArrayList<Student> arrayList) throws Exception {\n		// 创建 序列化流 \n		ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(\"list.txt\"));\n		// 写出对象\n		oos.writeObject(arrayList);\n		// 释放资源\n		oos.close();\n	}\n}\n```\n\n\n#  第四章 打印流\n\n## 4.1 概述\n\n平时我们在控制台打印输出，是调用`print`方法和`println`方法完成的，这两个方法都来自于`java.io.PrintStream`类，该类能够方便地打印各种数据类型的值，是一种便捷的输出方式。\n\n## 4.2 PrintStream类\n\n### 构造方法\n\n* `public PrintStream(String fileName)  `： 使用指定的文件名创建一个新的打印流。\n\n构造举例，代码如下：  \n\n```java\nPrintStream ps = new PrintStream(\"ps.txt\")；\n```\n\n### 改变打印流向\n\n`System.out`就是`PrintStream`类型的，只不过它的流向是系统规定的，打印在控制台上。不过，既然是流对象，我们就可以玩一个\"小把戏\"，改变它的流向。\n\n```java\npublic class PrintDemo {\n    public static void main(String[] args) throws IOException {\n		// 调用系统的打印流,控制台直接输出97\n        System.out.println(97);\n      \n		// 创建打印流,指定文件的名称\n        PrintStream ps = new PrintStream(\"ps.txt\");\n      	\n      	// 设置系统的打印流流向,输出到ps.txt\n        System.setOut(ps);\n      	// 调用系统的打印流,ps.txt中输出97\n        System.out.println(97);\n    }\n}\n```',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2020-01-30 10:27:49','2020-11-29 11:45:12',0),(102,'乐观锁与悲观锁','[TOC]\n## 非原子性操作导致危险发生\n> 原子性操作：操作无法再分\n\n```java\npublic class NoneAtomic {\n\n    private static int num = 0;\n\n    public static void addNum() {\n        num++;\n    }\n\n    public static void main(String[] args) {\n        for (int i = 0; i < 20; i++) {\n            new Thread(() -> {\n                for (int j = 1; j <= 10000 ; j++) {\n                    //此操作不是原子性操作，线程抢占执行任务会被其它线程打断\n                    addNum();\n                }\n            }).start();\n        }\n        while (Thread.activeCount() > 2)   //主线程和gc线程等待其它线程\n            Thread.yield();\n\n        System.out.println(num);\n    }\n}\n```\n由于num++不是原子性操作，不同线程抢占资源并对资源进行修改，导致最终结果不是200000  \n\n## 悲观锁-PessimisticLock\n### 概念\n> 悲观锁的看法十分悲观，认为资源一定会被别人抢占，所以当前线程拿到资源会立刻上一把锁，让其他线程无法对资源进行操作  \n\n1. 传统的关系型数据库使用这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。  \n2. Java 里面的同步 synchronized 关键字的实现。\n\n### 实现\n```java\npublic class PessimisticLock {\n\n    private static int num = 0;\n\n    public static void addNum() {\n        synchronized (PessimisticLock.class) {\n            num++;  //使用互斥锁使除当前以外其它线程无法访问资源\n        }\n    }\n\n    public static void main(String[] args) {\n        for (int i = 0; i < 20; i++) {\n            new Thread(() -> {\n                for (int j = 1; j <= 10000; j++) {\n                    addNum(); \n                }\n            }).start();\n        }\n        while (Thread.activeCount() > 2)   //主线程和gc线程等待其它线程\n            Thread.yield();\n\n        System.out.println(num);    //结果为200000\n    }\n}\n```\n缺点：\n悲观并发控制实际上是“先取锁再访问”的保守策略，为数据处理的安全提供了保证。但是在效率方面，处理加锁的机制会让数据库产生额外的开销，还有增加产生死锁的机会。另外还会降低并行性，一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数据。 \n\n## 乐观锁-OptimisticLock\n### 概念\n> 乐观锁的看法比较乐观，不会给资源上锁，允许其它线程访问。\n\n> 乐观锁假设数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则返回给用户错误的信息，让用户决定如何去做。乐观锁适用于读操作多的场景，这样可以提高程序的吞吐量  \n\n\n### 实现\n#### CAS-CompareAndSwap\n> CAS对应Java中Unsafe类下的compareAndSwap原生方法，调用C++下的指令级实现让cpu实现原子性的存储操作  \n\n我们可以使用Java下的Atomic类实现原子性的自增操作：  \n**Atomic相关类使用Unsafe类实现了对于不同基本数据类型的原子性操作**\n```java\npublic class OptimisticLock {\n\n    private static final AtomicInteger num = new AtomicInteger(0);\n\n    public static void addNum() {\n        num.getAndIncrement();\n    }\n\n    public static void main(String[] args) {\n        for (int i = 0; i < 20; i++) {\n            new Thread(() -> {\n                for (int j = 1; j <= 10000; j++) {\n                    addNum();   //操作变为原子操作\n                }\n            }).start();\n        }\n        while (Thread.activeCount() > 2)   //主线程和gc线程等待其它线程\n            Thread.yield();\n\n        System.out.println(num);    //结果为200000\n    }\n}\n```\nUnsafe类下的底层实现：\n```java\npublic final int getAndAddInt(Object var1, long var2, int var4) {\n    int var5;\n    do {\n        var5 = this.getIntVolatile(var1, var2);\n    } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));\n\n    return var5;\n}\n```\n调用了原生方法：\n> 这就是一个原子性操作  \n\n```\npublic final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5);\n```\n\n#### 版本号控制-ABA问题\n> ABA问题其实是在CAS之上的\n\n![image](https://upload-images.jianshu.io/upload_images/7038163-8ca34c3adccb7ca6.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/640/format/webp)  \n对于线程2来说虽然开始拿到的数值还是\"3\"，但是它已经被线程1改过了，现在的\"3\"不是原来的那个\"3\"了，为了解决这样的为问题会使用Java中的 AtomicStampedReference<T>解决  \n```java\nAtomicStampedReference<Integer> atomicStampedReference = new AtomicStampedReference<>(1,1);\n```\n在这里多了一个Stamp，也就是时间戳，可以实现版本控制，当线程2拿到资源的时候它就会发现版本号并不是一开始的那个版本了，从而可以及时发现并抛出异常',16,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2020-11-10 08:52:39','2020-11-29 11:45:12',0),(103,'生产者消费者问题','[TOC]\n## 描述\n生产者与消费者并发执行任务，防止出现问题\n\n## 实现\n### 管程法\n通过使用池的概念实现  \n创建一个同步池，判断当前池子中的状态对不同线程实现管理  \n```java\nclass Pool {\n    Product[] products = new Product[10];\n    int count = 0;\n\n    //生产者存入\n    public synchronized void push(Product product) {\n        while (count == products.length - 1) {\n            //存储池已满进入等待\n            try {\n                this.wait();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n        //添加产品到池子中\n        products[count] = product;\n        count++;\n\n        //已存入产品通知可以消费\n        this.notifyAll();\n    }\n\n    //消费者消费\n    public synchronized Product pop() {\n        while (count == 0) {\n            //存储池空进行等待\n            try {\n                this.wait();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n        count--;\n        Product product = this.products[count];\n        //提醒生产者生产\n        this.notifyAll();\n        return product;\n    }\n}\n```\n生产者：\n```java\nclass Producer implements Runnable {\n\n    private final Pool pool;\n\n    public Producer(Pool pool) {\n        this.pool = pool;\n    }\n\n    @Override\n    public void run() {\n        for (int i = 0; i < 100; i++) {\n            pool.push(new Product(i));\n            System.out.println(\"生产了\" + i + \"产品\");\n        }\n    }\n}\n```\n消费者：\n```java\nclass Consumer implements Runnable {\n\n    private final Pool pool;\n\n    Consumer(Pool pool) {\n        this.pool = pool;\n    }\n\n    @Override\n    public void run() {\n        for (int i = 0; i < 100; i++) {\n            Product product = pool.pop();\n            System.out.println(\"消费了\" + product.id + \"个产品\");\n        }\n    }\n}\n```\n产品：\n```java\nclass Product {\n    int id;\n\n    public Product(int id) {\n        this.id = id;\n    }\n}\n```\n通过wait和notifyAll实现线程之间的通信，当某一方条件不满足时进入等待状态，等待被其它线程唤醒  \n> 因为wait()的线程永远不能确定其他线程会在什么状态下notify()，所以必须在被唤醒、抢占到锁并且从wait()方法退出的时候再次进行指定条件的判断，以决定是满足条件往下执行呢还是不满足条件再次wait()  \n那么就极有可能出现唤醒生产者的是另一个生产者或者唤醒消费者的是另一个消费者，这样的情况下用if就必然会现类似过度生产或者过度消费的情况了，典型如IndexOutOfBoundsException的异常。**所以所有的java书籍都会建议开发者永远都要把wait()放到循环语句里面**。\nhttps://www.jianshu.com/p/25e243850bd2?appinstall=0\n\n### 信号灯法\n使用标志进行判断能否执行当前线程  \n产品：\n```java\nclass Product {\n    int id;\n    boolean flag = false;    //false为生产，true为消费\n\n    public Product(int id) {\n        this.id = id;\n    }\n\n    public synchronized void produce() {\n        while (this.flag) {\n            try {\n                this.wait();    //有产品不进行生产\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n        System.out.println(\"生产\");\n        this.flag = true;\n        this.notifyAll();\n    }\n\n    public synchronized void consume() {\n        while (!this.flag) {\n            try {\n                this.wait();    //没有产品不进行消费\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n        System.out.println(\"消费\");\n        this.flag = false;\n        this.notifyAll();\n    }\n}\n```\n生产者：\n```java\nclass Producer implements Runnable {\n\n    Product product;\n\n    public Producer(Product product) {\n        this.product = product;\n    }\n\n    @Override\n    public void run() {\n        for (int i = 0; i < 100; i++) {\n            product.produce();\n        }\n    }\n}\n```\n消费者：\n```java\nclass Consumer implements Runnable {\n\n    Product product;\n\n    public Consumer(Product product) {\n        this.product = product;\n    }\n\n    @Override\n    public void run() {\n        for (int i = 0; i < 100; i++) {\n            product.consume();\n        }\n    }\n}\n```\n\n\n## 全部代码\n### 管程法\n```java\npublic class PCProblem {\n    public static void main(String[] args) {\n        Pool pool = new Pool();\n        Producer producer = new Producer(pool);\n        Consumer consumer = new Consumer(pool);\n        new Thread(producer).start();\n        new Thread(consumer).start();\n    }\n}\n\nclass Pool {\n    Product[] products = new Product[10];\n    int count = 0;\n\n    //生产者存入\n    public synchronized void push(Product product) {\n        if (count == products.length - 1) {\n            //存储池已满进入等待\n            try {\n                this.wait();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n        //添加产品到池子中\n        products[count] = product;\n        count++;\n\n        //已存入产品通知可以消费\n        this.notifyAll();\n    }\n\n    //消费者消费\n    public synchronized Product pop() {\n        if (count == 0) {\n            //存储池空进行等待\n            try {\n                this.wait();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n        count--;\n        Product product = this.products[count];\n        //提醒生产者生产\n        this.notifyAll();\n        return product;\n    }\n}\n\nclass Producer implements Runnable {\n\n    private final Pool pool;\n\n    public Producer(Pool pool) {\n        this.pool = pool;\n    }\n\n    @Override\n    public void run() {\n        for (int i = 0; i < 100; i++) {\n            pool.push(new Product(i));\n            System.out.println(\"生产了\" + i + \"产品\");\n        }\n    }\n}\n\nclass Consumer implements Runnable {\n\n    private final Pool pool;\n\n    Consumer(Pool pool) {\n        this.pool = pool;\n    }\n\n    @Override\n    public void run() {\n        for (int i = 0; i < 100; i++) {\n            Product product = pool.pop();\n            System.out.println(\"消费了\" + product.id + \"个产品\");\n        }\n    }\n}\n\nclass Product {\n    int id;\n\n    public Product(int id) {\n        this.id = id;\n    }\n}\n```\n### 信号灯法\n```java\npublic class PCProblem {\n    public static void main(String[] args) {\n        Product product = new Product(1);\n        Producer producer = new Producer(product);\n        Consumer consumer = new Consumer(product);\n        new Thread(producer).start();\n        new Thread(consumer).start();\n    }\n}\n\nclass Producer implements Runnable {\n\n    Product product;\n\n    public Producer(Product product) {\n        this.product = product;\n    }\n\n    @Override\n    public void run() {\n        for (int i = 0; i < 100; i++) {\n            product.produce();\n        }\n    }\n}\n\nclass Consumer implements Runnable {\n\n    Product product;\n\n    public Consumer(Product product) {\n        this.product = product;\n    }\n\n    @Override\n    public void run() {\n        for (int i = 0; i < 100; i++) {\n            product.consume();\n        }\n    }\n}\n\nclass Product {\n    int id;\n    boolean flag = false;    //false为生产，true为消费\n\n    public Product(int id) {\n        this.id = id;\n    }\n\n    public synchronized void produce() {\n        while (this.flag) {\n            try {\n                this.wait();    //有产品不进行生产\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n        System.out.println(\"生产\");\n        this.flag = true;\n        this.notifyAll();\n    }\n\n    public synchronized void consume() {\n        while (!this.flag) {\n            try {\n                this.wait();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n        System.out.println(\"消费\");\n        this.flag = false;\n        this.notifyAll();\n    }\n}\n```',8,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2020-11-13 15:42:42','2020-11-29 11:45:12',0),(104,'BS服务器','Browser Sever用于浏览器与服务端进行沟通<br>\r\n浏览器对服务器申请访问请求，服务器进行解析之后将文件发送回浏览器<br>\r\n浏览器对于图片的请求应使用多线程一个个回复请求<br>\r\n```java\r\npackage NET;\r\n\r\nimport java.io.*;\r\nimport java.net.ServerSocket;\r\nimport java.net.Socket;\r\n\r\n//http://localhost:8000/web/index.html\r\npublic class BSServer {\r\n    @SuppressWarnings(\"InfiniteLoopStatement\")  //取消无限循环警告\r\n    public static void main(String[] args) throws IOException {\r\n        ServerSocket serverSocket = new ServerSocket(8000);\r\n        while (true) {  //循环接收请求\r\n            Socket socket = serverSocket.accept();\r\n            new Thread(new WebServer(socket)).start();\r\n        }\r\n    }\r\n\r\n    public static class WebServer implements Runnable {\r\n\r\n        private Socket socket;\r\n\r\n        public WebServer(Socket socket) {\r\n            this.socket = socket;\r\n        }\r\n\r\n        @Override\r\n        public void run() {\r\n            try {\r\n                //获取请求资源的位置\r\n                BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(socket.getInputStream()));\r\n                String request = bufferedReader.readLine();\r\n                String[] array = request.split(\" \");\r\n                String path = array[1].substring(1);    // 去掉web前面的/\r\n                System.out.println(path);\r\n\r\n                //寻找资源\r\n                FileInputStream fileInputStream = new FileInputStream(path);\r\n                OutputStream outputStream = socket.getOutputStream();\r\n                byte[] bytes = new byte[1024];\r\n                int len;\r\n                //输出\r\n                outputStream.write(\"HTTP/1.1 200 OK\\r\\n\".getBytes());\r\n                outputStream.write(\"Content-Type:text/html\\r\\n\".getBytes());\r\n                outputStream.write(\"\\r\\n\".getBytes());\r\n                while ((len = fileInputStream.read(bytes)) != -1) {\r\n                    outputStream.write(bytes, 0, len);\r\n                }\r\n\r\n                //关闭\r\n                fileInputStream.close();\r\n                bufferedReader.close();\r\n                socket.close();\r\n            } catch (Exception e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n}\r\n```',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2020-02-02 12:18:57','2020-11-29 11:45:12',0),(105,'Socket','### 客户端\n```java\npackage NET;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.Socket;\n\npublic class Client {\n    public static void main(String[] args) throws IOException {\n        Socket socket = new Socket(\"192.168.2.100\", 8000);\n        OutputStream outputStream = socket.getOutputStream();\n        outputStream.write(\"hello\".getBytes());\n        //收\n        InputStream inputStream = socket.getInputStream();\n        byte[] bytes = new byte[1024];\n        int len = inputStream.read(bytes);\n        System.out.println(new String(bytes, 0, len));\n        socket.close();\n    }\n}\n```\n### 服务端\n```java\npackage NET;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\npublic class Server {\n    public static void main(String[] args) throws IOException {\n        ServerSocket serverSocket = new ServerSocket(8000);\n        Socket socket = serverSocket.accept();\n        InputStream inputStream = socket.getInputStream();\n        byte[] bytes = new byte[1024];\n        int len = inputStream.read(bytes);\n        System.out.println(new String(bytes,0,len));\n        //发\n        OutputStream outputStream = socket.getOutputStream();\n        outputStream.write(\"get it\".getBytes());\n        socket.close();\n        serverSocket.close();\n    }\n}\n```',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2020-01-31 20:29:20','2020-11-29 11:45:12',0),(106,'客户端发送阻塞问题','### 客户端\n```java\npackage NET;\n\nimport java.io.*;\nimport java.net.Socket;\n\npublic class Client {\n    public static void main(String[] args) throws IOException {\n        FileInputStream fileInputStream = new FileInputStream(\"c:\\\\ZeldaBotW_thanks_B_1920_1080.jpg\");  //读取文件\n        byte[] bytes = new byte[1024];\n        int len;\n\n        Socket socket = new Socket(\"192.168.2.100\", 8000);\n        OutputStream outputStream = socket.getOutputStream();\n\n        while (true) {\n            len = fileInputStream.read(bytes);\n            System.out.println(len);\n            if (len == -1) {\n                break;\n            }\n            outputStream.write(bytes, 0, len);\n        }\n        socket.shutdownOutput();\n        System.out.println(socket.getInputStream().read(bytes));\n\n        fileInputStream.close();\n        socket.close();\n\n    }\n}\n```\n在使用基于socket的输出流时，无法将文件的结束标记写入（由于没有结束标志服务端停在了inputStream.read(bytes)），所以要使用socket.shutdownOutput()关闭输出流<br>\n客户端的socket.close()同样会关闭输出流<br>\n```java\npublic void shutdownInput()throws IOException\n将此套接字的输入流放置在“流的末尾”。 发送到套接字的输入流侧的任何数据都被确认，然后静默丢弃。 \n如果您在套接字上调用此方法后从套接字输入流读取，则流的available方法将返回0，其read方法将返回-1 （流结束）。\n```\n### 服务端\n```java\npackage NET;\n\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\npublic class Server {\n    public static void main(String[] args) throws IOException {\n        FileOutputStream fileOutputStream = new FileOutputStream(\"result.jpg\");\n        ServerSocket serverSocket = new ServerSocket(8000);\n        Socket socket = serverSocket.accept();\n        InputStream inputStream = socket.getInputStream();\n        byte[] bytes = new byte[1024000000];\n        int len;\n        while (true) {\n            len = inputStream.read(bytes);\n            System.out.println(len);\n            if (len == -1) {\n                break;\n            }\n            fileOutputStream.write(bytes, 0, len);\n\n        }\n\n        socket.getOutputStream().write(\"ok\".getBytes());\n\n        fileOutputStream.close();\n        socket.close();\n        serverSocket.close();\n    }\n}\n```',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2020-01-31 21:19:53','2020-11-29 11:45:12',0),(107,'服务端多线程循环接收消息','```java\npackage NET;\n\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\npublic class Server {\n    @SuppressWarnings(\"InfiniteLoopStatement\")  //取消无限循环警告\n    public static void main(String[] args) throws IOException {\n        ServerSocket serverSocket = new ServerSocket(8000);\n        while (true) {\n            Socket socket = serverSocket.accept();\n            new Thread(new Runnable() {\n                @Override\n                public void run() {\n                    try {\n                        InputStream inputStream = socket.getInputStream();\n                        byte[] bytes = new byte[1024];//1 000 000 000\n                        int len;\n                        String name = (System.currentTimeMillis()) + \".jpg\";\n                        FileOutputStream fileOutputStream = new FileOutputStream(name);\n                        while ((len = inputStream.read(bytes)) != -1)\n                            fileOutputStream.write(bytes, 0, len);\n                        fileOutputStream.close();\n                        socket.close();\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                }\n            }).start();\n        }\n    }\n}\n```\n### 客户端\n```java\npackage NET;\n\nimport java.io.*;\nimport java.net.Socket;\nimport java.util.Scanner;\n\npublic class Client {\n    public static void main(String[] args) throws IOException {\n        FileInputStream fileInputStream = new FileInputStream(\"c:\\\\ZeldaBotW_thanks_B_1920_1080.jpg\");  //读取文件\n        byte[] bytes = new byte[1024];\n        int len;\n\n        Socket socket = new Socket(\"192.168.2.100\", 8000);\n        OutputStream outputStream = socket.getOutputStream();\n\n        while (true) {\n            len = fileInputStream.read(bytes);\n            System.out.println(len);\n            if (len == -1) {\n                break;\n            }\n            outputStream.write(bytes, 0, len);\n        }\n        socket.shutdownOutput();\n\n        fileInputStream.close();\n        socket.close();\n\n    }\n}\n```',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2020-02-01 15:27:08','2020-11-29 11:45:12',0),(108,'代理模式','[TOC]\n## 动态代理\n概念：<br>\n    1. 真实对象：被代理的对象<br>\n    2. 代理对象：完成代理的对象<br>\n    3. 代理模式：代理对象代理真实对象，达到增强真实对象功能的目的<br>\n步骤：<br>\n    1. 代理对象和真实对象实现相同的接口<br>\n    2. 代理对象 = Proxy.newProxyInstance();<br>\n    3. 使用代理对象调用方法。<br>\n    4. 增强方法<br>\n    \n代理对象同样间接实现真实实现的接口，使用代理对象调用方法，在重写的InvocationHandler接口中再次调用method.invoke(真实对象, 方法参数)执行方法，如果方法有返回值要在invoke方法内完成return\n### 基于接口的动态代理\n```java\npublic class Client {\n    public static void main(String[] args) {\n        IProducer producer = new Producer();\n        /**\n         * newProxyInstance方法的参数：\n         *  ClassLoader：类加载器\n         *      用于加载代理对象的字节码文件，和被代理的对象使用相同的字节码（固定写法）\n         *  Class[]：字节码数组\n         *      用于让代理对象和被代理对象有相同的方法（固定写法）\n         *  invocationHandler：用于方法增强\n         *      匿名内部类\n         */\n        IProducer proxyInstance = (IProducer) Proxy.newProxyInstance(producer.getClass().getClassLoader(), producer.getClass().getInterfaces(), new InvocationHandler() {\n            /**\n             * 执行代理对象的任何方法都会经过该方法\n             * @param proxy 代理对象的引用\n             * @param method 执行的方法\n             * @param args 方法的参数\n             * @return 代理对象方法的返回值\n             */\n            @Override\n            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n                if (\"sale\".equals(method.getName())) {\n                    return method.invoke(producer, (double) args[0] * 0.8);\n                }\n                return method.invoke(producer, args);\n            }\n        });\n        proxyInstance.sale((double) 5000);\n    }\n}\n```\n### java类的动态代理\n要通过第三方jar包实现<br>\n```java\npublic class Client2 {\n    public static void main(String[] args) {\n        Producer producer = new Producer();\n        /**\n         * Class：字节码，指定被代理对象的字节码\n         * Callback：对于方法的增强\n         *  一般写该接口的子类的实现类\n         */\n        Producer proxyProducer = (Producer) Enhancer.create(producer.getClass(), new MethodInterceptor() {\n            @Override\n            public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {\n                if (\"sale\".equals(method.getName())) {\n                    return method.invoke(producer, (double) args[0] * 0.8);\n                }\n                return method.invoke(producer, args);\n            }\n        });\n        proxyProducer.sale((double) 800);\n    }\n}\n```\n\n### 通过Filter和代理模式过滤文字\n两个request其实是同一个，哈希值相同<br>\n首先通过filter进行拦截，放行之前更改request对象（使用它的代理对象调用方法），通过在内部修改返回值达到过滤目的<br>\n\n```\ngraph LR\n浏览器发起request请求-->Filter进行拦截,修改返回值\nFilter进行拦截,修改返回值-->访问Servlet\n```\n#### Filter\n```java\npackage filter;\n\nimport javax.servlet.*;\nimport javax.servlet.annotation.WebFilter;\nimport javax.servlet.http.HttpServletRequest;\nimport java.io.IOException;\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\nimport java.util.ArrayList;\nimport java.util.List;\n\n@WebFilter(\"/*\")\npublic class FilterWorlds implements Filter {\n    public void destroy() {\n    }\n\n    public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException {\n        System.out.println(req);\n        ServletRequest proxyRequest = (ServletRequest) Proxy.newProxyInstance(req.getClass().getClassLoader(), req.getClass().getInterfaces(), new InvocationHandler() {\n            @Override\n            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n                if (\"getParameter\".equals(method.getName())) {\n                    //对特定方法更改\n                    String string = (String) method.invoke(req, args);\n                    if (string != null)\n                        for (String str : stringList) {\n                            if (string.contains(str)) {\n                                return string.replace(str, \"***\");\n                            }\n                        }\n                    return string;\n                } else {\n                    //不进行更改\n                    return method.invoke(req, args);\n                }\n            }\n        });\n        chain.doFilter(proxyRequest, resp);\n    }\n\n    private List<String> stringList = new ArrayList<>();\n\n    public void init(FilterConfig config) throws ServletException {\n        stringList.add(\"混蛋\");\n        stringList.add(\"坏蛋\");\n    }\n\n}\n```\n#### servlet\n```java\npackage filter;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\n@WebServlet(\"/testServlet\")\npublic class TestServlet extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        System.out.println(request);\n        String world = request.getParameter(\"world\");\n        System.out.println(world);\n    }\n\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        this.doPost(request, response);\n    }\n}\n```',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2020-04-13 11:40:13','2020-11-29 11:45:12',0),(109,'工厂模式','[TOC]\n## 作用\n工厂模式可以用来解耦合<br>\n通常来说我们在创建一个对象的时候是直接new出来的<br>\n```java\nObject object = new Object();\n```\n然而通过反射我们也能把它搞出来<br>\n```java\nClass<?> aClass Class.forName(\"全限定类名\");\nObject object = aClass.newInstance();\n```\n工厂模式用到了相同的思想<br>\n### IOC Inversion of Control\n控制反转（Inversion of Control，缩写为IoC），是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度——将自己的控制权交给工厂<br>\n```\ngraph LR\nA[对象工厂]-->|通过对象的全限定类名加载对象|B[对象]\n```\n\n## 创建工厂\n我们可以使用工厂来创建对象，这样就可以不用把它new出来了<br>\n我们可以使用配置文件的方式获取全限定类名<br>\n```java\npackage factory;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Properties;\n\npublic class BeanFactory {\n    private static Properties properties;\n\n    static {\n        properties = new Properties();\n        InputStream inputStream = BeanFactory.class.getClassLoader().getResourceAsStream(\"bean.properties\");\n        System.out.println(inputStream);\n        try {\n            properties.load(inputStream);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static Object getBean(String beanName) throws ClassNotFoundException, IllegalAccessException, InstantiationException {\n        String name = properties.getProperty(beanName);\n        System.out.println(name);\n        Class<?> aClass = Class.forName(name);\n        return aClass.newInstance();\n    }\n}\n```\n\n## 获取配置文件(getResource)\n在获取配置文件的时候不应该直接把路径直接写出来，而要充分使用classes文件夹，可以使用类.getClass的方式<br>\n```java\nInputStream inputStream = 类名.class.getClassLoader().getResourceAsStream(\"Path\");\n```\nClassLoader负责载入系统的所有Resources（Class，文件，来自网络的字节流 等），通过ClassLoader从而将资源载入JVM<br>\n还可以不使用ClassLoader\n```java\nInputStream inputStream = 类名.getResourceAsStream(\"/PAth\");\n```\n### ClassLoader\n分为三层：<br>\nBootstrap ClassLoader是用C++编写的，在Java中看不到它，是null。它用来加载核 心类库，就是在lib下的类库。<br>\nExtension ClassLoader加载lib/ext下的类库。<br>\nApp ClassLoader加载 Classpath里的类库。<br>\n==核心类库在Java中是获取不到的<br>==\n使用的是委托加载机制：<br>\n![image](https://segmentfault.com/img/remote/1460000008491603?w=807&h=563)',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2020-04-11 11:17:15','2020-11-29 11:45:12',0),(110,'异常处理','### 捕获异常\n```java\npublic class Demon01 {\n    public static void main(String[] args) {\n        // Ctrl + Alt + T\n        try {\n            System.out.println(1 / 0);\n        } catch (ArithmeticException e) {\n            System.out.println(\"除数不能为0\");\n            //e.printStackTrace();    //输出系统异常\n        } finally {\n            System.out.println(\"结束\");   //用于善后工作\n        }\n    }\n}\n```\n### 抛出异常\n```java\npublic class Demon01 {\n    public static void main(String[] args) {\n        try {\n            new Demon01().division(1,0);\n        } catch (Exception e) { //异常被捕获程序还能继续走\n            e.printStackTrace();\n        }\n        System.out.println(\"程序可以继续执行\");\n    }\n\n    public void division(int a,int b){\n        if (b==0){\n            throw new ArithmeticException();\n        }\n        //return a/b;\n    }\n}\n```\n### 自定义异常\n1.首先写一个异常类继承Exception<br>\n2.重写toString方法<br>\n```java\npublic class Demon01 {\n    public static void main(String[] args) {\n        int a = 11;\n        if (a > 10) {\n            try {\n                throw new MyException(a);\n            } catch (MyException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n\nclass MyException extends Exception {\n    private int detail;\n\n    public MyException(int detail) {\n        this.detail = detail;\n    }\n\n    //异常信息的输出信息\n    @Override\n    public String toString() {\n        return \"MyException{\" + \"detail = \" +\n                detail + \" > 10\" +\n                \'}\';\n    }\n}\n```',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2020-01-12 19:50:32','2020-11-29 11:45:12',0),(111,'接口','接口可以多继承\n```java\npublic interface MyInterface {\n    public static final int A = 10; //常量\n    public abstract void method1();\n    public abstract void method2();\n    //静态方法\n    public static void method3(){\n        System.out.println(\"hello\");\n    }\n    //默认接口方法 JDK9 有静态默认方法\n    public default void method4(){\n        System.out.println(\"method4\");\n    }\n}\n```',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2020-01-15 23:02:50','2020-11-29 11:45:12',0),(112,'面向对象','[TOC]\n### 什么是面向对象\nObject Oriented Programming<br>\n面向对象的本质：以类的形式组织代码，以对象的形式封装数据<br>\n#### 封装<br>\n代码在一起<br>\nprivate用于改为私有方法或属性\n#### 继承<br>\nJava中没有多继承<br>\n在有继承关系的类进行实例化的过程中，首先掉用父类的构造器，然后再调用子类的构造器<br>\n```java\npublic class Demon01 {\n    public static void main(String[] args) {\n        Son son = new Son();\n    }\n}\n\nclass Father{\n    private  String name;\n    private int age;\n\n    //构造器\n    public Father() {\n        System.out.println(\"父类初始化\");\n    }\n}\n\nclass Son extends Father{\n    private String name;\n\n    //构造器\n    public Son(){\n        super();    //隐藏的父类初始化代码\n        System.out.println(\"子类初始化\");\n    }\n}\n```\nsuper注意点：<br>\n    1.super调用父类的构造方法，必须在构造方法的第一个<br>\n    2.super必须只能出现在子类的方法或构造方法中<br>\n    3.super和this不能同时调用构造方法<br>\n    this() 本类的构造<br>\n    super() 父类的构造<br>\n#### 多态\n==多态指的是将子类当作父类看待==<br>\n父类的引用指向子类<br>\n成员变量：编译看左边，运行还看左边<br>\n成员方法：编译看左边，运行看右边<br>\n```java\nFather father = new Son()\n```\n\n```java\npublic class Demon01 {\n    public static void main(String[] args) {\n        Student p1 = new Student();\n        //指向的引用类型不确定：父类的引用指向子类\n        Person p2 = new Student();\n        Object p3 = new Student();\n\n        System.out.println(p1.name);\n        System.out.println(p2.name);\n        //对象执行哪些方法主要与右边有关\n        p1.eat();\n        p2.eat();   //由于父类的方法在子类中被重写，所以使用子类的方法\n        ((Student) p2).study(); //不能调用子类独有的方法\n\n    }\n}\n\nclass Person {\n    String name = \"Father\";\n    public void eat() {\n        System.out.println(\"Person eat\");\n    }\n\n}\n\nclass Student extends Person {\n    String name = \"Son\";\n    @Override\n    public void eat() {\n        System.out.println(\"Student eat\");\n    }\n\n    public void study() {\n        System.out.println(\"Student study\");\n    }\n}\n```\n\n### 构造器\n#### 特点\n1.和类名相同<br>\n2.没有返回值\n#### 作用\n1.new 本质为调用构造器方法<br>\n2.初始化对象的值（有点像python中的__init__方法）<br>\n#### 注意点\n如果定义有参构造之后需要进行无参构造需要进行方法重构<br>\nAlt + Insert<br>\n\n```java\npublic class Demon01 {\n    public static void main(String[] args) {\n        Person person = new Person(\"Roderick Xiang\");\n        System.out.println(person.name);\n    }\n\n}\nclass Person{\n    String name;\n    int age;\n\n    //构造器（无参数）\n    public Person() {\n    }\n\n    //构造器（有参数）\n    public Person(String name) {\n        this.name = name;\n    }\n}\n```\n\n### 静态方法和非静态方法\n静态方法类似于python中的类方法，它和类一起加载，在使用的时候不需要实例化<br>\n写一个python中的工具类<br>\n```java\npublic class Demon01 {\n    public static void main(String[] args) {\n        Tool tool1 = new Tool(\"榔头\");\n        Tool tool2 = new Tool(\"锤子\");\n        System.out.println(Tool.number);\n    }\n}\n\nclass Tool{\n    String name;\n    static int number = 0;\n\n    public Tool(String name) {\n        this.name = name;\n        Tool.tollCount();\n    }\n\n    //静态方法（类方法）\n    public static void tollCount(){\n        Tool.number++;\n    }\n}\n```\n```java\npublic class Demon{\n\n    //和类一起加载\n    public static void a(){\n        //方法体\n    }\n    \n    //类实例化时加载\n    public void b(){\n        //方法体\n    }\n}\n```\n由于非静态方法不和类一起加载，所以在mian方法使用前因进行实例化操作\n```java\npublic class Demon01 {\n    public static void main(String[] args) {\n        Demon01 Demon01 = new Demon01();\n        Demon01.a();\n    }\n    public void a(){\n        System.out.println(\"hello\");\n    }\n}\n```\n#### 静态代码块和非静态代码块\n当实例化对象发生时：<br>\n1.静态代码块（只加载一次）<br>\n2.匿名代码块<br>\n3.构造器初始化<br>\n```java\npublic class Main {\n\n    //2.\n    {\n        System.out.println(\"匿名代码块\");\n    }\n\n    //1.（只运行一次）\n    static {\n        System.out.println(\"静态代码块\");\n    }\n\n    //3.\n    public Main() {\n        System.out.println(\"构造器初始化\");\n    }\n\n    public static void main(String[] args) {\n        Main main = new Main();\n\n    }\n}\n```\n### 图画描述面向对象过程\n![image](https://note.youdao.com/yws/api/personal/file/3CC310AD1ECE469DB3651B42CFF4A012?method=download&shareKey=a369f26662a486b5d706ab57df9b6983)\n```java\npublic class Demon01 {\n    public static void main(String[] args) {\n        Pet dog = new Pet(\"Gou\");\n        Pet cat = new Pet(\"Mao\");\n\n        dog.age = 10;\n        cat.age = 11;\n\n        //调用方法\n        System.out.println(dog.getName());\n        System.out.println(cat.getName());\n\n    }\n}\n\nclass Pet {\n    String name;\n    int age;\n\n    public Pet(String name) {\n        this.name = name;\n    }\n\n    public void eat() {\n        System.out.println(this.name + \"吃东西\");\n    }\n\n    public String getName() {\n        return this.name;\n    }\n\n    public int getAge() {\n        return this.age;\n    }\n\n}\n```\n### 方法的重写\n当父类的功能不能满足，子类的需求时我们进行方法的重写<br>\n1.方法名必须与父类相同<br>\n2.参数列表相同<br>\n3.修饰符范围可以缩小，不能扩大<br>\n4.抛出异常的范围可以缩小，不能扩大<br>\n```java\npublic class Demon01 {\n    public static void main(String[] args) {\n        Son son = new Son();\n        Father father = new Father();\n        father.eat();\n    }\n}\n\nclass Father {\n    private String name;\n    private int age;\n\n    //构造器\n    public Father() {\n        System.out.println(\"父类初始化\");\n    }\n\n    public void eat() {\n        System.out.println(\"父类吃\");\n    }\n}\n\nclass Son extends Father {\n    private String name;\n\n    //构造器\n    public Son() {\n        super();    //隐藏的父类初始化代码\n        System.out.println(\"子类初始化\");\n    }\n\n    public void eat() {\n        System.out.println(\"子类吃\");\n    }\n}\n```\n### 引用传递和值传递\n==在Java中只有值传递==<br>\n在下面的例子中表面上有引用传递，但实际上a是一个对象（已经经历了实例化的过程）<br>\n```java\npublic class Demon01 {\n    public static void main(String[] args) {\n        int[] a = new int[3];\n        change(a);\n        System.out.println(a[0]);   //输出100\n    }\n\n    public static void change(int[] a) {\n        a[0] = 100;\n    }\n}\n```\n### 类之间的类型转换\n基础类型之间可以进行类型转换，类之间也可以进行类型转换<br>\n低 --> 高 自动转换，高 --> 低 强制转换<br>\n\n```java\npublic class Demon01 {\n    public static void main(String[] args) {\n        //父类的类型，引用指向子类\n        Father father = new Son();\n        Son son = new Son();\n\n        //低 --> 高 自动转换，高 --> 低 强制转换\n        father.eat();   //由于子类重写了父类的方法，所以调用子类方法\n        father.work();\n        ((Son) father).run();   //父类没有子类方法，需要进行类型转换\n\n        //子类转化为父类，子类的方法会丢失\n        Father f2 = son;\n        ((Son) f2).run();\n    }\n}\n\nclass Father {\n    public void eat() {\n        System.out.println(\"Father eat\");\n    }\n\n    public void work() {\n        System.out.println(\"Father work\");\n    }\n}\n\nclass Son extends Father {\n    public void eat() {\n        System.out.println(\"Son eat\");\n    }\n\n    public void run() {\n        System.out.println(\"Son run\");\n    }\n}\n```\n### 抽象类\n1.不能new这个抽象类，只能靠它的子类实现<br>\n2.抽象类中可以写普通方法<br>\n3.抽象方法必须在抽象类中<br>\n抽象类存在构造器<br>\n```java\npublic class Main {\n    public static void main(String[] args) {\n        //抽象类不能使用new被实例化\n        B b = new B();\n        b.print();\n    }\n}\n\n\n//abstract修饰抽象类\nabstract class A {\n    public abstract void doSomeThing();\n\n    public A() {\n        System.out.println(\"构造器\");\n    }\n\n    public void print() {\n        System.out.println(\"Hello\");\n    }\n}\n\nclass B extends A {\n    //继承抽象类都必须要实现它的方法，除非再写抽象类交给子子类实现\n    @Override\n    public void doSomeThing() {\n        //方法体\n    }\n}\n```\n### 接口\n抽象类的延伸<br>\n定义一些方法，让不同的人实现<br>\n接口不能被实例化，接口中没有构造方法<br>\nimplement可以实现多个接口，可以实现伪多继承<br>\n```java\npublic class Main {\n    public static void main(String[] args) {\n        AImpl test = new AImpl();\n        test.add();\n    }\n}\n\ninterface A {\n    //接口中定义的抽象常量（一定是常量）\n    public static final int AGE = 10;\n\n    //接口中定义的抽象方法\n    public abstract void add();\n\n    void delete();\n\n    void change();\n\n    void search();\n\n}\n\ninterface B {\n    void doSomeThing();\n}\n\n\n//接口的实现（重写接口中定义的方法）\nclass AImpl implements A, B {\n    @Override\n    public void add() {\n        System.out.println(\"add\");\n    }\n\n    @Override\n    public void delete() {\n\n    }\n\n    @Override\n    public void change() {\n\n    }\n\n    @Override\n    public void search() {\n\n    }\n\n    @Override\n    public void doSomeThing() {\n\n    }\n}\n```\n### 内部类\n```java\npublic class Main {\n    public static void main(String[] args) {\n        Out out = new Out();\n        Out.Inner inner = out.new Inner();\n        inner.print();\n        //内部类可以调用外部类的私有属性或方法\n        System.out.println(inner.getA());\n    }\n}\n\nclass Out {\n    private int a = 10;\n\n    public void print() {\n        System.out.println(\"外部类\");\n    }\n\n    class Inner {\n        void print() {\n            System.out.println(\"内部类\");\n        }\n\n        int getA(){\n            return a;\n        }\n    }\n}\n```\n### instanceof\n判断是否有实例关系（它是不是它的实例对象）<br>\nresult = object instanceof class<br>\n在编译状态中，class可以是object对象的父类，自身类，子类。在这三种情况下Java编译时不会报错。\n在运行转态中，class可以是object对象的父类，自身类，不能是子类。在前两种情况下result的结果为true，最后一种为false。但是class为子类时编译不会报错。运行结果为false。 （大致就是判断表达式：class 变量=(class)object的引用 是否成立）。\n```java\nson instanceof Fatehr;\n```',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2020-03-03 12:43:14','2020-11-29 11:45:12',0),(113,'Java贪吃蛇','<!-- TOC -->\r\n\r\n- [一切先从核心玩法开始](#一切先从核心玩法开始)\r\n    - [如何运动](#如何运动)\r\n    - [控制蛇头的方向](#控制蛇头的方向)\r\n- [游戏界面](#游戏界面)\r\n    - [绘制游戏内容](#绘制游戏内容)\r\n    - [让一切都动起来](#让一切都动起来)\r\n    - [获取键盘事件](#获取键盘事件)\r\n- [游戏功能实现](#游戏功能实现)\r\n    - [穿墙效果](#穿墙效果)\r\n    - [蛇的身子变长（重点）](#蛇的身子变长重点)\r\n    - [碰撞检测](#碰撞检测)\r\n    - [检测吃食物](#检测吃食物)\r\n    - [计分系统](#计分系统)\r\n\r\n<!-- /TOC -->\r\n### 一切先从核心玩法开始\r\n首先贪吃蛇的运动是发生在一个规范的矩阵中，而矩阵中的每一方格就是蛇的身子，而蛇的运动就是一次一次更新正方形的位置，然后通过panel绘制上去<br>\r\n所以我们使用两个数组来储存贪吃蛇的位置,snakeX用来储存横坐标，而snakeY用来储存纵坐标的位置<br>\r\n```java\r\n//贪吃蛇初始的位置（一个头，两个身子）\r\npublic Snake() {\r\n        snakeX[0] = 400;\r\n        snakeY[0] = 400;\r\n        snakeX[1] = 380;\r\n        snakeY[1] = 400;\r\n        snakeX[2] = 360;\r\n        snakeY[2] = 400;\r\n    }\r\n```\r\n#### 如何运动\r\n我们只要更新蛇的位置就能让它动起来了，所以我们定义两个速度\"speedX\"和\"speedY\"用来控制头的位置<br>\r\n只动了头并没有用，还有身子，我们只需要用从尾巴开始使用循环继承上一个身体的位置，知道继承头部位置<br>\r\n```java\r\n    public void move() {\r\n        //身体跟着头走\r\n        for (int i = length - 1; i > 0; i--) {\r\n            snakeX[i] = snakeX[i - 1];\r\n            snakeY[i] = snakeY[i - 1];\r\n        }\r\n        snakeX[0] += speedX;\r\n        snakeY[0] += speedY;\r\n        isTmpMove = true;\r\n        checkBoundaries();\r\n        System.out.format(\"%d %d\\n\", snakeX[0], snakeY[0]);\r\n    }\r\n```\r\n#### 控制蛇头的方向\r\n为了跟好的控制小蛇，直接控制蛇头来的最为直接。但是这里有一个会产生BUG的点，蛇头不能做反方向运动，所以我们还要给蛇头添加一个方向\"direction\"属性，只有当按键按下和方向条件满足时才能改变蛇头的运动方向<br>\r\n```java\r\npublic void changeDirection(KeyEvent e) {\r\n    if (e.getKeyCode() == KeyEvent.VK_UP && !direction.equals(\"down\")) {\r\n        direction = \"up\";\r\n        speedX = 0;\r\n        speedY = -20;\r\n    } else if (e.getKeyCode() == KeyEvent.VK_DOWN && !direction.equals(\"UP\")) {\r\n        direction = \"down\";\r\n        speedX = 0;\r\n        speedY = 20;\r\n    } else if (e.getKeyCode() == KeyEvent.VK_RIGHT && !direction.equals(\"left\")) {\r\n        direction = \"right\";\r\n        speedX = 20;\r\n        speedY = 0;\r\n    } else if (e.getKeyCode() == KeyEvent.VK_LEFT && !direction.equals(\"right\")) {\r\n        direction = \"left\";\r\n        speedX = -20;\r\n        speedY = 0;\r\n    }\r\n    isTmpMove = false;\r\n}\r\n```\r\n### 游戏界面\r\n游戏界面我们使用Jframe来实现（我好方便实现关闭功能）<br>\r\n写一个类类继承Jframe，在里面添加面板并且进行初始化设置<br>\r\n```java\r\npublic class MyFrame extends JFrame {\r\n    public void init() {\r\n        JFrame frame = new JFrame();\r\n        setTitle(\"贪吃蛇\");\r\n        setResizable(false);\r\n        setBounds(300,100,865,830); //840 *780 （界面的大小一定要设置正确）\r\n        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\r\n\r\n        //添加Panel\r\n        GamePanel panel = new GamePanel();\r\n        add(panel);\r\n        setVisible(true);\r\n    }\r\n}\r\n```\r\n#### 绘制游戏内容\r\n已经添加了JPanal（GamePanel）,所以到Jpanal中添加游戏中需要绘制的内容<br>\r\n在Jpanal中重写paintComponent就能在实例化Jpanal时使用画笔绘制图像（方法自行被调用），这个类也是作为游戏的主类<br>\r\n```java\r\nclass MyPaint extends JPanel {}\r\n    @Override\r\n    protected void paintComponent(Graphics g) {\r\n        super.paintComponent(g);    //清屏\r\n        g.setColor(Color.BLACK);\r\n        g.fillRect(100,100,100,100);\r\n        //绘制所有的功能，省略不写......\r\n    }\r\n}\r\n```\r\n所以有这个就能画小蛇了！<br>\r\n#### 让一切都动起来\r\n为了有运动的效果，我们使用循环实现，这里我们使用ActionListener（函数式接口）用作定时器，我们实现一下接口里面的actionPerformed方法在方法里写需要定时执行的事件。定时器使用timer.start()开启<br>\r\n```java\r\n//执行定时操作\r\n@Override\r\npublic void actionPerformed(ActionEvent e) {\r\n    snake.move();\r\n    snake.checkEatFood(food);\r\n    food.changeFoodPosition();  //更改食物的位置\r\n    snake.checkCollide();   //碰撞检测\r\n    repaint();  //重新绘制图像\r\n}\r\n```\r\n#### 获取键盘事件\r\n实现KeyListener接口来进行事件监听<br>\r\n使用之间还要设置监听<br>\r\n```java\r\nJPanal.setFocusable(true); //设置监听焦点\r\nJpanal.addKeyListener(this);   //添加键盘监听事件\r\n接口中有三个抽象方法<br>\r\n```\r\n```java\r\npublic void keyPressed(KeyEvent e) {\r\n    int keycode = e.getKeyCode();\r\n    if (keycode == KeyEvent.VK_SPACE) {\r\n        isStart = !isStart;\r\n        if (isStart) {\r\n            timer.start();\r\n        }\r\n    } else if (snake.isTmpMove) {   //判断小蛇是否移动，避免蛇头折回\r\n        snake.changeDirection(e);\r\n    }\r\n    repaint();\r\n}\r\n```\r\n### 游戏功能实现\r\n#### 穿墙效果\r\n```java\r\npublic void checkBoundaries() {\r\n    if (snakeX[0] > 840) {\r\n        snakeX[0] = 0;\r\n    } else if (snakeX[0] < 0) {\r\n        snakeX[0] = 840;\r\n    } else if (snakeY[0] > 780) {\r\n        snakeY[0] = 0;\r\n    } else if (snakeY[0] < 0) {\r\n        snakeY[0] = 780;\r\n    }\r\n}\r\n```\r\n#### 蛇的身子变长（重点）\r\n我们让小蛇的尾部变长而不是头部，所以要参考蛇身最后的参数，并且获取速度<br>\r\n速度使用前坐标减后左边产生的差值得到<br>\r\n增加的位置通过蛇尾减速度得到<br>\r\n```java\r\npublic void getLonger(Food food) {\r\n    if (food.isEat) {\r\n        Point.getNormalFoodPoint();\r\n        snakeX[length] = snakeX[length - 1] - (snakeX[length - 2] - snakeX[length - 1]);\r\n        snakeY[length] = snakeY[length - 1] - (snakeY[length - 2] - snakeY[length - 1]);\r\n        length++;\r\n    } else if (food.isBonusEat) {\r\n        Point.getBonusFoodPoint();\r\n        snakeX[length] = snakeX[length - 1] - (snakeX[length - 2] - snakeX[length - 1]);\r\n        snakeY[length] = snakeY[length - 1] - (snakeY[length - 2] - snakeY[length - 1]);\r\n        length++;\r\n        food.isBonusEat = false;\r\n    }\r\n}\r\n```\r\n#### 碰撞检测\r\n遍历除了蛇头以外的位置,当坐标有相同的时候停止游戏<br>\r\n```java\r\npublic void checkCollide() {\r\n    for (int i = 1; i < length; i++) {\r\n        if (snakeX[i] == snakeX[0] && snakeY[i] == snakeY[0]) {\r\n            GamePanel.isDead = true;\r\n            System.out.format(\"%d %d %d %d\\n\", snakeX[i], snakeY[i], snakeX[0], snakeY[0]);\r\n            break;\r\n        }\r\n    }\r\n}\r\n```\r\n#### 检测吃食物\r\n判断头部位置是否与食物重叠就行<br>\r\n特殊食物还需要判断下是否存在<br>\r\n```java\r\npublic void checkEatFood(Food food) {\r\n    if (snakeX[0] == food.normalX && snakeY[0] == food.normalY) {\r\n        food.isEat = true;\r\n        getLonger(food);\r\n    } else if (snakeX[0] == food.bonusX && snakeY[0] == food.bonusY && food.hasBonus) {\r\n        food.isBonusEat = true;\r\n        food.hasBonus = false;\r\n        getLonger(food);\r\n    }\r\n}\r\n```\r\n#### 计分系统\r\n使用BufferReader和BufferWriter读写记录，获取最高分<br>\r\n```java\r\npublic static void writeResult() throws IOException {\r\n    BufferedWriter bw = new BufferedWriter(new FileWriter(\"记录.txt\", true));\r\n    bw.write(\"player\" + \"\\t\" + point);\r\n    bw.newLine();\r\n    bw.close();\r\n}\r\npublic static void readBestResult() throws IOException {\r\n    BufferedReader br = new BufferedReader(new FileReader(\"记录.txt\"));\r\n    String line;\r\n    int score;\r\n    while ((line = br.readLine()) != null) {\r\n        String[] tmp = line.split(\"\\t\");\r\n        score = Integer.parseInt(tmp[1]);\r\n        if (score > bestScore) {\r\n            bestScore = score;\r\n        }\r\n    }\r\n}\r\n```',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2020-02-16 22:01:37','2020-11-29 11:45:12',0),(114,'用户信息列表展示','[TOC]\n## 整体框架\n为了保证不滥用jsp所以采用三层框架，分别为页面展示层，逻辑操作层，和数据库访问层(Database Access Object)，其实简单的增删改查的操作都可以交给数据库，所以基本上没有什么逻辑操作。<br>\n对于数据的操作为了在未来更好的添加功能使用实现接口的方式，UserServices和AdministratorService<br>\n## 用户数据\n对于查询的数据使用User对象的方式进行封装，在直接获取属性就行<br>\n```java\n    private int id;\n    private String name;\n    private String gender;\n    private int age;\n    private String address;\n    private String qq;\n    private String email;\n```\n## 重要功能实现\n### 管理员登入\n```\ngraph LR\n浏览器发起request请求-->servlet{Servlet进行判断}\nservlet{Servlet进行判断}--有loginAdministrator返回值-->允许访问index.jsp\nservlet{Servlet进行判断}--没有,转发错误信息-->login.jsp\n```\n登入在数据库中需要一张管理员的表，同样封装管理员对象<br>\n```java\n    private String username;\n    private String password;\n```\n首先通过jsp页面展示html和验证码（通过CheckCodeServlet获取），老样子还是先判断激活码。<br>\n#### 过滤器(Filter)\n当实现登入功能的时候就会惊奇的发现，可以直接输入别的网址就能跳过登入界面了，所以在这里需要一个Filter，它会检查所有访问的请求<br>\n1.排除登入所需要的资源（servlet jsp js之类的资源）<br>\n2.检查请求的session中是否含有user这个属性<br>\n\n```\ngraph TD\n    A[来自浏览器的请求] --> C{Fliter进行拦截是否含有user属性}\n    C -->|有| D[放行]\n    C -->|无| E[转发到登入页面]\n```\n### 分页查询所有用户数据\n**SQL:selset * from person_data**（不完整）<br>\n由于要实现分页的要求所以前端与后端要进行一些数据的交换以达到效果，这里通过封装一个pageBean<br>\n```java\n    private int totalCount; //总记录数  （数据库）\n    private int totalPage;  //总页码数  （数据库）\n    private List<T> list;  //每页的数据 （数据库返回）\n    private int currentPage;    //当前的页码    （前端）\n    private int rows;   //每页显示的记录数  （servlet规定）\n```\n通过这些数据就能得知每一页应该显示什么内容<br>\n这里稍微画一下图表明一下三层架构：\n```\ngraph LR\n    Servlet-->UserService\n    UserService-->UserDao\n```\n### 增加新的数据\n**SQL:insert into person_data values(null,?,?,?,?,?,?)**<br>\n```java\nString sql = \"insert into person_data values(null,?,?,?,?,?,?)\";\njdbcTemplate.update(sql,\n        newUser.getName(), newUser.getGender(), newUser.getAge(), newUser.getAddress(), newUser.getQq(), newUser.getEmail());\n```\n在这里只需要获取来自前端表单提交的数据，再提交给服务器就行<br>\n直接使用BeanUtils做封装，减少代码量<br>\n```java\n    Map<String, String[]> map = request.getParameterMap();\n    User newUser = new User();\n    //自动封装\n    try {\n        BeanUtils.populate(newUser, map);\n    } catch (IllegalAccessException | InvocationTargetException e) {\n        e.printStackTrace();\n    }\n```\n### 更改用户数据\n**SQL:update person_data set name = ?,gender = ?,age = ?,address = ?,qq = ?,email = ? where id = ?**<br>\n```java\npublic void updateUser(User user) {\n    String sql = \"update person_data set name = ?,gender = ?,age = ?,address = ?,qq = ?,email = ? where id = ?\";\n    jdbcTemplate.update(sql,\n            user.getName(), user.getGender(), user.getAge(), user.getAddress(), user.getQq(), user.getEmail(), user.getId());\n}\n```\n这个要比新添加一个要难一些，而且要实现**回显用户的数据**，所以逻辑会稍微有点复杂<br>\n```\ngraph LR\n    list.jsp--传递id-->FindUserServlet\n    FindUserServlet--转发User数据-->updata.jsp\n    updata.jsp--传递User数据-->UpdataUserServlet\n    UpdataUserServlet--重定项-->ListUserByPageServlet\n```\n在第二次传递User数据的时候会发现表单中并没有id这个属性，所以这里耍个小聪明，在表单中隐藏id，有了id才能在数据库中做修改<br>\n```jsp\n<%--隐藏的id信息--%>\n<input type=\"hidden\" name=\"id\" value=\"${requestScope.user.id}\">\n```\n\n### 删除用户数据\n**SQL:delete from person_data where id = ?**<br>\n#### 单独删除\n这个好说，拿到id就行<br>\n#### 多选删除\n这个功能使用了另一个DeleteSelectedUserServlet完成<br>\n实现步骤：<br>\n前端使用form表单提交本页的userId数据，判断是否被选择<br>\n```html\n<form action=\"${pageContext.request.contextPath}/deleteSelectedUserServlet\" method=\"post\" id=\"form\">\n    <td><input type=\"checkbox\" name=\"userId\" value=\"${user.id}\"></td>\n</form>\n```\n只有被勾选才能id发送到到servlet，从而在servlet端接收参数数组<br>\n```html\n    <script>\n        window.onload = function () {\n            document.getElementById(\"deleteSelected\").onclick = function () {\n                let ids = document.getElementsByName(\"userId\");\n                let allowToDelete = false;\n                // 判断选择框是否有勾选\n                for (let i = 0; i < ids.length; i++) {\n                    if (ids[i].checked === true) {\n                        allowToDelete = true;\n                    }\n                }\n                if (!allowToDelete) {\n                    alert(\"没有选中任何用户，请选择用户后提交\")\n                } else if (confirm(\"是否要删除所选吗？\")) {\n                    document.getElementById(\"form\").submit();\n                }\n            };\n            document.getElementById(\"firstCheckbox\").onclick = function () {\n                let ids = document.getElementsByName(\"userId\");\n                for (let i = 0; i < ids.length; i++) {\n                    ids[i].checked = this.checked;\n                }\n            }\n        }\n    </script>\n```\n\n### 分页查询用户数据\n#### SQL语句\n**SQL:select * from person_data where 1 = 1 and key(name) like \'%模糊查找%\' [and key(name) like \'%模糊查找%\'] limit start rows**<br>\n在这里又要实现用户的模糊查询，还要实现分页查询的功能就会比较麻烦<br>\n首先从sql开始说起：<br>\n1.由于模糊查询的条件有三个但是又不能写死，因为用户可以不填，而且还要进行分页，所以这里采用拼接sql的方式<br>\n2.查找的条件使用where 1 = 1 的方式这样可以直接在后面拼接，这个也算一个小技巧吧<br>\n3.由于有未知的参数，所以要一个参数列表，在里面添加参数，然后直接传入数组就行<br>\n```java\n    public List<User> findUserByPage(int start, int rows, Map<String, String[]> condition) {\n        String sql = \"select * from person_data where 1 = 1 \";\n        //拼接sql\n        StrBuilder sqlStrBuilder = new StrBuilder(sql);\n        List<Object> params = new ArrayList<>();    //参数列表\n        for (String key : condition.keySet()) {   //遍历条件\n            String value = condition.get(key)[0];\n            //排除不需要的参数\n            if (\"currentPage\".equals(key) || \"rows\".equals(key)) {\n                continue;\n            }\n            //判断有值\n            if (value != null && !\"\".equals(value)) {\n                sqlStrBuilder.append(\" and \").append(key).append(\" like ? \");\n                params.add(\"%\" + value + \"%\");\n            }\n        }\n        sqlStrBuilder.append(\" limit ?, ? \");\n        params.add(start);\n        params.add(rows);\n        return jdbcTemplate.query(sqlStrBuilder.toString(), new BeanPropertyRowMapper<>(User.class), params.toArray());\n    }\n```\n#### 核心实现\n这里的实现借助于分页列出所有用户的数据，在listUserByPage下添加一个condition的参数，在condition中含有 currentPage rows [name] [address] [email]<br>\n在dao中进行sql的处理需要用到condition<br>\n\n### 导航条\n上一页和下一页<br>\n```html\n<li>\n    <a href=\"${pageContext.request.contextPath}/listUserByPageServlet?currentPage=${requestScope.pageBean.currentPage - 1}&rows=${requestScope.pageBean.rows}&name=${requestScope.condition.name[0]}&address=${requestScope.condition.address[0]}&email=${requestScope.condition.email[0]}\"\n       aria-label=\"Previous\">\n        <span aria-hidden=\"true\">&laquo;</span>\n    </a>\n</li>\n```\n显示现在的页面<br>\n```html\n<c:forEach begin=\"1\" end=\"${requestScope.pageBean.totalPage}\" step=\"1\" var=\"number\">\n    <%--设置激活状态--%>\n    <c:if test=\"${requestScope.pageBean.currentPage==number}\">\n        <li class=\"active\">\n            <a href=\"${pageContext.request.contextPath}/listUserByPageServlet?currentPage=${number}&rows=${requestScope.pageBean.rows}&name=${requestScope.condition.name[0]}&address=${requestScope.condition.address[0]}&email=${requestScope.condition.email[0]}\">${number}</a>\n        </li>\n    </c:if>\n    <c:if test=\"${requestScope.pageBean.currentPage!=number}\">\n        <li>\n            <a href=\"${pageContext.request.contextPath}/listUserByPageServlet?currentPage=${number}&rows=${requestScope.pageBean.rows}&name=${requestScope.condition.name[0]}&address=${requestScope.condition.address[0]}&email=${requestScope.condition.email[0]}\">${number}</a>\n        </li>\n    </c:if>\n\n</c:forEach>\n```',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2020-03-17 21:52:23','2020-11-29 11:45:12',0),(115,'车辆展示页面(SpringBoot练习)','[TOC]\n## 简介\nspringboot的练手项目，一个展示车辆性能的网站，将不同车辆的在纽伯格零的圈速排序展示在页面上，并且支持管理员对于成绩的管理，调用接口实现车辆识别。\n1. 项目简介展示\n2. SpringBoot介绍\n3. Thymleaf模板引擎\n4. SpringSecurity\n5. CRUD操作\n6. 百度接口\n7. AJAX发送数据\n8. 前端回显\n\n## 核心功能\n1. 对于车辆圈速的展示\n2. 简单的CRUD，实现对车辆成绩的增删改查\n3. 继承SpringSecurity实现登录\n4. 图片上传和前端回显 \n5. 调用百度智能接口实现车辆识别\n\n## 数据库设计\n数据库：<br>\n由于核心功能是比较圈速，所以核心是对时间的比较（因为要排序）\n在数据库中使用time(2)保留秒后两位<br>\n后端：<br>\n从前端接收字符串，然后转换为特定的日期格式入库\n```java\nlap_time = new SimpleDateFormat(\"mm:ss.SSS\").parse(lap_timestr);\n```\n入库：\n```xml\n<insert id=\"insertVehicle\" parameterType=\"com.roderick.pojo.Vehicle\" useGeneratedKeys=\"true\" keyProperty=\"id\">\n    insert into vehicle (model_name,lap_time,introduction)\n    value (#{model_name},#{lap_time},#{introduction})\n</insert>\n```\n\n## 难度功能具体实现\n### 文件上传以及前端回显\n#### 前端发送数据\n1. 使用post提交数据\n2. enctype=\"multipart/form-data\"\n3. input标签 type=\"file\" \n\n```html\n<form id=\"uploadForm\" method=\"post\" enctype=\"multipart/form-data\">\n    <div class=\"form-group insertFrom\">\n        <label for=\"file\">上传图片</label>\n        <input type=\"file\" name=\"file\" id=\"file\">\n    </div>\n    <button id=\"submit-btn\" class=\"btn btn-primary\" type=\"button\">提交</button>\n</form>\n```\n\n#### 后端接收数据\n后端接收：\n```java\n@PostMapping(\"/management/vehicleIdentification\")\n@ResponseBody\npublic String vehicleIdentification(@RequestParam(\"file\") MultipartFile file) throws IOException {\n    file.transferTo(new File(\"PATH\"))   //储存文件\n    return null;\n}\n```\n\n#### 前端回显图片（不经过后端）\n获取图片的src：\n```javascript\nfunction getObjectURL(file) {   //获取上传图片的地址生成零时文件（名称为uuid）\n    let url = null;\n    if (window.createObjectURL !== undefined) { // basic\n        url = window.createObjectURL(file);\n    } else if (window.URL !== undefined) { // mozilla(firefox)\n        url = window.URL.createObjectURL(file)\n    } else if (window.webkitURL !== undefined) { // webkit or chrome\n        url = window.webkitURL.createObjectURL(file);\n    }\n    return url;\n}\n```\n修改图片：\n```javascript\nlet $file = $(\"#file\");    //获取表单数据\nlet src = getObjectURL($file[0].files[0]);  //转化为DOM对象后，获取文件（使用jQuery对象无法进行操作）\n$(\"#image\").attr(\"src\", src)    //修改图片的src属性\n```\n\n### 防止明文密码泄露\n#### 导包\n```xml\n<!--加密组件-->\n<dependency>\n    <groupId>com.github.ulisesbocchio</groupId>\n    <artifactId>jasypt-spring-boot-starter</artifactId>\n    <version>3.0.2</version>\n</dependency>\n```\n\n#### 配置\n使用一个字符串作为解密密码\n```yml\njasypt:\n  encryptor:\n    password: Roderick  # 明文密码接管\n```\n\n#### 获取加密字符\n```java\n@Autowired\nStringEncryptor stringEncryptor;\n\n@Test\npublic void encryptTest() {\n    String admin = stringEncryptor.encrypt(\"admin\");    //加密\n    System.out.println(stringEncryptor.decrypt(admin)); //解密\n}\n```\n开始运行（配置了解密密码），可以直接从配置文件中获取解密的密码\n```java\n@Value(\"${baidu.SECRET_KEY}\")\nprivate String SECRET_KEY;\n```\n如果没有配置解密密码会导致无法解析ApplicationContext文件<br>',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2020-06-23 23:05:11','2020-11-29 11:45:12',0),(116,'JDBC','[TOC]\n### 简单入门（createStatement）\n```java\npackage mysql;\n\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\npublic class JDBC {\n    public static void main(String[] args) {\n        Connection connection = null;   //只能在try外面声明\n        Statement statement = null;\n\n        try {\n            //1.获取驱动\n            Class.forName(\"com.mysql.cj.jdbc.Driver\");\n            //2.得到链接\n            connection = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/db1\", \"root\", \"admin\");\n            String sql = \"insert into student(id,name,age,score,birthday,sex) value(2,\'小狗\',200,20,\'2000-10-16\',\'男\')\";\n\n            //3.得到用于执行sql的对象\n            statement = connection.createStatement();\n            //4.发送sql语句\n            int result = statement.executeUpdate(sql);\n            System.out.println(result);\n        } catch (ClassNotFoundException | SQLException e) {\n            e.printStackTrace();\n        } finally {\n            //5.资源释放（判断是否为null，以防空指针异常）\n            try {\n                if (statement != null)\n                    statement.close();\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n            try {\n                if (connection != null)\n                    connection.close();\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n```\n\n### 表查询\n```java\npackage mysql;\n\nimport java.sql.*;\n\npublic class JDBC {\n    public static void main(String[] args) {\n        Connection connection = null;   //只能在try外面声明\n        Statement statement = null;\n        ResultSet resultSet = null;\n\n        try {\n            //1.获取驱动\n            Class.forName(\"com.mysql.cj.jdbc.Driver\");\n            //2.得到链接\n            connection = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/db1\", \"root\", \"admin\");\n            String sql = \"select * from emp\";\n\n            //3.得到用于执行sql的对象\n            statement = connection.createStatement();\n            //4.发送sql语句\n            resultSet = statement.executeQuery(sql);\n\n            while (resultSet.next()) {\n                System.out.println(resultSet.getString(\"name\")); //方法重载\n            }\n\n        } catch (ClassNotFoundException | SQLException e) {\n            e.printStackTrace();\n        } finally {\n            //5.资源释放（判断是否为null，以防空指针异常）\n            try {\n                if (resultSet != null)\n                    resultSet.close();\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n            try {\n                if (statement != null)\n                    statement.close();\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n            try {\n                if (connection != null)\n                    connection.close();\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n\n        }\n    }\n}\n```\n### 防止sql注入（prepareStatement）\n```java\npackage mysql;\n\nimport java.sql.*;\n\npublic class JDBC {\n    public static void main(String[] args) {\n        Connection connection = null;   //只能在try外面声明\n        ResultSet resultSet = null;\n        PreparedStatement preparedStatement = null;\n\n        try {\n            //1.获取驱动\n            Class.forName(\"com.mysql.cj.jdbc.Driver\");\n            //2.得到链接\n            connection = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/db1\", \"root\", \"admin\");\n            String sql = \"select * from student\";\n            String str = \"student\";\n            //3.得到用于执行sql的对象\n            preparedStatement = connection.prepareStatement(sql);   //使用prepareStatement防止sql注入问题\n            //4.发送sql语句\n            resultSet = preparedStatement.executeQuery();   //执行数据可以不用传递参数，因为在此之前就要进行sql语句的处理\n\n            while (resultSet.next()) {\n                System.out.println(resultSet.getString(\"name\")); //方法重载\n            }\n\n        } catch (ClassNotFoundException | SQLException e) {\n            e.printStackTrace();\n        } finally {\n            //5.资源释放（判断是否为null，以防空指针异常）\n            try {\n                if (resultSet != null)\n                    resultSet.close();\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n            try {\n                if (preparedStatement != null)\n                    preparedStatement.close();\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n            try {\n                if (connection != null)\n                    connection.close();\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n\n        }\n    }\n}\n```\n### 使用setAutoCommitment开启事务\n转账业务模拟\n```java\npackage mysql;\n\nimport java.sql.*;\n\npublic class Bank {\n    public static void main(String[] args) {\n        Connection connection = null;\n        PreparedStatement preparedStatement1 = null;    //继承了statement\n        PreparedStatement preparedStatement2 = null;\n        try {\n            Class.forName(\"com.mysql.cj.jdbc.Driver\");\n            connection = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/db1\", \"root\", \"admin\");\n            String sql1 = \"update bank set balance = balance + ? where name = ?\";\n            String sql2 = \"update bank set balance = balance + ? where name = ?\";\n\n            //开启事务\n            connection.setAutoCommit(false);\n\n            preparedStatement1 = connection.prepareStatement(sql1);\n            preparedStatement2 = connection.prepareStatement(sql2);\n\n            //处理sql\n            preparedStatement1.setDouble(1, -500);\n            preparedStatement1.setString(2, \"张三\");\n            preparedStatement2.setDouble(1, 500);\n            preparedStatement2.setString(2, \"李四\");\n\n            int resultSet1 = preparedStatement1.executeUpdate();\n            int resultSet2 = preparedStatement2.executeUpdate();\n\n            //提交事务\n            connection.commit();\n\n        } catch (Exception e) {\n            //回滚事务\n            if (connection != null) {   //会有空指针异常\n                try {\n                    connection.rollback();\n                } catch (SQLException ex) {\n                    ex.printStackTrace();\n                }\n            }\n            e.printStackTrace();\n        } finally {\n            if (connection != null) {\n                try {\n                    connection.close();\n                } catch (SQLException e) {\n                    e.printStackTrace();\n                }\n            }\n\n            if (preparedStatement1 != null) {\n                try {\n                    preparedStatement1.close();\n                } catch (SQLException e) {\n                    e.printStackTrace();\n                }\n            }\n\n            if (preparedStatement2 != null) {\n                try {\n                    preparedStatement2.close();\n                } catch (SQLException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n### 连接池（C3P0 && Druid）\n#### C3P0\n配置文件（必须放在src的根目录下）\n```xml\n<c3p0-config>\n  <!-- 使用默认的配置读取连接池对象 -->\n  <default-config>\n    <!--  连接参数 -->\n    <property name=\"driverClass\">com.mysql.cj.jdbc.Driver</property>\n    <property name=\"jdbcUrl\">jdbc:mysql://localhost:3306/db1?serverTimezone=UTC</property>\n    <property name=\"user\">root</property>\n    <property name=\"password\">admin</property>\n\n    <!-- 连接池参数 -->\n    <property name=\"initialPoolSize\">5</property>\n    <property name=\"maxPoolSize\">10</property>\n    <property name=\"checkoutTimeout\">3000</property>\n  </default-config>\n\n  <named-config name=\"otherc3p0\">\n    <!--  连接参数 -->\n    <property name=\"driverClass\">com.mysql.cj.jdbc.Driver</property>\n    <property name=\"jdbcUrl\">jdbc:mysql://localhost:3306/db1?serverTimezone=UTC</property>\n    <property name=\"user\">root</property>\n    <property name=\"password\">admin</property>\n\n    <!-- 连接池参数 -->\n    <property name=\"initialPoolSize\">5</property>\n    <property name=\"maxPoolSize\">8</property>\n    <property name=\"checkoutTimeout\">1000</property>\n  </named-config>\n</c3p0-config>\n```\n```java\npackage datasource;\n\nimport com.mchange.v2.c3p0.ComboPooledDataSource;\n\nimport javax.sql.DataSource;\nimport java.sql.Connection;\nimport java.sql.SQLException;\n\npublic class C3P0 {\n    public static void main(String[] args) throws SQLException {\n        DataSource dataSource = new ComboPooledDataSource();    //还可以使用指定名称的配置\n        //Connection connection = dataSource.getConnection(); //c3p0的config.xml必须在src的根目录下\n        for (int i = 0; i <10 ; i++) {\n            Connection connection = dataSource.getConnection();\n            System.out.println(connection);\n            connection.close();\n        }\n    }\n}\n```\n#### Druid\n配置文件（可以放在任意位置）\n```properties\ndriverClassName=com.mysql.cj.jdbc.Driver\nurl=jdbc:mysql://localhost:3306/db1?serverTimezone=UTC\nusername=root\npassword=admin\ninitialSize=5\nmaxActive=10\nmaxWait=3000\n```\n```java\npackage datasource;\n\nimport com.alibaba.druid.pool.DruidDataSourceFactory;\n\nimport javax.sql.DataSource;\nimport java.io.FileInputStream;\nimport java.io.InputStream;\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.util.Properties;\n\npublic class Druid {\n    public static void main(String[] args) throws Exception {\n        //1.获取文件输入流以得到properties配置文件\n        InputStream inputStream = new FileInputStream(\"src/druid-config\");\n        Properties properties = new Properties();\n        properties.load(inputStream);\n        //2.DataSource初始化，获取DataSource对象\n        DataSource dataSource = DruidDataSourceFactory.createDataSource(properties);\n\n        //3.获取connection对象\n        Connection connection = dataSource.getConnection();\n\n        //4.发送sql\n        String sql = \"select * from student\";\n        PreparedStatement preparedStatement = connection.prepareStatement(sql);\n        ResultSet resultSet = preparedStatement.executeQuery();\n        while (resultSet.next()) {\n            System.out.println(resultSet.getString(2));\n        }\n        System.out.println(connection);\n\n    }\n}\n```\n##### 使用JdbcTemplate简化发送sql的过程(Spring)\n```java\npackage datasource;\n\nimport com.alibaba.druid.pool.DruidDataSourceFactory;\nimport org.springframework.jdbc.core.JdbcTemplate;\n\nimport javax.sql.DataSource;\nimport java.io.FileInputStream;\nimport java.util.Properties;\n\npublic class SpringJDBCTemplate {\n    public static void main(String[] args) throws Exception {\n        InputStream inputStream = 现在的类名.class.getClassLoader().getResourceAsStream(\"druid.properties\");\n        Properties properties = new Properties();\n        properties.load(inputStream);\n        DataSource dataSource = DruidDataSourceFactory.createDataSource(properties);\n\n        //1.创建JdbcTemplate，传入dataSource对象\n        JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);\n        String sql = \"update student set age = 1 where id = ?\";\n        //2.发送数据\n        int result = jdbcTemplate.update(sql, 1);\n        System.out.println(result);\n    }\n}\n```\n##### 查询语句\n```java\npackage datasource;\n\nimport com.alibaba.druid.pool.DruidDataSourceFactory;\nimport org.junit.Test;\nimport org.springframework.jdbc.core.JdbcTemplate;\n\nimport javax.sql.DataSource;\nimport java.io.FileInputStream;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\n\npublic class SpringJDBCTemplate {\n    @Test\n    public void getData() throws Exception {\n        FileInputStream fileInputStream = new FileInputStream(\"src/druid-config\");\n        Properties properties = new Properties();\n        properties.load(fileInputStream);\n        DataSource dataSource = DruidDataSourceFactory.createDataSource(properties);\n\n        //1.创建JdbcTemplate，传入dataSource对象\n        JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);\n        String sql = \"select * from emp\";\n        //2.发送数据\n        //Map<String, Object> stringObjectMap = jdbcTemplate.queryForMap(sql,1);  //封装成一个map集合\n        List<Map<String, Object>> maps = jdbcTemplate.queryForList(sql);\n        for (Map<String, Object> map : maps) {\n            System.out.println(map);\n        }\n    }\n\n    @Test\n    public void fun() throws Exception {\n        FileInputStream fileInputStream = new FileInputStream(\"src/druid-config\");\n        Properties properties = new Properties();\n        properties.load(fileInputStream);\n        DataSource dataSource = DruidDataSourceFactory.createDataSource(properties);\n\n        //1.创建JdbcTemplate，传入dataSource对象\n        JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);\n        String sql = \"select count(id) from emp\";\n        Long number = jdbcTemplate.queryForObject(sql, Long.class);\n        System.out.println(number);\n    }\n}\n```',2,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2020-03-16 19:42:23','2020-11-29 11:45:12',0),(117,'JDBC课堂笔记','# 今日内容\r\n\r\n	1. JDBC基本概念\r\n	2. 快速入门\r\n	3. 对JDBC中各个接口和类详解\r\n\r\n\r\n## JDBC：\r\n	1. 概念：Java DataBase Connectivity  Java 数据库连接， Java语言操作数据库\r\n		* JDBC本质：其实是官方（sun公司）定义的一套操作所有关系型数据库的规则，即接口。各个数据库厂商去实现这套接口，提供数据库驱动jar包。我们可以使用这套接口（JDBC）编程，真正执行的代码是驱动jar包中的实现类。\r\n\r\n	2. 快速入门：\r\n		* 步骤：\r\n			1. 导入驱动jar包 mysql-connector-java-5.1.37-bin.jar\r\n				1.复制mysql-connector-java-5.1.37-bin.jar到项目的libs目录下\r\n				2.右键-->Add As Library\r\n			2. 注册驱动\r\n			3. 获取数据库连接对象 Connection\r\n			4. 定义sql\r\n			5. 获取执行sql语句的对象 Statement\r\n			6. 执行sql，接受返回结果\r\n			7. 处理结果\r\n			8. 释放资源\r\n\r\n		* 代码实现：\r\n		  	//1. 导入驱动jar包\r\n	        //2.注册驱动\r\n	        Class.forName(\"com.mysql.cj.jdbc.Driver\");  //后期版本有变化\r\n	        //3.获取数据库连接对象\r\n	        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:3306/db3\", \"root\", \"root\");\r\n	        //4.定义sql语句\r\n	        String sql = \"update account set balance = 500 where id = 1\";\r\n	        //5.获取执行sql的对象 Statement\r\n	        Statement stmt = conn.createStatement();\r\n	        //6.执行sql\r\n	        int count = stmt.executeUpdate(sql);\r\n	        //7.处理结果\r\n	        System.out.println(count);\r\n	        //8.释放资源\r\n	        stmt.close();\r\n	        conn.close();\r\n	\r\n	3. 详解各个对象：\r\n		1. DriverManager：驱动管理对象\r\n			* 功能：\r\n				1. 注册驱动：告诉程序该使用哪一个数据库驱动jar\r\n					static void registerDriver(Driver driver) :注册与给定的驱动程序 DriverManager 。 \r\n					写代码使用：  Class.forName(\"com.mysql.jdbc.Driver\");\r\n					通过查看源码发现：在com.mysql.jdbc.Driver类中存在静态代码块\r\n					 static {\r\n					        try {\r\n					            java.sql.DriverManager.registerDriver(new Driver());\r\n					        } catch (SQLException E) {\r\n					            throw new RuntimeException(\"Can\'t register driver!\");\r\n					        }\r\n    					}\r\n\r\n					注意：mysql5之后的驱动jar包可以省略注册驱动的步骤。\r\n				2. 获取数据库连接：\r\n					* 方法：static Connection getConnection(String url, String user, String password) \r\n					* 参数：\r\n						* url：指定连接的路径\r\n							* 语法：jdbc:mysql://ip地址(域名):端口号/数据库名称\r\n							* 例子：jdbc:mysql://localhost:3306/db3\r\n							* 细节：如果连接的是本机mysql服务器，并且mysql服务默认端口是3306，则url可以简写为：jdbc:mysql:///数据库名称\r\n						* user：用户名\r\n						* password：密码 \r\n		2. Connection：数据库连接对象\r\n			1. 功能：\r\n				1. 获取执行sql 的对象\r\n					* Statement createStatement()\r\n					* PreparedStatement prepareStatement(String sql)  \r\n				2. 管理事务：\r\n					* 开启事务：setAutoCommit(boolean autoCommit) ：调用该方法设置参数为false，即开启事务\r\n					* 提交事务：commit() \r\n					* 回滚事务：rollback() \r\n		3. Statement：执行sql的对象\r\n			1. 执行sql\r\n				1. boolean execute(String sql) ：可以执行任意的sql 了解 \r\n				2. int executeUpdate(String sql) ：执行DML（insert、update、delete）语句、DDL(create，alter、drop)语句\r\n					* 返回值：影响的行数，可以通过这个影响的行数判断DML语句是否执行成功 返回值>0的则执行成功，反之，则失败。\r\n				3. ResultSet executeQuery(String sql)  ：执行DQL（select)语句\r\n			2. 练习：\r\n				1. account表 添加一条记录\r\n				2. account表 修改记录\r\n				3. account表 删除一条记录\r\n\r\n				代码：\r\n					Statement stmt = null;\r\n			        Connection conn = null;\r\n			        try {\r\n			            //1. 注册驱动\r\n			            Class.forName(\"com.mysql.jdbc.Driver\");\r\n			            //2. 定义sql\r\n			            String sql = \"insert into account values(null,\'王五\',3000)\";\r\n			            //3.获取Connection对象\r\n			            conn = DriverManager.getConnection(\"jdbc:mysql:///db3\", \"root\", \"root\");\r\n			            //4.获取执行sql的对象 Statement\r\n			            stmt = conn.createStatement();\r\n			            //5.执行sql\r\n			            int count = stmt.executeUpdate(sql);//影响的行数\r\n			            //6.处理结果\r\n			            System.out.println(count);\r\n			            if(count > 0){\r\n			                System.out.println(\"添加成功！\");\r\n			            }else{\r\n			                System.out.println(\"添加失败！\");\r\n			            }\r\n			\r\n			        } catch (ClassNotFoundException e) {\r\n			            e.printStackTrace();\r\n			        } catch (SQLException e) {\r\n			            e.printStackTrace();\r\n			        }finally {\r\n			            //stmt.close();\r\n			            //7. 释放资源\r\n			            //避免空指针异常\r\n			            if(stmt != null){\r\n			                try {\r\n			                    stmt.close();\r\n			                } catch (SQLException e) {\r\n			                    e.printStackTrace();\r\n			                }\r\n			            }\r\n			\r\n			            if(conn != null){\r\n			                try {\r\n			                    conn.close();\r\n			                } catch (SQLException e) {\r\n			                    e.printStackTrace();\r\n			                }\r\n			            }\r\n			        }\r\n				\r\n		4. ResultSet：结果集对象,封装查询结果\r\n			* boolean next(): 游标向下移动一行，判断当前行是否是最后一行末尾(是否有数据)，如果是，则返回false，如果不是则返回true\r\n			* getXxx(参数):获取数据\r\n				* Xxx：代表数据类型   如： int getInt() ,	String getString()\r\n				* 参数：\r\n					1. int：代表列的编号,从1开始   如： getString(1)\r\n					2. String：代表列名称。 如： getDouble(\"balance\")\r\n			\r\n			* 注意：\r\n				* 使用步骤：\r\n					1. 游标向下移动一行\r\n					2. 判断是否有数据\r\n					3. 获取数据\r\n\r\n				   //循环判断游标是否是最后一行末尾。\r\n		            while(rs.next()){\r\n		                //获取数据\r\n		                //6.2 获取数据\r\n		                int id = rs.getInt(1);\r\n		                String name = rs.getString(\"name\");\r\n		                double balance = rs.getDouble(3);\r\n		\r\n		                System.out.println(id + \"---\" + name + \"---\" + balance);\r\n		            }\r\n\r\n			* 练习：\r\n				* 定义一个方法，查询emp表的数据将其封装为对象，然后装载集合，返回。\r\n					1. 定义Emp类\r\n					2. 定义方法 public List<Emp> findAll(){}\r\n					3. 实现方法 select * from emp;\r\n						\r\n		5. PreparedStatement：执行sql的对象\r\n			1. SQL注入问题：在拼接sql时，有一些sql的特殊关键字参与字符串的拼接。会造成安全性问题\r\n				1. 输入用户随便，输入密码：a\' or \'a\' = \'a\r\n				2. sql：select * from user where username = \'fhdsjkf\' and password = \'a\' or \'a\' = \'a\' \r\n\r\n			2. 解决sql注入问题：使用PreparedStatement对象来解决\r\n			3. 预编译的SQL：参数使用?作为占位符\r\n			4. 步骤：\r\n				1. 导入驱动jar包 mysql-connector-java-5.1.37-bin.jar\r\n				2. 注册驱动\r\n				3. 获取数据库连接对象 Connection\r\n				4. 定义sql\r\n					* 注意：sql的参数使用？作为占位符。 如：select * from user where username = ? and password = ?;\r\n				5. 获取执行sql语句的对象 PreparedStatement  Connection.prepareStatement(String sql) \r\n				6. 给？赋值：\r\n					* 方法： setXxx(参数1,参数2)\r\n						* 参数1：？的位置编号 从1 开始\r\n						* 参数2：？的值\r\n				7. 执行sql，接受返回结果，不需要传递sql语句\r\n				8. 处理结果\r\n				9. 释放资源\r\n\r\n			5. 注意：后期都会使用PreparedStatement来完成增删改查的所有操作\r\n				1. 可以防止SQL注入\r\n				2. 效率更高\r\n\r\n## 抽取JDBC工具类 ： JDBCUtils\r\n	* 目的：简化书写\r\n	* 分析：\r\n		1. 注册驱动也抽取\r\n		2. 抽取一个方法获取连接对象\r\n			* 需求：不想传递参数（麻烦），还得保证工具类的通用性。\r\n			* 解决：配置文件\r\n				jdbc.properties\r\n					url=\r\n					user=\r\n					password=\r\n\r\n\r\n		3. 抽取一个方法释放资源\r\n\r\n	* 代码实现：\r\n		public class JDBCUtils {\r\n	    private static String url;\r\n	    private static String user;\r\n	    private static String password;\r\n	    private static String driver;\r\n	    /**\r\n	     * 文件的读取，只需要读取一次即可拿到这些值。使用静态代码块\r\n	     */\r\n	    static{\r\n	        //读取资源文件，获取值。\r\n	\r\n	        try {\r\n	            //1. 创建Properties集合类。\r\n	            Properties pro = new Properties();\r\n	\r\n	            //获取src路径下的文件的方式--->ClassLoader 类加载器\r\n	            ClassLoader classLoader = JDBCUtils.class.getClassLoader();\r\n	            URL res  = classLoader.getResource(\"jdbc.properties\");\r\n	            String path = res.getPath();\r\n	            System.out.println(path);///D:/IdeaProjects/itcast/out/production/day04_jdbc/jdbc.properties\r\n	            //2. 加载文件\r\n	           // pro.load(new FileReader(\"D:\\\\IdeaProjects\\\\itcast\\\\day04_jdbc\\\\src\\\\jdbc.properties\"));\r\n	            pro.load(new FileReader(path));\r\n	\r\n	            //3. 获取数据，赋值\r\n	            url = pro.getProperty(\"url\");\r\n	            user = pro.getProperty(\"user\");\r\n	            password = pro.getProperty(\"password\");\r\n	            driver = pro.getProperty(\"driver\");\r\n	            //4. 注册驱动\r\n	            Class.forName(driver);\r\n	        } catch (IOException e) {\r\n	            e.printStackTrace();\r\n	        } catch (ClassNotFoundException e) {\r\n	            e.printStackTrace();\r\n	        }\r\n	    }\r\n	\r\n	\r\n	    /**\r\n	     * 获取连接\r\n	     * @return 连接对象\r\n	     */\r\n	    public static Connection getConnection() throws SQLException {\r\n	\r\n	        return DriverManager.getConnection(url, user, password);\r\n	    }\r\n	\r\n	    /**\r\n	     * 释放资源\r\n	     * @param stmt\r\n	     * @param conn\r\n	     */\r\n	    public static void close(Statement stmt,Connection conn){\r\n	        if( stmt != null){\r\n	            try {\r\n	                stmt.close();\r\n	            } catch (SQLException e) {\r\n	                e.printStackTrace();\r\n	            }\r\n	        }\r\n	\r\n	        if( conn != null){\r\n	            try {\r\n	                conn.close();\r\n	            } catch (SQLException e) {\r\n	                e.printStackTrace();\r\n	            }\r\n	        }\r\n	    }\r\n	\r\n	\r\n	    /**\r\n	     * 释放资源\r\n	     * @param stmt\r\n	     * @param conn\r\n	     */\r\n	    public static void close(ResultSet rs,Statement stmt, Connection conn){\r\n	        if( rs != null){\r\n	            try {\r\n	                rs.close();\r\n	            } catch (SQLException e) {\r\n	                e.printStackTrace();\r\n	            }\r\n	        }\r\n	\r\n	        if( stmt != null){\r\n	            try {\r\n	                stmt.close();\r\n	            } catch (SQLException e) {\r\n	                e.printStackTrace();\r\n	            }\r\n	        }\r\n	\r\n	        if( conn != null){\r\n	            try {\r\n	                conn.close();\r\n	            } catch (SQLException e) {\r\n	                e.printStackTrace();\r\n	            }\r\n	        }\r\n	    }\r\n	\r\n	}\r\n\r\n	* 练习：\r\n		* 需求：\r\n			1. 通过键盘录入用户名和密码\r\n			2. 判断用户是否登录成功\r\n				* select * from user where username = \"\" and password = \"\";\r\n				* 如果这个sql有查询结果，则成功，反之，则失败\r\n\r\n		* 步骤：\r\n			1. 创建数据库表 user\r\n				CREATE TABLE USER(\r\n					id INT PRIMARY KEY AUTO_INCREMENT,\r\n					username VARCHAR(32),\r\n					PASSWORD VARCHAR(32)\r\n				\r\n				);\r\n\r\n				INSERT INTO USER VALUES(NULL,\'zhangsan\',\'123\');\r\n				INSERT INTO USER VALUES(NULL,\'lisi\',\'234\');\r\n\r\n			2. 代码实现：\r\n				public class JDBCDemo9 {\r\n\r\n				    public static void main(String[] args) {\r\n				        //1.键盘录入，接受用户名和密码\r\n				        Scanner sc = new Scanner(System.in);\r\n				        System.out.println(\"请输入用户名：\");\r\n				        String username = sc.nextLine();\r\n				        System.out.println(\"请输入密码：\");\r\n				        String password = sc.nextLine();\r\n				        //2.调用方法\r\n				        boolean flag = new JDBCDemo9().login(username, password);\r\n				        //3.判断结果，输出不同语句\r\n				        if(flag){\r\n				            //登录成功\r\n				            System.out.println(\"登录成功！\");\r\n				        }else{\r\n				            System.out.println(\"用户名或密码错误！\");\r\n				        }\r\n				\r\n				\r\n				    }\r\n				\r\n				\r\n				\r\n				    /**\r\n				     * 登录方法\r\n				     */\r\n				    public boolean login(String username ,String password){\r\n				        if(username == null || password == null){\r\n				            return false;\r\n				        }\r\n				        //连接数据库判断是否登录成功\r\n				        Connection conn = null;\r\n				        Statement stmt =  null;\r\n				        ResultSet rs = null;\r\n				        //1.获取连接\r\n				        try {\r\n				            conn =  JDBCUtils.getConnection();\r\n				            //2.定义sql\r\n				            String sql = \"select * from user where username = \'\"+username+\"\' and password = \'\"+password+\"\' \";\r\n				            //3.获取执行sql的对象\r\n				            stmt = conn.createStatement();\r\n				            //4.执行查询\r\n				            rs = stmt.executeQuery(sql);\r\n				            //5.判断\r\n				           /* if(rs.next()){//如果有下一行，则返回true\r\n				                return true;\r\n				            }else{\r\n				                return false;\r\n				            }*/\r\n				           return rs.next();//如果有下一行，则返回true\r\n				\r\n				        } catch (SQLException e) {\r\n				            e.printStackTrace();\r\n				        }finally {\r\n				            JDBCUtils.close(rs,stmt,conn);\r\n				        }\r\n				\r\n				\r\n				        return false;\r\n				    }\r\n				}\r\n\r\n\r\n## JDBC控制事务：\r\n	1. 事务：一个包含多个步骤的业务操作。如果这个业务操作被事务管理，则这多个步骤要么同时成功，要么同时失败。\r\n	2. 操作：\r\n		1. 开启事务\r\n		2. 提交事务\r\n		3. 回滚事务\r\n	3. 使用Connection对象来管理事务\r\n		* 开启事务：setAutoCommit(boolean autoCommit) ：调用该方法设置参数为false，即开启事务\r\n			* 在执行sql之前开启事务\r\n		* 提交事务：commit() \r\n			* 当所有sql都执行完提交事务\r\n		* 回滚事务：rollback() \r\n			* 在catch中回滚事务\r\n\r\n	4. 代码：\r\n		public class JDBCDemo10 {\r\n\r\n		    public static void main(String[] args) {\r\n		        Connection conn = null;\r\n		        PreparedStatement pstmt1 = null;\r\n		        PreparedStatement pstmt2 = null;\r\n		\r\n		        try {\r\n		            //1.获取连接\r\n		            conn = JDBCUtils.getConnection();\r\n		            //开启事务\r\n		            conn.setAutoCommit(false);\r\n		\r\n		            //2.定义sql\r\n		            //2.1 张三 - 500\r\n		            String sql1 = \"update account set balance = balance - ? where id = ?\";\r\n		            //2.2 李四 + 500\r\n		            String sql2 = \"update account set balance = balance + ? where id = ?\";\r\n		            //3.获取执行sql对象\r\n		            pstmt1 = conn.prepareStatement(sql1);\r\n		            pstmt2 = conn.prepareStatement(sql2);\r\n		            //4. 设置参数\r\n		            pstmt1.setDouble(1,500);\r\n		            pstmt1.setInt(2,1);\r\n		\r\n		            pstmt2.setDouble(1,500);\r\n		            pstmt2.setInt(2,2);\r\n		            //5.执行sql\r\n		            pstmt1.executeUpdate();\r\n		            // 手动制造异常\r\n		            int i = 3/0;\r\n		\r\n		            pstmt2.executeUpdate();\r\n		            //提交事务\r\n		            conn.commit();\r\n		        } catch (Exception e) {\r\n		            //事务回滚\r\n		            try {\r\n		                if(conn != null) {\r\n		                    conn.rollback();\r\n		                }\r\n		            } catch (SQLException e1) {\r\n		                e1.printStackTrace();\r\n		            }\r\n		            e.printStackTrace();\r\n		        }finally {\r\n		            JDBCUtils.close(pstmt1,conn);\r\n		            JDBCUtils.close(pstmt2,null);\r\n		        }\r\n		\r\n		\r\n		    }\r\n		\r\n		}',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2020-02-14 12:32:26','2020-11-29 11:45:12',0),(118,'JDBC连接池&JDBCTemplate课堂笔记','# 今日内容\r\n	1. 数据库连接池\r\n\r\n	2. Spring JDBC : JDBC Template\r\n\r\n\r\n\r\n## 数据库连接池\r\n	1. 概念：其实就是一个容器(集合)，存放数据库连接的容器。\r\n		    当系统初始化好后，容器被创建，容器中会申请一些连接对象，当用户来访问数据库时，从容器中获取连接对象，用户访问完之后，会将连接对象归还给容器。\r\n\r\n	2. 好处：\r\n		1. 节约资源\r\n		2. 用户访问高效\r\n\r\n	3. 实现：\r\n		1. 标准接口：DataSource   javax.sql包下的\r\n			1. 方法：\r\n				* 获取连接：getConnection()\r\n				* 归还连接：Connection.close()。如果连接对象Connection是从连接池中获取的，那么调用Connection.close()方法，则不会再关闭连接了。而是归还连接\r\n\r\n		2. 一般我们不去实现它，有数据库厂商来实现\r\n			1. C3P0：数据库连接池技术\r\n			2. Druid：数据库连接池实现技术，由阿里巴巴提供的\r\n\r\n\r\n	4. C3P0：数据库连接池技术\r\n		* 步骤：\r\n			1. 导入jar包 (两个) c3p0-0.9.5.2.jar mchange-commons-java-0.2.12.jar ，\r\n				* 不要忘记导入数据库驱动jar包\r\n			2. 定义配置文件：\r\n				* 名称： c3p0.properties 或者 c3p0-config.xml\r\n				* 路径：直接将文件放在src目录下即可。\r\n\r\n			3. 创建核心对象 数据库连接池对象 ComboPooledDataSource\r\n			4. 获取连接： getConnection\r\n		* 代码：\r\n			 //1.创建数据库连接池对象\r\n	        DataSource ds  = new ComboPooledDataSource();\r\n	        //2. 获取连接对象\r\n	        Connection conn = ds.getConnection();\r\n	5. Druid：数据库连接池实现技术，由阿里巴巴提供的\r\n		1. 步骤：\r\n			1. 导入jar包 druid-1.0.9.jar\r\n			2. 定义配置文件：\r\n				* 是properties形式的\r\n				* 可以叫任意名称，可以放在任意目录下\r\n			3. 加载配置文件。Properties\r\n			4. 获取数据库连接池对象：通过工厂来来获取  DruidDataSourceFactory\r\n			5. 获取连接：getConnection\r\n		* 代码：\r\n			 //3.加载配置文件\r\n	        Properties pro = new Properties();\r\n	        InputStream is = DruidDemo.class.getClassLoader().getResourceAsStream(\"druid.properties\");\r\n	        pro.load(is);\r\n	        //4.获取连接池对象\r\n	        DataSource ds = DruidDataSourceFactory.createDataSource(pro);\r\n	        //5.获取连接\r\n	        Connection conn = ds.getConnection();\r\n		2. 定义工具类\r\n			1. 定义一个类 JDBCUtils\r\n			2. 提供静态代码块加载配置文件，初始化连接池对象\r\n			3. 提供方法\r\n				1. 获取连接方法：通过数据库连接池获取连接\r\n				2. 释放资源\r\n				3. 获取连接池的方法\r\n\r\n\r\n		* 代码：\r\n			public class JDBCUtils {\r\n\r\n			    //1.定义成员变量 DataSource\r\n			    private static DataSource ds ;\r\n			\r\n			    static{\r\n			        try {\r\n			            //1.加载配置文件\r\n			            Properties pro = new Properties();\r\n			            pro.load(JDBCUtils.class.getClassLoader().getResourceAsStream(\"druid.properties\"));\r\n			            //2.获取DataSource\r\n			            ds = DruidDataSourceFactory.createDataSource(pro);\r\n			        } catch (IOException e) {\r\n			            e.printStackTrace();\r\n			        } catch (Exception e) {\r\n			            e.printStackTrace();\r\n			        }\r\n			    }\r\n			\r\n			    /**\r\n			     * 获取连接\r\n			     */\r\n			    public static Connection getConnection() throws SQLException {\r\n			        return ds.getConnection();\r\n			    }\r\n			\r\n			    /**\r\n			     * 释放资源\r\n			     */\r\n			    public static void close(Statement stmt,Connection conn){\r\n			       /* if(stmt != null){\r\n			            try {\r\n			                stmt.close();\r\n			            } catch (SQLException e) {\r\n			                e.printStackTrace();\r\n			            }\r\n			        }\r\n			\r\n			        if(conn != null){\r\n			            try {\r\n			                conn.close();//归还连接\r\n			            } catch (SQLException e) {\r\n			                e.printStackTrace();\r\n			            }\r\n			        }*/\r\n			\r\n			       close(null,stmt,conn);\r\n			    }\r\n			\r\n			\r\n			    public static void close(ResultSet rs , Statement stmt, Connection conn){\r\n			\r\n			\r\n			        if(rs != null){\r\n			            try {\r\n			                rs.close();\r\n			            } catch (SQLException e) {\r\n			                e.printStackTrace();\r\n			            }\r\n			        }\r\n			\r\n			\r\n			        if(stmt != null){\r\n			            try {\r\n			                stmt.close();\r\n			            } catch (SQLException e) {\r\n			                e.printStackTrace();\r\n			            }\r\n			        }\r\n			\r\n			        if(conn != null){\r\n			            try {\r\n			                conn.close();//归还连接\r\n			            } catch (SQLException e) {\r\n			                e.printStackTrace();\r\n			            }\r\n			        }\r\n			    }\r\n			\r\n			    /**\r\n			     * 获取连接池方法\r\n			     */\r\n			\r\n			    public static DataSource getDataSource(){\r\n			        return  ds;\r\n			    }\r\n			\r\n			}\r\n\r\n## Spring JDBC\r\n	* Spring框架对JDBC的简单封装。提供了一个JDBCTemplate对象简化JDBC的开发\r\n	* 步骤：\r\n		1. 导入jar包\r\n		2. 创建JdbcTemplate对象。依赖于数据源DataSource\r\n			* JdbcTemplate template = new JdbcTemplate(ds);\r\n\r\n		3. 调用JdbcTemplate的方法来完成CRUD的操作\r\n			* update():执行DML语句。增、删、改语句\r\n			* queryForMap():查询结果将结果集封装为map集合，将列名作为key，将值作为value 将这条记录封装为一个map集合\r\n				* 注意：这个方法查询的结果集长度只能是1\r\n			* queryForList():查询结果将结果集封装为list集合\r\n				* 注意：将每一条记录封装为一个Map集合，再将Map集合装载到List集合中\r\n			* query():查询结果，将结果封装为JavaBean对象\r\n				* query的参数：RowMapper\r\n					* 一般我们使用BeanPropertyRowMapper实现类。可以完成数据到JavaBean的自动封装\r\n					* new BeanPropertyRowMapper<类型>(类型.class)\r\n			* queryForObject：查询结果，将结果封装为对象\r\n				* 一般用于聚合函数的查询\r\n\r\n		4. 练习：\r\n			* 需求：\r\n				1. 修改1号数据的 salary 为 10000\r\n				2. 添加一条记录\r\n				3. 删除刚才添加的记录\r\n				4. 查询id为1的记录，将其封装为Map集合\r\n				5. 查询所有记录，将其封装为List\r\n				6. 查询所有记录，将其封装为Emp对象的List集合\r\n				7. 查询总记录数\r\n\r\n			* 代码：\r\n				\r\n				import cn.itcast.domain.Emp;\r\n				import cn.itcast.utils.JDBCUtils;\r\n				import org.junit.Test;\r\n				import org.springframework.jdbc.core.BeanPropertyRowMapper;\r\n				import org.springframework.jdbc.core.JdbcTemplate;\r\n				import org.springframework.jdbc.core.RowMapper;\r\n				\r\n				import java.sql.Date;\r\n				import java.sql.ResultSet;\r\n				import java.sql.SQLException;\r\n				import java.util.List;\r\n				import java.util.Map;\r\n				\r\n				public class JdbcTemplateDemo2 {\r\n				\r\n				    //Junit单元测试，可以让方法独立执行\r\n				\r\n				\r\n				    //1. 获取JDBCTemplate对象\r\n				    private JdbcTemplate template = new JdbcTemplate(JDBCUtils.getDataSource());\r\n				    /**\r\n				     * 1. 修改1号数据的 salary 为 10000\r\n				     */\r\n				    @Test\r\n				    public void test1(){\r\n				\r\n				        //2. 定义sql\r\n				        String sql = \"update emp set salary = 10000 where id = 1001\";\r\n				        //3. 执行sql\r\n				        int count = template.update(sql);\r\n				        System.out.println(count);\r\n				    }\r\n				\r\n				    /**\r\n				     * 2. 添加一条记录\r\n				     */\r\n				    @Test\r\n				    public void test2(){\r\n				        String sql = \"insert into emp(id,ename,dept_id) values(?,?,?)\";\r\n				        int count = template.update(sql, 1015, \"郭靖\", 10);\r\n				        System.out.println(count);\r\n				\r\n				    }\r\n				\r\n				    /**\r\n				     * 3.删除刚才添加的记录\r\n				     */\r\n				    @Test\r\n				    public void test3(){\r\n				        String sql = \"delete from emp where id = ?\";\r\n				        int count = template.update(sql, 1015);\r\n				        System.out.println(count);\r\n				    }\r\n				\r\n				    /**\r\n				     * 4.查询id为1001的记录，将其封装为Map集合\r\n				     * 注意：这个方法查询的结果集长度只能是1\r\n				     */\r\n				    @Test\r\n				    public void test4(){\r\n				        String sql = \"select * from emp where id = ? or id = ?\";\r\n				        Map<String, Object> map = template.queryForMap(sql, 1001,1002);\r\n				        System.out.println(map);\r\n				        //{id=1001, ename=孙悟空, job_id=4, mgr=1004, joindate=2000-12-17, salary=10000.00, bonus=null, dept_id=20}\r\n				\r\n				    }\r\n				\r\n				    /**\r\n				     * 5. 查询所有记录，将其封装为List\r\n				     */\r\n				    @Test\r\n				    public void test5(){\r\n				        String sql = \"select * from emp\";\r\n				        List<Map<String, Object>> list = template.queryForList(sql);\r\n				\r\n				        for (Map<String, Object> stringObjectMap : list) {\r\n				            System.out.println(stringObjectMap);\r\n				        }\r\n				    }\r\n				\r\n				    /**\r\n				     * 6. 查询所有记录，将其封装为Emp对象的List集合\r\n				     */\r\n				\r\n				    @Test\r\n				    public void test6(){\r\n				        String sql = \"select * from emp\";\r\n				        List<Emp> list = template.query(sql, new RowMapper<Emp>() {\r\n				\r\n				            @Override\r\n				            public Emp mapRow(ResultSet rs, int i) throws SQLException {\r\n				                Emp emp = new Emp();\r\n				                int id = rs.getInt(\"id\");\r\n				                String ename = rs.getString(\"ename\");\r\n				                int job_id = rs.getInt(\"job_id\");\r\n				                int mgr = rs.getInt(\"mgr\");\r\n				                Date joindate = rs.getDate(\"joindate\");\r\n				                double salary = rs.getDouble(\"salary\");\r\n				                double bonus = rs.getDouble(\"bonus\");\r\n				                int dept_id = rs.getInt(\"dept_id\");\r\n				\r\n				                emp.setId(id);\r\n				                emp.setEname(ename);\r\n				                emp.setJob_id(job_id);\r\n				                emp.setMgr(mgr);\r\n				                emp.setJoindate(joindate);\r\n				                emp.setSalary(salary);\r\n				                emp.setBonus(bonus);\r\n				                emp.setDept_id(dept_id);\r\n				\r\n				                return emp;\r\n				            }\r\n				        });\r\n				\r\n				\r\n				        for (Emp emp : list) {\r\n				            System.out.println(emp);\r\n				        }\r\n				    }\r\n				\r\n				    /**\r\n				     * 6. 查询所有记录，将其封装为Emp对象的List集合\r\n				     */\r\n				\r\n				    @Test\r\n				    public void test6_2(){\r\n				        String sql = \"select * from emp\";\r\n				        List<Emp> list = template.query(sql, new BeanPropertyRowMapper<Emp>(Emp.class));\r\n				        for (Emp emp : list) {\r\n				            System.out.println(emp);\r\n				        }\r\n				    }\r\n				\r\n				    /**\r\n				     * 7. 查询总记录数\r\n				     */\r\n				\r\n				    @Test\r\n				    public void test7(){\r\n				        String sql = \"select count(id) from emp\";\r\n				        Long total = template.queryForObject(sql, Long.class);\r\n				        System.out.println(total);\r\n				    }\r\n				\r\n				}',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2020-01-17 16:54:17','2020-11-29 11:45:12',0),(119,'MySQL基础课堂笔记','# 今日内容\r\n\r\n1. 数据库的基本概念\r\n\r\n\r\n2. MySQL数据库软件\r\n	1. 安装\r\n	2. 卸载\r\n	3. 配置\r\n\r\n3. SQL\r\n\r\n\r\n## 数据库的基本概念\r\n	1. 数据库的英文单词： DataBase 简称 ： DB\r\n	2. 什么数据库？\r\n		* 用于存储和管理数据的仓库。\r\n\r\n	3. 数据库的特点：\r\n		1. 持久化存储数据的。其实数据库就是一个文件系统\r\n		2. 方便存储和管理数据\r\n		3. 使用了统一的方式操作数据库 -- SQL\r\n\r\n	\r\n	4. 常见的数据库软件\r\n		* 参见《MySQL基础.pdf》\r\n\r\n\r\n# MySQL数据库软件\r\n	1. 安装\r\n		* 参见《MySQL基础.pdf》\r\n	2. 卸载\r\n		1. 去mysql的安装目录找到my.ini文件\r\n			* 复制 datadir=\"C:/ProgramData/MySQL/MySQL Server 5.5/Data/\"\r\n		2. 卸载MySQL\r\n		3. 删除C:/ProgramData目录下的MySQL文件夹。\r\n		\r\n	3. 配置\r\n		* MySQL服务启动\r\n			1. 手动。\r\n			2. cmd--> services.msc 打开服务的窗口\r\n			3. 使用管理员打开cmd\r\n				* net start mysql : 启动mysql的服务\r\n				* net stop mysql:关闭mysql服务\r\n		* MySQL登录\r\n			1. mysql -uroot -p密码\r\n			2. mysql -hip -uroot -p连接目标的密码\r\n			3. mysql --host=ip --user=root --password=连接目标的密码\r\n		* MySQL退出\r\n			1. exit\r\n			2. quit\r\n	\r\n		* MySQL目录结构\r\n			1. MySQL安装目录：basedir=\"D:/develop/MySQL/\"\r\n				* 配置文件 my.ini\r\n			2. MySQL数据目录：datadir=\"C:/ProgramData/MySQL/MySQL Server 5.5/Data/\"\r\n				* 几个概念\r\n					* 数据库：文件夹\r\n					* 表：文件\r\n					* 数据：数据\r\n\r\n\r\n\r\n# SQL\r\n\r\n	1.什么是SQL？\r\n		Structured Query Language：结构化查询语言\r\n		其实就是定义了操作所有关系型数据库的规则。每一种数据库操作的方式存在不一样的地方，称为“方言”。\r\n		\r\n	2.SQL通用语法\r\n		1. SQL 语句可以单行或多行书写，以分号结尾。\r\n		2. 可使用空格和缩进来增强语句的可读性。\r\n		3. MySQL 数据库的 SQL 语句不区分大小写，关键字建议使用大写。\r\n		4. 3 种注释\r\n			* 单行注释: -- 注释内容 或 # 注释内容(mysql 特有) \r\n			* 多行注释: /* 注释 */\r\n		\r\n	3. SQL分类\r\n		1) DDL(Data Definition Language)数据定义语言\r\n			用来定义数据库对象：数据库，表，列等。关键字：create, drop,alter 等\r\n		2) DML(Data Manipulation Language)数据操作语言\r\n			用来对数据库中表的数据进行增删改。关键字：insert, delete, update 等\r\n		3) DQL(Data Query Language)数据查询语言\r\n			用来查询数据库中表的记录(数据)。关键字：select, where 等\r\n		4) DCL(Data Control Language)数据控制语言(了解)\r\n			用来定义数据库的访问权限和安全级别，及创建用户。关键字：GRANT， REVOKE 等\r\n\r\n## DDL:操作数据库、表\r\n\r\n	1. 操作数据库：CRUD\r\n		1. C(Create):创建\r\n			* 创建数据库：\r\n				* create database 数据库名称;\r\n			* 创建数据库，判断不存在，再创建：\r\n				* create database if not exists 数据库名称;\r\n			* 创建数据库，并指定字符集\r\n				* create database 数据库名称 character set 字符集名;\r\n\r\n			* 练习： 创建db4数据库，判断是否存在，并制定字符集为gbk\r\n				* create database if not exists db4 character set gbk;\r\n		2. R(Retrieve)：查询\r\n			* 查询所有数据库的名称:\r\n				* show databases;\r\n			* 查询某个数据库的字符集:查询某个数据库的创建语句\r\n				* show create database 数据库名称;\r\n		3. U(Update):修改\r\n			* 修改数据库的字符集\r\n				* alter database 数据库名称 character set 字符集名称;\r\n		4. D(Delete):删除\r\n			* 删除数据库\r\n				* drop database 数据库名称;\r\n			* 判断数据库存在，存在再删除\r\n				* drop database if exists 数据库名称;\r\n		5. 使用数据库\r\n			* 查询当前正在使用的数据库名称\r\n				* select database();\r\n			* 使用数据库\r\n				* use 数据库名称;\r\n\r\n\r\n	2. 操作表\r\n		1. C(Create):创建\r\n			1. 语法：\r\n				create table 表名(\r\n					列名1 数据类型1,\r\n					列名2 数据类型2,\r\n					....\r\n					列名n 数据类型n\r\n				);\r\n				* 注意：最后一列，不需要加逗号（,）\r\n				* 数据库类型：\r\n					1. int：整数类型\r\n						* age int,\r\n					2. double:小数类型\r\n						* score double(5,2)\r\n					3. date:日期，只包含年月日，yyyy-MM-dd\r\n					4. datetime:日期，包含年月日时分秒	 yyyy-MM-dd HH:mm:ss\r\n					5. timestamp:时间错类型	包含年月日时分秒	 yyyy-MM-dd HH:mm:ss	\r\n						* 如果将来不给这个字段赋值，或赋值为null，则默认使用当前的系统时间，来自动赋值\r\n\r\n					6. varchar：字符串\r\n						* name varchar(20):姓名最大20个字符\r\n						* zhangsan 8个字符  张三 2个字符\r\n				\r\n\r\n			* 创建表\r\n				create table student(\r\n					id int,\r\n					name varchar(32),\r\n					age int ,\r\n					score double(4,1),\r\n					birthday date,\r\n					insert_time timestamp\r\n				);\r\n			* 复制表：\r\n				* create table 表名 like 被复制的表名;	  	\r\n		2. R(Retrieve)：查询\r\n			* 查询某个数据库中所有的表名称\r\n				* show tables;\r\n			* 查询表结构\r\n				* desc 表名;\r\n		3. U(Update):修改\r\n			1. 修改表名\r\n				alter table 表名 rename to 新的表名;\r\n			2. 修改表的字符集\r\n				alter table 表名 character set 字符集名称;\r\n			3. 添加一列\r\n				alter table 表名 add 列名 数据类型;\r\n			4. 修改列名称 类型\r\n				alter table 表名 change 列名 新列别 新数据类型;\r\n				alter table 表名 modify 列名 新数据类型;\r\n			5. 删除列\r\n				alter table 表名 drop 列名;\r\n		4. D(Delete):删除\r\n			* drop table 表名;\r\n			* drop table  if exists 表名 ;\r\n\r\n* 客户端图形化工具：SQLYog\r\n\r\n## DML：增删改表中数据\r\n\r\n	1. 添加数据：\r\n		* 语法：\r\n			* insert into 表名(列名1,列名2,...列名n) values(值1,值2,...值n);\r\n		* 注意：\r\n			1. 列名和值要一一对应。\r\n			2. 如果表名后，不定义列名，则默认给所有列添加值\r\n				insert into 表名 values(值1,值2,...值n);\r\n			3. 除了数字类型，其他类型需要使用引号(单双都可以)引起来\r\n	2. 删除数据：\r\n		* 语法：\r\n			* delete from 表名 [where 条件]\r\n		* 注意：\r\n			1. 如果不加条件，则删除表中所有记录。\r\n			2. 如果要删除所有记录\r\n				1. delete from 表名; -- 不推荐使用。有多少条记录就会执行多少次删除操作\r\n				2. TRUNCATE TABLE 表名; -- 推荐使用，效率更高 先删除表，然后再创建一张一样的表。\r\n	3. 修改数据：\r\n		* 语法：\r\n			* update 表名 set 列名1 = 值1, 列名2 = 值2,... [where 条件];\r\n\r\n		* 注意：\r\n			1. 如果不加任何条件，则会将表中所有记录全部修改。\r\n\r\n\r\n\r\n## DQL：查询表中的记录\r\n	* select * from 表名;\r\n	\r\n	1. 语法：\r\n		select\r\n			字段列表\r\n		from\r\n			表名列表\r\n		where\r\n			条件列表\r\n		group by\r\n			分组字段\r\n		having\r\n			分组之后的条件\r\n		order by\r\n			排序\r\n		limit\r\n			分页限定\r\n\r\n\r\n	2. 基础查询\r\n		1. 多个字段的查询\r\n			select 字段名1，字段名2... from 表名；\r\n			* 注意：\r\n				* 如果查询所有字段，则可以使用*来替代字段列表。\r\n		2. 去除重复：\r\n			* distinct\r\n		3. 计算列\r\n			* 一般可以使用四则运算计算一些列的值。（一般只会进行数值型的计算）\r\n			* ifnull(表达式1,表达式2)：null参与的运算，计算结果都为null\r\n				* 表达式1：哪个字段需要判断是否为null\r\n				* 如果该字段为null后的替换值。\r\n		4. 起别名：\r\n			* as：as也可以省略\r\n			\r\n\r\n	3. 条件查询\r\n		1. where子句后跟条件\r\n		2. 运算符\r\n			* > 、< 、<= 、>= 、= 、<>\r\n			* BETWEEN...AND  \r\n			* IN( 集合) \r\n			* LIKE：模糊查询\r\n				* 占位符：\r\n					* _:单个任意字符\r\n					* %：多个任意字符\r\n			* IS NULL  \r\n			* and  或 &&\r\n			* or  或 || \r\n			* not  或 !\r\n			\r\n				-- 查询年龄大于20岁\r\n\r\n				SELECT * FROM student WHERE age > 20;\r\n				\r\n				SELECT * FROM student WHERE age >= 20;\r\n				\r\n				-- 查询年龄等于20岁\r\n				SELECT * FROM student WHERE age = 20;\r\n				\r\n				-- 查询年龄不等于20岁\r\n				SELECT * FROM student WHERE age != 20;\r\n				SELECT * FROM student WHERE age <> 20;\r\n				\r\n				-- 查询年龄大于等于20 小于等于30\r\n				\r\n				SELECT * FROM student WHERE age >= 20 &&  age <=30;\r\n				SELECT * FROM student WHERE age >= 20 AND  age <=30;\r\n				SELECT * FROM student WHERE age BETWEEN 20 AND 30;\r\n				\r\n				-- 查询年龄22岁，18岁，25岁的信息\r\n				SELECT * FROM student WHERE age = 22 OR age = 18 OR age = 25\r\n				SELECT * FROM student WHERE age IN (22,18,25);\r\n				\r\n				-- 查询英语成绩为null\r\n				SELECT * FROM student WHERE english = NULL; -- 不对的。null值不能使用 = （!=） 判断\r\n				\r\n				SELECT * FROM student WHERE english IS NULL;\r\n				\r\n				-- 查询英语成绩不为null\r\n				SELECT * FROM student WHERE english  IS NOT NULL;\r\n	\r\n\r\n\r\n				-- 查询姓马的有哪些？ like\r\n				SELECT * FROM student WHERE NAME LIKE \'马%\';\r\n				-- 查询姓名第二个字是化的人\r\n				\r\n				SELECT * FROM student WHERE NAME LIKE \"_化%\";\r\n				\r\n				-- 查询姓名是3个字的人\r\n				SELECT * FROM student WHERE NAME LIKE \'___\';\r\n				\r\n				\r\n				-- 查询姓名中包含德的人\r\n				SELECT * FROM student WHERE NAME LIKE \'%德%\';',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2020-01-17 17:02:50','2020-11-29 11:45:12',0),(120,'MySQL多表&事务课堂笔记','# 今日内容\r\n\r\n	1. 多表查询\r\n\r\n	2. 事务\r\n\r\n	3. DCL\r\n\r\n\r\n## 多表查询：\r\n	* 查询语法：\r\n		select\r\n			列名列表\r\n		from\r\n			表名列表\r\n		where....\r\n	* 准备sql\r\n		# 创建部门表\r\n		CREATE TABLE dept(\r\n			id INT PRIMARY KEY AUTO_INCREMENT,\r\n			NAME VARCHAR(20)\r\n		);\r\n		INSERT INTO dept (NAME) VALUES (\'开发部\'),(\'市场部\'),(\'财务部\');\r\n		# 创建员工表\r\n		CREATE TABLE emp (\r\n			id INT PRIMARY KEY AUTO_INCREMENT,\r\n			NAME VARCHAR(10),\r\n			gender CHAR(1), -- 性别\r\n			salary DOUBLE, -- 工资\r\n			join_date DATE, -- 入职日期\r\n			dept_id INT,\r\n			FOREIGN KEY (dept_id) REFERENCES dept(id) -- 外键，关联部门表(部门表的主键)\r\n		);\r\n		INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(\'孙悟空\',\'男\',7200,\'2013-02-24\',1);\r\n		INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(\'猪八戒\',\'男\',3600,\'2010-12-02\',2);\r\n		INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(\'唐僧\',\'男\',9000,\'2008-08-08\',2);\r\n		INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(\'白骨精\',\'女\',5000,\'2015-10-07\',3);\r\n		INSERT INTO emp(NAME,gender,salary,join_date,dept_id) VALUES(\'蜘蛛精\',\'女\',4500,\'2011-03-14\',1);\r\n	* 笛卡尔积：\r\n		* 有两个集合A,B .取这两个集合的所有组成情况。\r\n		* 要完成多表查询，需要消除无用的数据\r\n	* 多表查询的分类：\r\n		1. 内连接查询：\r\n			1. 隐式内连接：使用where条件消除无用数据\r\n				* 例子：\r\n				-- 查询所有员工信息和对应的部门信息\r\n\r\n				SELECT * FROM emp,dept WHERE emp.`dept_id` = dept.`id`;\r\n				\r\n				-- 查询员工表的名称，性别。部门表的名称\r\n				SELECT emp.name,emp.gender,dept.name FROM emp,dept WHERE emp.`dept_id` = dept.`id`;\r\n				\r\n				SELECT \r\n					t1.name, -- 员工表的姓名\r\n					t1.gender,-- 员工表的性别\r\n					t2.name -- 部门表的名称\r\n				FROM\r\n					emp t1,\r\n					dept t2\r\n				WHERE \r\n					t1.`dept_id` = t2.`id`;\r\n\r\n	\r\n			2. 显式内连接：\r\n				* 语法： select 字段列表 from 表名1 [inner] join 表名2 on 条件\r\n				* 例如：\r\n					* SELECT * FROM emp INNER JOIN dept ON emp.`dept_id` = dept.`id`;	\r\n					* SELECT * FROM emp JOIN dept ON emp.`dept_id` = dept.`id`;	\r\n\r\n			3. 内连接查询：\r\n				1. 从哪些表中查询数据\r\n				2. 条件是什么\r\n				3. 查询哪些字段\r\n		2. 外链接查询：\r\n			1. 左外连接：\r\n				* 语法：select 字段列表 from 表1 left [outer] join 表2 on 条件；\r\n				* 查询的是左表所有数据以及其交集部分。\r\n				* 例子：\r\n					-- 查询所有员工信息，如果员工有部门，则查询部门名称，没有部门，则不显示部门名称\r\n					SELECT 	t1.*,t2.`name` FROM emp t1 LEFT JOIN dept t2 ON t1.`dept_id` = t2.`id`;\r\n			2. 右外连接：\r\n				* 语法：select 字段列表 from 表1 right [outer] join 表2 on 条件；\r\n				* 查询的是右表所有数据以及其交集部分。\r\n				* 例子：\r\n					SELECT 	* FROM dept t2 RIGHT JOIN emp t1 ON t1.`dept_id` = t2.`id`;\r\n		3. 子查询：\r\n			* 概念：查询中嵌套查询，称嵌套查询为子查询。\r\n				-- 查询工资最高的员工信息\r\n				-- 1 查询最高的工资是多少 9000\r\n				SELECT MAX(salary) FROM emp;\r\n				\r\n				-- 2 查询员工信息，并且工资等于9000的\r\n				SELECT * FROM emp WHERE emp.`salary` = 9000;\r\n				\r\n				-- 一条sql就完成这个操作。子查询\r\n				SELECT * FROM emp WHERE emp.`salary` = (SELECT MAX(salary) FROM emp);\r\n\r\n			* 子查询不同情况\r\n				1. 子查询的结果是单行单列的：\r\n					* 子查询可以作为条件，使用运算符去判断。 运算符： > >= < <= =\r\n					* \r\n					-- 查询员工工资小于平均工资的人\r\n					SELECT * FROM emp WHERE emp.salary < (SELECT AVG(salary) FROM emp);\r\n				2. 子查询的结果是多行单列的：\r\n					* 子查询可以作为条件，使用运算符in来判断\r\n					-- 查询\'财务部\'和\'市场部\'所有的员工信息\r\n					SELECT id FROM dept WHERE NAME = \'财务部\' OR NAME = \'市场部\';\r\n					SELECT * FROM emp WHERE dept_id = 3 OR dept_id = 2;\r\n					-- 子查询\r\n					SELECT * FROM emp WHERE dept_id IN (SELECT id FROM dept WHERE NAME = \'财务部\' OR NAME = \'市场部\');\r\n\r\n				3. 子查询的结果是多行多列的：\r\n					* 子查询可以作为一张虚拟表参与查询\r\n					-- 查询员工入职日期是2011-11-11日之后的员工信息和部门信息\r\n					-- 子查询\r\n					SELECT * FROM dept t1 ,(SELECT * FROM emp WHERE emp.`join_date` > \'2011-11-11\') t2\r\n					WHERE t1.id = t2.dept_id;\r\n					\r\n					-- 普通内连接\r\n					SELECT * FROM emp t1,dept t2 WHERE t1.`dept_id` = t2.`id` AND t1.`join_date` >  \'2011-11-11\'\r\n\r\n		* 多表查询练习\r\n\r\n				-- 部门表\r\n				CREATE TABLE dept (\r\n				  id INT PRIMARY KEY PRIMARY KEY, -- 部门id\r\n				  dname VARCHAR(50), -- 部门名称\r\n				  loc VARCHAR(50) -- 部门所在地\r\n				);\r\n				\r\n				-- 添加4个部门\r\n				INSERT INTO dept(id,dname,loc) VALUES \r\n				(10,\'教研部\',\'北京\'),\r\n				(20,\'学工部\',\'上海\'),\r\n				(30,\'销售部\',\'广州\'),\r\n				(40,\'财务部\',\'深圳\');\r\n				\r\n				\r\n				\r\n				-- 职务表，职务名称，职务描述\r\n				CREATE TABLE job (\r\n				  id INT PRIMARY KEY,\r\n				  jname VARCHAR(20),\r\n				  description VARCHAR(50)\r\n				);\r\n				\r\n				-- 添加4个职务\r\n				INSERT INTO job (id, jname, description) VALUES\r\n				(1, \'董事长\', \'管理整个公司，接单\'),\r\n				(2, \'经理\', \'管理部门员工\'),\r\n				(3, \'销售员\', \'向客人推销产品\'),\r\n				(4, \'文员\', \'使用办公软件\');\r\n				\r\n				\r\n				\r\n				-- 员工表\r\n				CREATE TABLE emp (\r\n				  id INT PRIMARY KEY, -- 员工id\r\n				  ename VARCHAR(50), -- 员工姓名\r\n				  job_id INT, -- 职务id\r\n				  mgr INT , -- 上级领导\r\n				  joindate DATE, -- 入职日期\r\n				  salary DECIMAL(7,2), -- 工资\r\n				  bonus DECIMAL(7,2), -- 奖金\r\n				  dept_id INT, -- 所在部门编号\r\n				  CONSTRAINT emp_jobid_ref_job_id_fk FOREIGN KEY (job_id) REFERENCES job (id),\r\n				  CONSTRAINT emp_deptid_ref_dept_id_fk FOREIGN KEY (dept_id) REFERENCES dept (id)\r\n				);\r\n				\r\n				-- 添加员工\r\n				INSERT INTO emp(id,ename,job_id,mgr,joindate,salary,bonus,dept_id) VALUES \r\n				(1001,\'孙悟空\',4,1004,\'2000-12-17\',\'8000.00\',NULL,20),\r\n				(1002,\'卢俊义\',3,1006,\'2001-02-20\',\'16000.00\',\'3000.00\',30),\r\n				(1003,\'林冲\',3,1006,\'2001-02-22\',\'12500.00\',\'5000.00\',30),\r\n				(1004,\'唐僧\',2,1009,\'2001-04-02\',\'29750.00\',NULL,20),\r\n				(1005,\'李逵\',4,1006,\'2001-09-28\',\'12500.00\',\'14000.00\',30),\r\n				(1006,\'宋江\',2,1009,\'2001-05-01\',\'28500.00\',NULL,30),\r\n				(1007,\'刘备\',2,1009,\'2001-09-01\',\'24500.00\',NULL,10),\r\n				(1008,\'猪八戒\',4,1004,\'2007-04-19\',\'30000.00\',NULL,20),\r\n				(1009,\'罗贯中\',1,NULL,\'2001-11-17\',\'50000.00\',NULL,10),\r\n				(1010,\'吴用\',3,1006,\'2001-09-08\',\'15000.00\',\'0.00\',30),\r\n				(1011,\'沙僧\',4,1004,\'2007-05-23\',\'11000.00\',NULL,20),\r\n				(1012,\'李逵\',4,1006,\'2001-12-03\',\'9500.00\',NULL,30),\r\n				(1013,\'小白龙\',4,1004,\'2001-12-03\',\'30000.00\',NULL,20),\r\n				(1014,\'关羽\',4,1007,\'2002-01-23\',\'13000.00\',NULL,10);\r\n				\r\n				\r\n				\r\n				-- 工资等级表\r\n				CREATE TABLE salarygrade (\r\n				  grade INT PRIMARY KEY,   -- 级别\r\n				  losalary INT,  -- 最低工资\r\n				  hisalary INT -- 最高工资\r\n				);\r\n				\r\n				-- 添加5个工资等级\r\n				INSERT INTO salarygrade(grade,losalary,hisalary) VALUES \r\n				(1,7000,12000),\r\n				(2,12010,14000),\r\n				(3,14010,20000),\r\n				(4,20010,30000),\r\n				(5,30010,99990);\r\n				\r\n				-- 需求：\r\n				\r\n				-- 1.查询所有员工信息。查询员工编号，员工姓名，工资，职务名称，职务描述\r\n				/*\r\n					分析：\r\n						1.员工编号，员工姓名，工资，需要查询emp表  职务名称，职务描述 需要查询job表\r\n						2.查询条件 emp.job_id = job.id\r\n				\r\n				*/\r\n				SELECT \r\n					t1.`id`, -- 员工编号\r\n					t1.`ename`, -- 员工姓名\r\n					t1.`salary`,-- 工资\r\n					t2.`jname`, -- 职务名称\r\n					t2.`description` -- 职务描述\r\n				FROM \r\n					emp t1, job t2\r\n				WHERE \r\n					t1.`job_id` = t2.`id`;\r\n				\r\n				\r\n				\r\n				-- 2.查询员工编号，员工姓名，工资，职务名称，职务描述，部门名称，部门位置\r\n				/*\r\n					分析：\r\n						1. 员工编号，员工姓名，工资 emp  职务名称，职务描述 job  部门名称，部门位置 dept\r\n						2. 条件： emp.job_id = job.id and emp.dept_id = dept.id\r\n				*/\r\n				\r\n				SELECT \r\n					t1.`id`, -- 员工编号\r\n					t1.`ename`, -- 员工姓名\r\n					t1.`salary`,-- 工资\r\n					t2.`jname`, -- 职务名称\r\n					t2.`description`, -- 职务描述\r\n					t3.`dname`, -- 部门名称\r\n					t3.`loc` -- 部门位置\r\n				FROM \r\n					emp t1, job t2,dept t3\r\n				WHERE \r\n					t1.`job_id` = t2.`id` AND t1.`dept_id` = t3.`id`;\r\n				   \r\n				-- 3.查询员工姓名，工资，工资等级\r\n				/*\r\n					分析：\r\n						1.员工姓名，工资 emp  工资等级 salarygrade\r\n						2.条件 emp.salary >= salarygrade.losalary and emp.salary <= salarygrade.hisalary\r\n							emp.salary BETWEEN salarygrade.losalary and salarygrade.hisalary\r\n				*/\r\n				SELECT \r\n					t1.ename ,\r\n					t1.`salary`,\r\n					t2.*\r\n				FROM emp t1, salarygrade t2\r\n				WHERE t1.`salary` BETWEEN t2.`losalary` AND t2.`hisalary`;\r\n				\r\n				\r\n				\r\n				-- 4.查询员工姓名，工资，职务名称，职务描述，部门名称，部门位置，工资等级\r\n				/*\r\n					分析：\r\n						1. 员工姓名，工资 emp ， 职务名称，职务描述 job 部门名称，部门位置，dept  工资等级 salarygrade\r\n						2. 条件： emp.job_id = job.id and emp.dept_id = dept.id and emp.salary BETWEEN salarygrade.losalary and salarygrade.hisalary\r\n							\r\n				*/\r\n				SELECT \r\n					t1.`ename`,\r\n					t1.`salary`,\r\n					t2.`jname`,\r\n					t2.`description`,\r\n					t3.`dname`,\r\n					t3.`loc`,\r\n					t4.`grade`\r\n				FROM \r\n					emp t1,job t2,dept t3,salarygrade t4\r\n				WHERE \r\n					t1.`job_id` = t2.`id` \r\n					AND t1.`dept_id` = t3.`id`\r\n					AND t1.`salary` BETWEEN t4.`losalary` AND t4.`hisalary`;\r\n				\r\n				\r\n				\r\n				-- 5.查询出部门编号、部门名称、部门位置、部门人数\r\n				\r\n				/*\r\n					分析：\r\n						1.部门编号、部门名称、部门位置 dept 表。 部门人数 emp表\r\n						2.使用分组查询。按照emp.dept_id完成分组，查询count(id)\r\n						3.使用子查询将第2步的查询结果和dept表进行关联查询\r\n						\r\n				*/\r\n				SELECT \r\n					t1.`id`,t1.`dname`,t1.`loc` , t2.total\r\n				FROM \r\n					dept t1,\r\n					(SELECT\r\n						dept_id,COUNT(id) total\r\n					FROM \r\n						emp\r\n					GROUP BY dept_id) t2\r\n				WHERE t1.`id` = t2.dept_id;\r\n				\r\n				\r\n				-- 6.查询所有员工的姓名及其直接上级的姓名,没有领导的员工也需要查询\r\n				\r\n				/*\r\n					分析：\r\n						1.姓名 emp， 直接上级的姓名 emp\r\n							* emp表的id 和 mgr 是自关联\r\n						2.条件 emp.id = emp.mgr\r\n						3.查询左表的所有数据，和 交集数据\r\n							* 使用左外连接查询\r\n					\r\n				*/\r\n				/*\r\n				select\r\n					t1.ename,\r\n					t1.mgr,\r\n					t2.`id`,\r\n					t2.ename\r\n				from emp t1, emp t2\r\n				where t1.mgr = t2.`id`;\r\n				\r\n				*/\r\n				\r\n				SELECT \r\n					t1.ename,\r\n					t1.mgr,\r\n					t2.`id`,\r\n					t2.`ename`\r\n				FROM emp t1\r\n				LEFT JOIN emp t2\r\n				ON t1.`mgr` = t2.`id`;\r\n\r\n\r\n## 事务\r\n\r\n	1. 事务的基本介绍\r\n		1. 概念：\r\n			*  如果一个包含多个步骤的业务操作，被事务管理，那么这些操作要么同时成功，要么同时失败。\r\n			\r\n		2. 操作：\r\n			1. 开启事务： start transaction;\r\n			2. 回滚：rollback;\r\n			3. 提交：commit;\r\n		3. 例子：\r\n			CREATE TABLE account (\r\n				id INT PRIMARY KEY AUTO_INCREMENT,\r\n				NAME VARCHAR(10),\r\n				balance DOUBLE\r\n			);\r\n			-- 添加数据\r\n			INSERT INTO account (NAME, balance) VALUES (\'zhangsan\', 1000), (\'lisi\', 1000);\r\n			\r\n			\r\n			SELECT * FROM account;\r\n			UPDATE account SET balance = 1000;\r\n			-- 张三给李四转账 500 元\r\n			\r\n			-- 0. 开启事务\r\n			START TRANSACTION;\r\n			-- 1. 张三账户 -500\r\n			\r\n			UPDATE account SET balance = balance - 500 WHERE NAME = \'zhangsan\';\r\n			-- 2. 李四账户 +500\r\n			-- 出错了...\r\n			UPDATE account SET balance = balance + 500 WHERE NAME = \'lisi\';\r\n			\r\n			-- 发现执行没有问题，提交事务\r\n			COMMIT;\r\n			\r\n			-- 发现出问题了，回滚事务\r\n			ROLLBACK;\r\n		4. MySQL数据库中事务默认自动提交\r\n			\r\n			* 事务提交的两种方式：\r\n				* 自动提交：\r\n					* mysql就是自动提交的\r\n					* 一条DML(增删改)语句会自动提交一次事务。\r\n				* 手动提交：\r\n					* Oracle 数据库默认是手动提交事务\r\n					* 需要先开启事务，再提交\r\n			* 修改事务的默认提交方式：\r\n				* 查看事务的默认提交方式：SELECT @@autocommit; -- 1 代表自动提交  0 代表手动提交\r\n				* 修改默认提交方式： set @@autocommit = 0;\r\n\r\n\r\n	2. 事务的四大特征：\r\n		1. 原子性：是不可分割的最小操作单位，要么同时成功，要么同时失败。\r\n		2. 持久性：当事务提交或回滚后，数据库会持久化的保存数据。\r\n		3. 隔离性：多个事务之间。相互独立。\r\n		4. 一致性：事务操作前后，数据总量不变\r\n	3. 事务的隔离级别（了解）\r\n		* 概念：多个事务之间隔离的，相互独立的。但是如果多个事务操作同一批数据，则会引发一些问题，设置不同的隔离级别就可以解决这些问题。\r\n		* 存在问题：\r\n			1. 脏读：一个事务，读取到另一个事务中没有提交的数据\r\n			2. 不可重复读(虚读)：在同一个事务中，两次读取到的数据不一样。\r\n			3. 幻读：一个事务操作(DML)数据表中所有记录，另一个事务添加了一条数据，则第一个事务查询不到自己的修改。\r\n		* 隔离级别：\r\n			1. read uncommitted：读未提交\r\n				* 产生的问题：脏读、不可重复读、幻读\r\n			2. read committed：读已提交 （Oracle）\r\n				* 产生的问题：不可重复读、幻读\r\n			3. repeatable read：可重复读 （MySQL默认）\r\n				* 产生的问题：幻读\r\n			4. serializable：串行化\r\n				* 可以解决所有的问题\r\n\r\n			* 注意：隔离级别从小到大安全性越来越高，但是效率越来越低\r\n			* 数据库查询隔离级别：\r\n				* select @@tx_isolation;\r\n			* 数据库设置隔离级别：\r\n				* set global transaction isolation level  级别字符串;\r\n\r\n		* 演示：\r\n			set global transaction isolation level read uncommitted;\r\n			start transaction;\r\n			-- 转账操作\r\n			update account set balance = balance - 500 where id = 1;\r\n			update account set balance = balance + 500 where id = 2;\r\n\r\n\r\n\r\n## DCL：\r\n	* SQL分类：\r\n		1. DDL：操作数据库和表\r\n		2. DML：增删改表中数据\r\n		3. DQL：查询表中数据\r\n		4. DCL：管理用户，授权\r\n\r\n	* DBA：数据库管理员\r\n\r\n	* DCL：管理用户，授权\r\n		1. 管理用户\r\n			1. 添加用户：\r\n				* 语法：CREATE USER \'用户名\'@\'主机名\' IDENTIFIED BY \'密码\';\r\n			2. 删除用户：\r\n				* 语法：DROP USER \'用户名\'@\'主机名\';\r\n			3. 修改用户密码：\r\n				\r\n				UPDATE USER SET PASSWORD = PASSWORD(\'新密码\') WHERE USER = \'用户名\';\r\n				UPDATE USER SET PASSWORD = PASSWORD(\'abc\') WHERE USER = \'lisi\';\r\n				\r\n				SET PASSWORD FOR \'用户名\'@\'主机名\' = PASSWORD(\'新密码\');\r\n				SET PASSWORD FOR \'root\'@\'localhost\' = PASSWORD(\'123\');\r\n\r\n				* mysql中忘记了root用户的密码？\r\n					1. cmd -- > net stop mysql 停止mysql服务\r\n						* 需要管理员运行该cmd\r\n\r\n					2. 使用无验证方式启动mysql服务： mysqld --skip-grant-tables\r\n					3. 打开新的cmd窗口,直接输入mysql命令，敲回车。就可以登录成功\r\n					4. use mysql;\r\n					5. update user set password = password(\'你的新密码\') where user = \'root\';\r\n					6. 关闭两个窗口\r\n					7. 打开任务管理器，手动结束mysqld.exe 的进程\r\n					8. 启动mysql服务\r\n					9. 使用新密码登录。\r\n			4. 查询用户：\r\n				-- 1. 切换到mysql数据库\r\n				USE myql;\r\n				-- 2. 查询user表\r\n				SELECT * FROM USER;\r\n				\r\n				* 通配符： % 表示可以在任意主机使用用户登录数据库\r\n\r\n		2. 权限管理：\r\n			1. 查询权限：\r\n				-- 查询权限\r\n				SHOW GRANTS FOR \'用户名\'@\'主机名\';\r\n				SHOW GRANTS FOR \'lisi\'@\'%\';\r\n\r\n			2. 授予权限：\r\n				-- 授予权限\r\n				grant 权限列表 on 数据库名.表名 to \'用户名\'@\'主机名\';\r\n				-- 给张三用户授予所有权限，在任意数据库任意表上\r\n				\r\n				GRANT ALL ON *.* TO \'zhangsan\'@\'localhost\';\r\n			3. 撤销权限：\r\n				-- 撤销权限：\r\n				revoke 权限列表 on 数据库名.表名 from \'用户名\'@\'主机名\';\r\n				REVOKE UPDATE ON db3.`account` FROM \'lisi\'@\'%\';',1,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2020-01-17 16:58:18','2020-11-29 11:45:12',0),(121,'MySQL约束课堂笔记','# 今日内容\r\n	\r\n	1. DQL:查询语句\r\n		1. 排序查询\r\n		2. 聚合函数\r\n		3. 分组查询\r\n		4. 分页查询\r\n\r\n	2. 约束\r\n	3. 多表之间的关系\r\n	4. 范式\r\n	5. 数据库的备份和还原\r\n\r\n# DQL:查询语句\r\n	1. 排序查询\r\n		* 语法：order by 子句\r\n			* order by 排序字段1 排序方式1 ，  排序字段2 排序方式2...\r\n\r\n		* 排序方式：\r\n			* ASC：升序，默认的。\r\n			* DESC：降序。\r\n\r\n		* 注意：\r\n			* 如果有多个排序条件，则当前边的条件值一样时，才会判断第二条件。\r\n\r\n\r\n	2. 聚合函数：将一列数据作为一个整体，进行纵向的计算。\r\n		1. count：计算个数\r\n			1. 一般选择非空的列：主键\r\n			2. count(*)\r\n		2. max：计算最大值\r\n		3. min：计算最小值\r\n		4. sum：计算和\r\n		5. avg：计算平均值\r\n		\r\n\r\n		* 注意：聚合函数的计算，排除null值。\r\n			解决方案：\r\n				1. 选择不包含非空的列进行计算\r\n				2. IFNULL函数\r\n\r\n	3. 分组查询:\r\n		1. 语法：group by 分组字段；\r\n		2. 注意：\r\n			1. 分组之后查询的字段：分组字段、聚合函数\r\n			2. where 和 having 的区别？\r\n				1. where 在分组之前进行限定，如果不满足条件，则不参与分组。having在分组之后进行限定，如果不满足结果，则不会被查询出来\r\n				2. where 后不可以跟聚合函数，having可以进行聚合函数的判断。\r\n\r\n			-- 按照性别分组。分别查询男、女同学的平均分\r\n\r\n			SELECT sex , AVG(math) FROM student GROUP BY sex;\r\n			\r\n			-- 按照性别分组。分别查询男、女同学的平均分,人数\r\n			\r\n			SELECT sex , AVG(math),COUNT(id) FROM student GROUP BY sex;\r\n			\r\n			--  按照性别分组。分别查询男、女同学的平均分,人数 要求：分数低于70分的人，不参与分组\r\n			SELECT sex , AVG(math),COUNT(id) FROM student WHERE math > 70 GROUP BY sex;\r\n			\r\n			--  按照性别分组。分别查询男、女同学的平均分,人数 要求：分数低于70分的人，不参与分组,分组之后。人数要大于2个人\r\n			SELECT sex , AVG(math),COUNT(id) FROM student WHERE math > 70 GROUP BY sex HAVING COUNT(id) > 2;\r\n			\r\n			SELECT sex , AVG(math),COUNT(id) 人数 FROM student WHERE math > 70 GROUP BY sex HAVING 人数 > 2;\r\n\r\n\r\n			\r\n	4. 分页查询\r\n		1. 语法：limit 开始的索引,每页查询的条数;\r\n		2. 公式：开始的索引 = （当前的页码 - 1） * 每页显示的条数\r\n			-- 每页显示3条记录 \r\n\r\n			SELECT * FROM student LIMIT 0,3; -- 第1页\r\n			\r\n			SELECT * FROM student LIMIT 3,3; -- 第2页\r\n			\r\n			SELECT * FROM student LIMIT 6,3; -- 第3页\r\n\r\n		3. limit 是一个MySQL\"方言\"\r\n\r\n\r\n## 约束\r\n	* 概念： 对表中的数据进行限定，保证数据的正确性、有效性和完整性。	\r\n	* 分类：\r\n		1. 主键约束：primary key\r\n		2. 非空约束：not null\r\n		3. 唯一约束：unique\r\n		4. 外键约束：foreign key\r\n\r\n	* 非空约束：not null，某一列的值不能为null\r\n		1. 创建表时添加约束\r\n			CREATE TABLE stu(\r\n				id INT,\r\n				NAME VARCHAR(20) NOT NULL -- name为非空\r\n			);\r\n		2. 创建表完后，添加非空约束\r\n			ALTER TABLE stu MODIFY NAME VARCHAR(20) NOT NULL;\r\n\r\n		3. 删除name的非空约束\r\n			ALTER TABLE stu MODIFY NAME VARCHAR(20);\r\n\r\n	* 唯一约束：unique，某一列的值不能重复\r\n		1. 注意：\r\n			* 唯一约束可以有NULL值，但是只能有一条记录为null\r\n		2. 在创建表时，添加唯一约束\r\n			CREATE TABLE stu(\r\n				id INT,\r\n				phone_number VARCHAR(20) UNIQUE -- 手机号\r\n			);\r\n		3. 删除唯一约束\r\n			ALTER TABLE stu DROP INDEX phone_number;\r\n		4. 在表创建完后，添加唯一约束\r\n			ALTER TABLE stu MODIFY phone_number VARCHAR(20) UNIQUE;\r\n	\r\n	* 主键约束：primary key。\r\n		1. 注意：\r\n			1. 含义：非空且唯一\r\n			2. 一张表只能有一个字段为主键\r\n			3. 主键就是表中记录的唯一标识\r\n\r\n		2. 在创建表时，添加主键约束\r\n			create table stu(\r\n				id int primary key,-- 给id添加主键约束\r\n				name varchar(20)\r\n			);\r\n\r\n		3. 删除主键\r\n			-- 错误 alter table stu modify id int ;\r\n			ALTER TABLE stu DROP PRIMARY KEY;\r\n\r\n		4. 创建完表后，添加主键\r\n			ALTER TABLE stu MODIFY id INT PRIMARY KEY;\r\n\r\n		5. 自动增长：\r\n			1.  概念：如果某一列是数值类型的，使用 auto_increment 可以来完成值得自动增长\r\n\r\n			2. 在创建表时，添加主键约束，并且完成主键自增长\r\n			create table stu(\r\n				id int primary key auto_increment,-- 给id添加主键约束\r\n				name varchar(20)\r\n			);\r\n\r\n			\r\n			3. 删除自动增长\r\n			ALTER TABLE stu MODIFY id INT;\r\n			4. 添加自动增长\r\n			ALTER TABLE stu MODIFY id INT AUTO_INCREMENT;\r\n\r\n\r\n	* 外键约束：foreign key,让表于表产生关系，从而保证数据的正确性。\r\n		1. 在创建表时，可以添加外键\r\n			* 语法：\r\n				create table 表名(\r\n					....\r\n					外键列\r\n					constraint 外键名称 foreign key (外键列名称) references 主表名称(主表列名称)\r\n				);\r\n\r\n		2. 删除外键\r\n			ALTER TABLE 表名 DROP FOREIGN KEY 外键名称;\r\n\r\n		3. 创建表之后，添加外键\r\n			ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称);\r\n		\r\n		\r\n		4. 级联操作\r\n			1. 添加级联操作\r\n				语法：ALTER TABLE 表名 ADD CONSTRAINT 外键名称 \r\n						FOREIGN KEY (外键字段名称) REFERENCES 主表名称(主表列名称) ON UPDATE CASCADE ON DELETE CASCADE  ;\r\n			2. 分类：\r\n				1. 级联更新：ON UPDATE CASCADE \r\n				2. 级联删除：ON DELETE CASCADE \r\n	\r\n\r\n## 数据库的设计\r\n\r\n	1. 多表之间的关系\r\n		1. 分类：\r\n			1. 一对一(了解)：\r\n				* 如：人和身份证\r\n				* 分析：一个人只有一个身份证，一个身份证只能对应一个人\r\n			2. 一对多(多对一)：\r\n				* 如：部门和员工\r\n				* 分析：一个部门有多个员工，一个员工只能对应一个部门\r\n			3. 多对多：\r\n				* 如：学生和课程\r\n				* 分析：一个学生可以选择很多门课程，一个课程也可以被很多学生选择\r\n		2. 实现关系：\r\n			1. 一对多(多对一)：\r\n				* 如：部门和员工\r\n				* 实现方式：在多的一方建立外键，指向一的一方的主键。\r\n			2. 多对多：\r\n				* 如：学生和课程\r\n				* 实现方式：多对多关系实现需要借助第三张中间表。中间表至少包含两个字段，这两个字段作为第三张表的外键，分别指向两张表的主键\r\n			3. 一对一(了解)：\r\n				* 如：人和身份证\r\n				* 实现方式：一对一关系实现，可以在任意一方添加唯一外键指向另一方的主键。\r\n\r\n		3. 案例\r\n			-- 创建旅游线路分类表 tab_category\r\n			-- cid 旅游线路分类主键，自动增长\r\n			-- cname 旅游线路分类名称非空，唯一，字符串 100\r\n			CREATE TABLE tab_category (\r\n				cid INT PRIMARY KEY AUTO_INCREMENT,\r\n				cname VARCHAR(100) NOT NULL UNIQUE\r\n			);\r\n			\r\n			-- 创建旅游线路表 tab_route\r\n			/*\r\n			rid 旅游线路主键，自动增长\r\n			rname 旅游线路名称非空，唯一，字符串 100\r\n			price 价格\r\n			rdate 上架时间，日期类型\r\n			cid 外键，所属分类\r\n			*/\r\n			CREATE TABLE tab_route(\r\n				rid INT PRIMARY KEY AUTO_INCREMENT,\r\n				rname VARCHAR(100) NOT NULL UNIQUE,\r\n				price DOUBLE,\r\n				rdate DATE,\r\n				cid INT,\r\n				FOREIGN KEY (cid) REFERENCES tab_category(cid)\r\n			);\r\n			\r\n			/*创建用户表 tab_user\r\n			uid 用户主键，自增长\r\n			username 用户名长度 100，唯一，非空\r\n			password 密码长度 30，非空\r\n			name 真实姓名长度 100\r\n			birthday 生日\r\n			sex 性别，定长字符串 1\r\n			telephone 手机号，字符串 11\r\n			email 邮箱，字符串长度 100\r\n			*/\r\n			CREATE TABLE tab_user (\r\n				uid INT PRIMARY KEY AUTO_INCREMENT,\r\n				username VARCHAR(100) UNIQUE NOT NULL,\r\n				PASSWORD VARCHAR(30) NOT NULL,\r\n				NAME VARCHAR(100),\r\n				birthday DATE,\r\n				sex CHAR(1) DEFAULT \'男\',\r\n				telephone VARCHAR(11),\r\n				email VARCHAR(100)\r\n			);\r\n			\r\n			/*\r\n			创建收藏表 tab_favorite\r\n			rid 旅游线路 id，外键\r\n			date 收藏时间\r\n			uid 用户 id，外键\r\n			rid 和 uid 不能重复，设置复合主键，同一个用户不能收藏同一个线路两次\r\n			*/\r\n			CREATE TABLE tab_favorite (\r\n				rid INT, -- 线路id\r\n				DATE DATETIME,\r\n				uid INT, -- 用户id\r\n				-- 创建复合主键\r\n				PRIMARY KEY(rid,uid), -- 联合主键\r\n				FOREIGN KEY (rid) REFERENCES tab_route(rid),\r\n				FOREIGN KEY(uid) REFERENCES tab_user(uid)\r\n			);\r\n\r\n		\r\n	2. 数据库设计的范式\r\n		* 概念：设计数据库时，需要遵循的一些规范。要遵循后边的范式要求，必须先遵循前边的所有范式要求\r\n\r\n			设计关系数据库时，遵从不同的规范要求，设计出合理的关系型数据库，这些不同的规范要求被称为不同的范式，各种范式呈递次规范，越高的范式数据库冗余越小。\r\n			目前关系数据库有六种范式：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。\r\n\r\n		* 分类：\r\n			1. 第一范式（1NF）：每一列都是不可分割的原子数据项\r\n			2. 第二范式（2NF）：在1NF的基础上，非码属性必须完全依赖于码（在1NF基础上消除非主属性对主码的部分函数依赖）\r\n				* 几个概念：\r\n					1. 函数依赖：A-->B,如果通过A属性(属性组)的值，可以确定唯一B属性的值。则称B依赖于A\r\n						例如：学号-->姓名。  （学号，课程名称） --> 分数\r\n					2. 完全函数依赖：A-->B， 如果A是一个属性组，则B属性值得确定需要依赖于A属性组中所有的属性值。\r\n						例如：（学号，课程名称） --> 分数\r\n					3. 部分函数依赖：A-->B， 如果A是一个属性组，则B属性值得确定只需要依赖于A属性组中某一些值即可。\r\n						例如：（学号，课程名称） -- > 姓名\r\n					4. 传递函数依赖：A-->B, B -- >C . 如果通过A属性(属性组)的值，可以确定唯一B属性的值，在通过B属性（属性组）的值可以确定唯一C属性的值，则称 C 传递函数依赖于A\r\n						例如：学号-->系名，系名-->系主任\r\n					5. 码：如果在一张表中，一个属性或属性组，被其他所有属性所完全依赖，则称这个属性(属性组)为该表的码\r\n						例如：该表中码为：（学号，课程名称）\r\n						* 主属性：码属性组中的所有属性\r\n						* 非主属性：除过码属性组的属性\r\n						\r\n			3. 第三范式（3NF）：在2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖）\r\n\r\n\r\n## 数据库的备份和还原\r\n\r\n	1. 命令行：\r\n		* 语法：\r\n			* 备份： mysqldump -u用户名 -p密码 数据库名称 > 保存的路径\r\n			* 还原：\r\n				1. 登录数据库\r\n				2. 创建数据库\r\n				3. 使用数据库\r\n				4. 执行文件。source 文件路径\r\n	2. 图形化工具：',1,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2020-01-17 17:00:36','2020-11-29 11:45:12',0),(122,'pip命令','#### 安装包\npip install <包名>\n#### 查看已安装的包\npip list\n#### 查看可升级的的包\npip list -o\n#### 升级\npip install -U <包名>\n#### 卸载包\npip uninstall <包名>\n#### 指定单次安装源\npip install <包名> -i https://mirrors.aliyun.com/pypi/simple\n#### 显示包所在的位置\npip show <包名>',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2020-02-21 14:28:24','2020-11-29 11:45:12',0),(123,'python准备','# 课前准备\n[pycharm](https://www.jetbrains.com/)\n[python3.7](https://www.python.org/downloads/)\n\n    pycharm专业版本社区版本都ok\n    \n## 激活地址\n    http://elporfirio.com:1017/\n    http://idea.imsxm.com/\n    \n## 文档地址\n    https://docs.python.org/zh-cn/3/\n    \n    \n```java\n\nclass A{\n    public static void main(String args[]){\n        System.out.println(\"hello world\");\n    }\n}\n\n<!--python-->\nprint(\"hello world\")\n```\n    pip 包安装管理工具的使用\n    1.pip list # 查看已安装模块\n    2.pip install django # 安装模块\n    3.pip uninstall django #卸载模块\n    4.pip download 下载包\n    5. pip -i 指定包源',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2019-07-05 15:49:52','2020-11-29 11:45:12',0),(124,'socket（tcp）','它是位于tcp和应用层之间的桥梁，用于应用与应用之间的通信\n\n### tcp的三次握手与四次挥手\n#### 三次握手\n![image](http://blog.chinaunix.net/attachment/201304/8/22312037_1365405910EROI.png)\n#### 四次挥手\n![image](http://blog.chinaunix.net/attachment/201304/9/22312037_1365503104wDR0.png)\n### socket收发消息原理\n内存分为内核内存与用户内存：<br>\n1.内核内存中存放操作系统的应用<br>\n2.用户内存存放普通应用\n\n实现过程：<br>\n1.socket应用程序将要发送的信息传入内核内存<br>\n2.操作系统通过网卡发送消息<br>\n3.另一网卡接收消息存入内核内存<br>\n4.socket应用程序从内核内存读入消息\n\n### 服务端\nAF_INET（又称 PF_INET）是 IPv4 网络协议的套接字类型，AF_INET6 则是 IPv6 的；而 AF_UNIX 则是 Unix 系统本地通信。\n\n选择 AF_INET 的目的就是使用 IPv4 进行通信。因为 IPv4 使用 32 位地址，相比 IPv6 的 128 位来说，计算更快，便于用于局域网通信。\n\n而且 AF_INET 相比 AF_UNIX 更具通用性，因为 Windows 上有 AF_INET 而没有 AF_UNIX。\n```python\nimport socket\n\n# 创建一个传输对象（使用网络的TCP协议）\ntcp_server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n# 解决Unix系统下端口占用问题\ntcp_server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n# 绑定\ntcp_server.bind((\"192.168.2.249\", 8000))\n# 控制半连接池中连接的个数\ntcp_server.listen(5)\nwhile True:\n    print(\"服务端开始运行\")\n    # 接受新的连接对象和地址（等待客户端）\n    connection, address = tcp_server.accept()\n\n    while True:\n        try:\n            data = connection.recv(1024)\n        except ConnectionResetError:\n            print(\"客户端断开连接\")\n            break\n        print(data.decode(\"utf-8\"))\n        # 发送消息\n        connection.send(data.upper())\n\n    # 关闭\n    connection.close()\n\ntcp_server.close()\n\n```\n### 客户端\n```python\nimport socket\n\ntcp_sever = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\ntcp_sever.connect((\"192.168.2.249\", 8000))\n\n# 以二进制方式发送\nwhile True:\n    msg = input(\">>:\")\n    tcp_sever.send(msg.encode(\"utf-8\"))\n    data = tcp_sever.recv(1024)\n    print(data.decode(\"utf-8\"))\n\n```',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2019-11-19 09:25:36','2020-11-29 11:45:12',0),(125,'socket（udp）','udp不需要tcp的复杂的传输协议，只是发包与收包\n### 服务端\n```python\nimport socket\n\n# 数据报格式\nudp_sever = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\nudp_sever.bind((\"192.168.2.249\", 8000))\n\nwhile True:\n    data, address = udp_sever.recvfrom(1024)\n    udp_sever.sendto(data.upper(), address)\n\n```\n### 客户端\n```python\nimport socket\n\nudp_client = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\nwhile True:\n    msg = input(\">>\")\n    udp_client.sendto(msg.encode(\"utf-8\"), (\"192.168.2.249\", 8000))\n\n    data, address = udp_client.recvfrom(1024)\n    print(data.decode(\"utf-8\"))\n\n```',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2019-11-19 09:29:31','2020-11-29 11:45:12',0),(126,'tcp粘包解决方法','[TOC]\n\n### tcp粘包原理\n当缓存大小小于接受的数据大小会导致粘包\n### 粘包的解决\n核心思想为让客户端了解数据大小\n#### 服务端\n##### 通常写法\n1.发送数据的大小\n\n2.接受来自客户端的确认消息（防止Nagel算法介入）\n\n3.发送最后数据\n```python\n# 1.发送消息大小\n msg_len = len(final_result)\n msg_len = str(msg_len).encode()\n connection.send(msg_len)\n\n# 2.接受允许发送信号（防止TCP Nagle算法介入）\n signal = connection.recv(1024)\n # 3.发送消息\n if signal == b\"ready\":\n     connection.send(final_result)\n```\n\n##### 使用struct模块优化算法\n通过此模块的优点在于节省了在发送数据前的确认，较少服务器开销\n\n1.使用struct模块封装4个字节的长度数据\n\n2.发送长度数据和结果数据，由于Nagel算法导致数据一次性发送\n```python\nimport struct\nmsg_len = len(final_result)\nmsg_len = struct.pack(\"i\", msg_len)\n# 利用Nagle算法（一次性发送）\nconnection.send(msg_len)\nconnection.send(final_result)\n```\n#### 服务端全部代码\n```python\nimport socket\nimport subprocess\nimport struct\n\ntcp_server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\ntcp_server.bind((\"192.168.2.249\", 8000))\ntcp_server.listen(5)\n\nwhile True:\n    connection, address = tcp_server.accept()\n    while True:\n        print(\"服务端开始工作\")\n        try:\n            command = connection.recv(1024)\n            # 防止结果为空\n            if not command:\n                continue\n            print(\"收到的命令\", command.decode(\"utf_8\"))\n            if command.decode(\"utf-8\") == \"exit\":\n                break\n\n            # 使用管道进行输出\n            result = subprocess.Popen(command.decode(\"utf_8\"),\n                                      shell=True,\n                                      stderr=subprocess.PIPE,\n                                      stdout=subprocess.PIPE,\n                                      stdin=subprocess.PIPE)\n\n            error_msg = result.stderr.read()\n            if error_msg:\n                final_result = error_msg\n            else:\n                # 以GBK编码发送\n                final_result = result.stdout.read()\n            if not final_result:\n                final_result = \"执行成功\".encode(\"GBK\")\n\n            # # 1.发送消息大小\n            # msg_len = len(final_result)\n            # msg_len = str(msg_len).encode()\n            # connection.send(msg_len)\n            #\n            # # 2.接受允许发送信号（防止TCP Nagle算法介入）\n            # signal = connection.recv(1024)\n            # # 3.发送消息\n            # if signal == b\"ready\":\n            #     connection.send(final_result)\n\n            # 使用struck模块封装长度数据\n            msg_len = len(final_result)\n            msg_len = struct.pack(\"i\", msg_len)\n            # 利用Nagle算法（一次性发送）\n            connection.send(msg_len)\n            connection.send(final_result)\n\n        except ConnectionResetError:\n            break\n\n    connection.close()\n# tcp_server.close()\n\n```\n#### 客户端\n##### 通常写法\n1.接收来自客户端的数据大小信息\n\n2.向客户端发送准备信息\n\n3.接受数据（防止数据大于缓冲区使用while循环接受，最后输出）\n```python\n# tcp会出现粘包现象，而udp不会\nmsg_len = tcp_client.recv(1024)\n# msg_len以字节的方式记录长度\nif len(msg_len):\n    tcp_client.send(b\"ready\")\n\nmsg_len = int(msg_len.decode(\"utf-8\"))\n\n# 正式接受信息\nreceive_len = 0\nresult = b\"\"\nwhile receive_len < msg_len:\n    # Windows默认使用GBK编码\n    result += tcp_client.recv(1024)\n    receive_len += len(result)\nprint(result.decode(\"GBK\"))\n\n```\n##### 使用struct优化算法\n1.接收4个字节的长度数据\n\n2.接收剩余长度（使用while循环）\n```python\n    msg_len = tcp_client.recv(4)\n    msg_len = struct.unpack(\"i\", msg_len)[0]\n    receive_len = 0\n    result = b\"\"\n    # 2.接受剩余长度\n    while receive_len < msg_len:\n        # Windows默认使用GBK编码\n        result += tcp_client.recv(1024)\n        receive_len += len(result)\n    print(result.decode(\"GBK\"))\n```\n\n#### 客户端全部代码\n```python\nimport socket\nimport struct\n\ntcp_client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\ntcp_client.connect((\"192.168.2.249\", 8000))\n\nwhile True:\n    msg = input(\"myshell@USER->\")\n    if not msg:\n        continue\n    # 发送消息\n    tcp_client.send(msg.encode(\"utf-8\"))\n    if msg == \"exit\":\n        break\n    # tcp会出现粘包现象，而udp不会\n    # msg_len = tcp_client.recv(1024)  # msg_len以字节的方式记录长度\n    # if len(msg_len):\n    #     tcp_client.send(b\"ready\")\n    #\n    # msg_len = int(msg_len.decode(\"utf-8\"))\n    #\n    # # 正式接受信息\n    # receive_len = 0\n    # result = b\"\"\n    # while receive_len < msg_len:\n    #     # Windows默认使用GBK编码\n    #     result += tcp_client.recv(1024)\n    #     receive_len += len(result)\n    # print(result.decode(\"GBK\"))\n    # 1.首先接受4个字节长度\n    msg_len = tcp_client.recv(4)\n    # unpack返回一个元组\n    msg_len = struct.unpack(\"i\", msg_len)[0]\n    receive_len = 0\n    result = b\"\"\n    # 2.接受剩余长度\n    while receive_len < msg_len:\n        # Windows默认使用GBK编码\n        result += tcp_client.recv(1024)\n        receive_len += len(result)\n    print(result.decode(\"GBK\"))\ntcp_client.close()\n\n```',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2019-11-20 23:04:17','2020-11-29 11:45:12',0),(127,'反射','### 作用\n使用字符串调用函数，不需要大量的if elif判断\n### 代码\n```python\nfunc = input(\"请输入要被执行的函数名称：\")\n\n\nclass Function:\n    def test(self):\n        if hasattr(self, func):\n            obj = getattr(self, func)\n            obj()\n\n    @staticmethod\n    def a():\n        print(\"调用a\")\n\n    @staticmethod\n    def b():\n        print(\"调用b\")\n\n\na = Function()\na.test()\n```',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2019-11-24 22:54:19','2020-11-29 11:45:12',0),(128,'Readme','### 简介\r\n看视频写的FTP服务器<br>\r\n### 使用方法\r\n#### 服务端\r\n启动文件为FTP_server/bin/ftp_server.py<br>\r\n使用cmd启动(python ftp_client.py start)<br>\r\n#### 客户端\r\n使用cmd启动(python ftp_client.py start)<br>\r\n基本的Linux命令\r\n1.上传：put (filename) (target_dirname)<br>\r\n2.校验文件：verify (filename)<br>\r\n3.切换文件夹：cd (filename)\r\n### 功能\r\n1.上传文件<br>\r\n2.mkdir ls cd基本命令<br>\r\n3.实现进度条<br>\r\n4.md5校验文件是否相同<br>\r\n5.断点续传<br>\r\n6.用户账号密码认证<br>\r\n7.每个用户有自己的家目录<br>\r\n### 补足的功能\r\n1.下载<br>\r\n不知道好想打游戏',1,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2019-11-29 20:15:09','2020-11-29 11:45:12',0),(129,'pygame游戏主框架','### 主框架\n```python\nfrom plane_sprites import *\n\n\nclass PlaneGame:\n    \"\"\"飞机大战主游戏\"\"\"\n\n    def __init__(self):\n        # 创建游戏窗口\n        self.screen = pygame.display.set_mode(SCREEN_SIZE.size)\n        # 游戏时钟\n        self.clock = pygame.time.Clock()\n        # 私有方法创建精灵\n        self._create_sprites()\n        # 设置定时器（定时产生事件）\n        pygame.time.set_timer(CREATE_ENEMY, 1000)\n        pygame.time.set_timer(HERO_FIRE_EVENT, 100)\n        pygame.time.set_timer(CREATE_MID_ENEMY, 5000)\n        pygame.time.set_timer(CREATE_LARGE_ENEMY, 5000)\n        # 设置实例延时器（防止照片播放速度太快）\n        self.delay = 100\n\n    # 创建精灵的私有方法\n    def _create_sprites(self):\n        # 创建背景精灵.\n        bg1 = BackGround()\n        bg2 = BackGround(True)\n        # 创建英雄精灵（由于后续操作需定义为属性）\n        self.hero = Hero()\n        # 创建敌机精灵组\n        self.enemy_group = pygame.sprite.Group()\n        # 创建中型敌机精灵组\n        self.mid_enemy_group = pygame.sprite.Group()\n        # 创建大型敌机精灵组\n        self.large_enemy_group = pygame.sprite.Group()\n        # 创建背景精灵组\n        self.bg_group = pygame.sprite.Group(bg1, bg2)\n        # 创建英雄精灵组\n        self.hero_group = pygame.sprite.Group(self.hero)\n        # 被击中的敌方飞机组\n        self.enemy_hit_group = pygame.sprite.Group()\n        self.temp_hit_group = pygame.sprite.Group()\n\n    def start_game(self):\n        \"\"\"游戏主循环\"\"\"\n        while True:\n            # 设置刷新率\n            self.clock.tick(FRAME_PER_SEC)\n            # 事件监听\n            self.__event_handler()\n            # 更新精灵\n            self.__update_sprites()\n            # 检测碰撞\n            self.__check_collide()\n            # 控制延时\n            self.delay += 1\n            # 更新屏幕\n            pygame.display.update()\n\n    # 事件监听\n    def __event_handler(self):\n        for event in pygame.event.get():\n            if event.type == pygame.QUIT:\n                PlaneGame.__game_over()\n            elif event.type == CREATE_ENEMY:\n                # 创建敌机精灵\n                enemy = Enemy()\n                # 将敌机精灵添加到精灵组\n                self.enemy_group.add(enemy)\n            # 添加中型敌机\n            elif event.type == CREATE_MID_ENEMY:\n                mid_enemy = MidEnemy()\n                self.mid_enemy_group.add(mid_enemy)\n            # 添加大型敌机\n            elif event.type == CREATE_LARGE_ENEMY:\n                large_enemy = LargeEnemy()\n                self.large_enemy_group.add(large_enemy)\n            elif event.type == HERO_FIRE_EVENT:\n                # 调用开火方法\n                self.hero.fire()\n        \"\"\"操作飞机\"\"\"\n        key_pressed = pygame.key.get_pressed()\n        if key_pressed[pygame.K_RIGHT]:\n            self.hero.speed = 3\n        elif key_pressed[pygame.K_LEFT]:\n            self.hero.speed = -3\n        elif key_pressed[pygame.K_UP]:\n            self.hero.image = pygame.image.load(\"./images/me1.png\")\n            self.hero.speedy = -3\n        elif key_pressed[pygame.K_DOWN]:\n            self.hero.speedy = 3\n        else:\n            self.hero.image = pygame.image.load(\"./images/me2.png\")\n            self.hero.speed = 0\n            self.hero.speedy = 0\n\n    # 检测碰撞\n    def __check_collide(self):\n        # 某个精灵组与某个精灵组之间的碰撞\n        \"\"\"子弹摧毁敌机\"\"\"\n        # 添加被撞敌机\n        # 1.加入被撞敌机组\n        self.enemy_hit_group.add(pygame.sprite.groupcollide(self.enemy_group, self.hero.bullet_group, False, True))\n        # 添加后期进行判断\n        self.temp_hit_group.add(pygame.sprite.groupcollide(self.mid_enemy_group, self.hero.bullet_group, False, True))\n        self.temp_hit_group.add(pygame.sprite.groupcollide(self.large_enemy_group, self.hero.bullet_group, False, True))\n        # 增加击中次数\n        for each in self.temp_hit_group:\n            each.hit_num += 1\n        self.temp_hit_group.empty()\n\n        for each in self.mid_enemy_group:\n            if each.hit_num == each.dead_hit_num:\n                self.enemy_hit_group.add(each)\n                self.mid_enemy_group.remove(each)\n\n        for each in self.large_enemy_group:\n            if 20 < each.hit_num <= each.hit_num:\n                each.switch = False\n            if each.hit_num == each.dead_hit_num:\n                self.enemy_hit_group.add(each)\n                self.large_enemy_group.remove(each)\n\n        \"\"\"敌机摧毁英雄\"\"\"\n        # 某个精灵与某个精灵组之间的碰撞\n        # spritecollide返回一个精灵组中被撞精灵的列表\n        en = pygame.sprite.spritecollide(self.hero, self.enemy_group, True, pygame.sprite.collide_mask)\n        # 英雄与中型敌机碰撞\n        en.extend(pygame.sprite.spritecollide(self.hero, self.mid_enemy_group, True, pygame.sprite.collide_mask))\n        if len(en) > 0:\n            self.hero.active = False\n            self.hero.kill()\n            # 遍历所有的被撞精灵，添加被撞击的敌机到被撞精灵组\n            for each in en:\n                self.enemy_hit_group.add(each)\n\n        \"\"\"播放英雄坠毁效果\"\"\"\n        if not self.hero.active:\n            # TODO 正好除的进3\n            if (self.delay % 3) == 0:\n                self.screen.blit(self.hero.destroy_images[self.hero.hero_hit_index], self.hero.rect)\n                # 因为后续直接退出游戏所以在此更新屏幕\n                pygame.display.update()\n                self.hero.hero_hit_index += 1\n                if self.hero.hero_hit_index == 4:\n                    PlaneGame.__game_over()\n\n        \"\"\"播放敌机坠毁效果\"\"\"\n        # 2.将被撞敌机从敌机精灵组中去除\n        for enemy_hit in self.enemy_hit_group:\n            self.enemy_group.remove(enemy_hit)\n        # 3.处理被撞敌机精灵组（显示效果）\n        for each in self.enemy_hit_group:\n            if (self.delay % 3) == 0:\n                self.screen.blit(each.destroy_images[each.enemy_hit_index], each.rect)\n                pygame.display.update()\n                each.enemy_hit_index += 1\n                if each.enemy_hit_index == each.max_enemy_hit_index:\n                    each.kill()\n\n    # 更新位置\n    def __update_sprites(self):\n        self.bg_group.update()\n        self.bg_group.draw(self.screen)\n\n        self.enemy_group.update()\n        self.enemy_group.draw(self.screen)\n\n        self.mid_enemy_group.update()\n        self.mid_enemy_group.draw(self.screen)\n\n        self.large_enemy_group.update()\n        self.large_enemy_group.draw(self.screen)\n\n        self.hero_group.update()\n        self.hero_group.draw(self.screen)\n\n        self.hero.bullet_group.update()\n        self.hero.bullet_group.draw(self.screen)\n\n    # 退出游戏\n    @staticmethod\n    def __game_over():\n        print(\"Game Over\")\n        pygame.quit()\n        exit(0)\n\n\npygame.init()\ngame = PlaneGame()\ngame.start_game()',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2019-11-12 16:19:34','2020-11-29 11:45:12',0),(130,'显示被击中后的图像','### 首先使用一个数组储存销毁后的图像\n```python\n        # 添加坠毁图像\n        self.destroy_images = []\n        self.destroy_images.extend([pygame.image.load(\"./images/enemy1_down1.png\").convert_alpha(),\n                                    pygame.image.load(\"./images/enemy1_down2.png\").convert_alpha(),\n                                    pygame.image.load(\"./images/enemy1_down3.png\").convert_alpha(),\n                                    pygame.image.load(\"./images/enemy1_down4.png\").convert_alpha()])\n        # 用于检索销毁图片\n        self.enemy_hit_index = 0\n        self.max_enemy_hit_index = 4\n```\n### 在主函数中显示每个图像\n```python\n        for each in self.enemy_hit_group:\n            if (self.delay % 3) == 0:\n                self.screen.blit(each.destroy_images[each.enemy_hit_index], each.rect)\n                pygame.display.update()\n                each.enemy_hit_index += 1\n                if each.enemy_hit_index == each.max_enemy_hit_index:\n                    each.kill()\n```\n### 检测碰撞函数\n```python\n    def __check_collide(self):\n        # 某个精灵组与某个精灵组之间的碰撞\n        \"\"\"子弹摧毁敌机\"\"\"\n        # 添加被撞敌机\n        # 1.加入被撞敌机组\n        self.enemy_hit_group.add(pygame.sprite.groupcollide(self.enemy_group, self.hero.bullet_group, False, True))\n        # 添加后期进行判断\n        self.temp_hit_group.add(pygame.sprite.groupcollide(self.mid_enemy_group, self.hero.bullet_group, False, True))\n        self.temp_hit_group.add(pygame.sprite.groupcollide(self.large_enemy_group, self.hero.bullet_group, False, True))\n        # 增加击中次数\n        for each in self.temp_hit_group:\n            each.hit_num += 1\n        self.temp_hit_group.empty()\n\n        for each in self.mid_enemy_group:\n            if each.hit_num == each.dead_hit_num:\n                self.enemy_hit_group.add(each)\n                self.mid_enemy_group.remove(each)\n\n        for each in self.large_enemy_group:\n            if 20 < each.hit_num <= each.hit_num:\n                each.switch = False\n            if each.hit_num == each.dead_hit_num:\n                self.enemy_hit_group.add(each)\n                self.large_enemy_group.remove(each)\n\n        \"\"\"敌机摧毁英雄\"\"\"\n        # 某个精灵与某个精灵组之间的碰撞\n        # spritecollide返回一个精灵组中被撞精灵的列表\n        en = pygame.sprite.spritecollide(self.hero, self.enemy_group, True, pygame.sprite.collide_mask)\n        # 英雄与中型敌机碰撞\n        en.extend(pygame.sprite.spritecollide(self.hero, self.mid_enemy_group, True, pygame.sprite.collide_mask))\n        if len(en) > 0:\n            self.hero.active = False\n            self.hero.kill()\n            # 遍历所有的被撞精灵，添加被撞击的敌机到被撞精灵组\n            for each in en:\n                self.enemy_hit_group.add(each)\n\n        \"\"\"播放英雄坠毁效果\"\"\"\n        if not self.hero.active:\n            # TODO 正好除的进3\n            if (self.delay % 3) == 0:\n                self.screen.blit(self.hero.destroy_images[self.hero.hero_hit_index], self.hero.rect)\n                # 因为后续直接退出游戏所以在此更新屏幕\n                pygame.display.update()\n                self.hero.hero_hit_index += 1\n                if self.hero.hero_hit_index == 4:\n                    PlaneGame.__game_over()\n\n        \"\"\"播放敌机坠毁效果\"\"\"\n        # 2.将被撞敌机从敌机精灵组中去除\n        for enemy_hit in self.enemy_hit_group:\n            self.enemy_group.remove(enemy_hit)\n        # 3.处理被撞敌机精灵组（显示效果）\n        for each in self.enemy_hit_group:\n            if (self.delay % 3) == 0:\n                self.screen.blit(each.destroy_images[each.enemy_hit_index], each.rect)\n                pygame.display.update()\n                each.enemy_hit_index += 1\n                if each.enemy_hit_index == each.max_enemy_hit_index:\n                    each.kill()\n```',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2019-11-12 16:31:18','2020-11-29 11:45:12',0),(131,'二叉树','[TOC]\n### 二叉树的声明\n```c\n/*声明定义链式二叉树*/\ntypedef struct\n{\n	char a;\n}DataType;\ntypedef struct binarytreenode\n{\n	DataType data;\n	struct binarytreenode* lchild;	/*左子树*/\n	struct binarytreenode* rchild;	/*右子树*/\n}BiTree;\n```\n### 二叉树的建立\n#### 递归\n使用递归的方法建立，要在用\'#\'将每个节点的子树表示（只使用前序遍历无法确定唯一的二叉树）<br>\n函数最后的return T会有两种情况：<br>\n1.输入的为\'#\'：直接返回NULL（传入的参数就是NULL，所以就是将NULL赋值）<br>\n2.输入的为数据：创建新的存储空间\n```c\n/*初始化二叉树*/\nBiTree* init_Binarytreenode(BiTree* T)\n{\n	DataType x;\n	printf(\"请输入字符：\\n\");\n	scanf_s(\"%c\", &x.a, 1); /*scanf有返回值*/\n	//rewind(stdin);\n	if (x.a != \'#\')\n	{\n		T = (BiTree*)malloc(sizeof(BiTree));\n		if (T == NULL)\n		{\n			printf(\"内存分配失败！\\n\");\n			exit(1);\n		}\n		T->data = x;\n		T->lchild = NULL;\n		T->rchild = NULL;\n		T->lchild = init_Binarytreenode(T->lchild);\n		T->rchild = init_Binarytreenode(T->rchild);\n	}\n	return T;\n}\n```\n#### 非递归\n使用非递归前序遍历的方法创建二叉树要使用双亲位置（完全二叉树，根结点从1开始）为子结点除2，所以创建一个指针数组，将新储存的结点按顺序存入数组中，使用新结点下标模除2来知道为左结点或右结点，更改双亲的指向（p[0]里面啥都没有）\n```c\n/*初始化二叉树（非递归）*/\nBiTree* init_Binarytreenode_Without_Recursion(BiTree* T)\n{\n	DataType x;\n	int i, j;\n	BiTree* p[50] = {NULL};	/*存放节点的指针数组*/\n	BiTree* head = NULL;\n	while (1)\n	{\n		printf(\"请输入节点信息和位置（位置用-1结束，中间用空格隔开）：\\n\");\n		scanf_s(\"%c %d\", &x.a, 1, &i);\n		rewind(stdin);\n		if (i == -1)\n		{\n			break;\n		}\n		T = (BiTree*)malloc(sizeof(BiTree));\n		if (T == NULL)\n		{\n			printf(\"申请内存空间失败！\\n\");\n			exit(1);\n		}\n		T->data = x;\n		T->lchild = NULL;\n		T->rchild = NULL;\n		/*根节点的输入*/\n		if (i == 1)\n		{\n		    /*头指针*/\n			head = T;\n		}\n		else\n		{\n			j = i / 2;	/*双亲的位置*/\n			/*判断左右子树*/\n			if (i % 2 == 0)\n			{\n				/*左子树*/\n				/*更改双亲的指向*/\n				p[j]->lchild = T;\n			}\n			else\n			{\n				/*右子树*/\n				p[j]->rchild = T;\n			}\n		}\n		p[i] = T;	/*将新添加的节点添加到列表中*/\n	}\n	return head;    /*将头指针返回*/\n}\n```\n\n### 遍历二叉树\n#### 递归\n```c\n/*前序遍历二叉树*/\nint pre_Order_Traverse(BiTree* T)\n{\n	if (T == NULL)\n	{\n		return 0;\n	}\n	printf(\"%c\", T->data.a);\n	pre_Other_Traverse(T->lchild);\n	pre_Other_Traverse(T->rchild);\n	return OK;\n}\n```\n#### 非递归（迭代）\n非递归要使用栈的思想，这里把栈想象成一个记事本将有右子树的右结点指针使用栈记录下来，在当某结点的左节点为空时进行弹栈操作\n```c\n/*前序遍历二叉树（非递归）*/\nint pre_Order_Traverse_Without_Recursion(BiTree* T)\n{\n	BiTree* p = T;	/*用于寻找当前节点位置*/\n	/*假栈的声明与定义*/\n	BiTree* fakestack[50];\n	int top = -1;\n	while (p != NULL || top != -1)\n	{\n		if (p != NULL)\n		{\n			printf(\"%c\", p->data.a);\n			/*右子树入栈*/\n			if (p->rchild != NULL)\n			{\n				fakestack[++top] = p->rchild;\n			}\n			p = p->lchild;\n		}\n		else\n		{\n			/*出栈*/\n			p = fakestack[top--];\n		}\n	}\n	return OK;\n}\n```\nC++写法：\n```cpp\n\nclass Solution {\npublic:\n    vector<int> preorderTraversal(TreeNode *root) {\n        vector<int> result;\n        if (root == nullptr) {\n            return result;\n        }\n        stack<TreeNode *> s;\n        s.push(root);\n        while (!s.empty()) {\n            TreeNode *node = s.top();\n            s.pop();\n            result.push_back(node->val);\n            if (node->right != nullptr) {\n                s.push(node->right);\n            }\n            if (node->left != nullptr) {\n                s.push(node->left);\n            }\n        }\n        return result;\n    }\n};\n```\n### 寻找叶子节点个数\n主要思想还是用前序遍历的想法，当左右子树都为空的时候计数器（全局变量）自增\n```c\nint find_Leafnode_Numner(BiTree* T)\n{\n	if (T != NULL)\n	{\n		if (T->lchild == NULL && T->rchild == NULL)\n		{\n		    /*计数器自增*/\n			num++;\n		}\n		find_Leafnode_Numner(T->lchild);\n		find_Leafnode_Numner(T->rchild);\n	}\n	return num;\n}\n```\n### 二叉树的深度\n用到递归的思想，使用level来记录每个数据的深度，每往下一层level就加一\n```c\n/*寻找二叉树深度*/\nvoid find_Deep(BiTree* T,int level)\n{\n	if (T != NULL)\n	{\n		//printf(\"%c %d\\n\", T->data.a, level);\n		if (max < level)\n		{\n			/*使用全局变量max来记录最大个数*/\n			max = level;\n		}\n		find_Deep(T->lchild, level + 1);\n		find_Deep(T->rchild, level + 1);\n	}\n}\n```\n### 全部代码\n```c\n#pragma warning(disable:4996)\n#include<stdio.h>\n#include<stdlib.h>\n#include<malloc.h>\n#define OK 0\n#define ERROR -1\n#define MAXSIZE 50\nint num = 0;\nint max = 0;\n/*声明定义链式二叉树*/\ntypedef struct\n{\n	char a;\n}DataType;\ntypedef struct binarytreenode\n{\n	DataType data;\n	struct binarytreenode* lchild;	/*左子树*/\n	struct binarytreenode* rchild;	/*右子树*/\n}BiTree;\n\n/*初始化二叉树（前序遍历）*/\nBiTree* init_Binarytreenode(BiTree* T)\n{\n	DataType x;\n	printf(\"请输入字符：\\n\");\n	scanf_s(\"%c\", &x.a, 1);	/*scanf有返回值*/\n	//rewind(stdin);\n	if (x.a != \'#\')\n	{\n		T = (BiTree*)malloc(sizeof(BiTree));\n		if (T == NULL)\n		{\n			printf(\"内存分配失败！\\n\");\n			exit(1);\n		}\n		T->data = x;\n		T->lchild = NULL;\n		T->rchild = NULL;\n		T->lchild = init_Binarytreenode(T->lchild);\n		T->rchild = init_Binarytreenode(T->rchild);\n	}\n	return T;\n}\n\n/*初始化二叉树（非递归）*/\nBiTree* init_Binarytreenode_Without_Recursion(BiTree* T)\n{\n	DataType x;\n	int i, j;\n	BiTree* p[50] = { NULL };	/*存放节点的指针数组*/\n	BiTree* head = NULL;\n	while (1)\n	{\n		printf(\"请输入节点信息和位置（位置用-1结束，中间用空格隔开）：\\n\");\n		scanf_s(\"%c %d\", &x.a, 1, &i);\n		rewind(stdin);\n		if (i == -1)\n		{\n			break;\n		}\n		T = (BiTree*)malloc(sizeof(BiTree));\n		if (T == NULL)\n		{\n			printf(\"申请内存空间失败！\\n\");\n			exit(1);\n		}\n		T->data = x;\n		T->lchild = NULL;\n		T->rchild = NULL;\n		/*根节点的输入*/\n		if (i == 1)\n		{\n			/*头指针*/\n			head = T;\n		}\n		else\n		{\n			j = i / 2;	/*双亲的位置*/\n			/*判断左右子树*/\n			if (i % 2 == 0)\n			{\n				/*左子树*/\n				/*更改双亲的指向*/\n				p[j]->lchild = T;\n			}\n			else\n			{\n				/*右子树*/\n				p[j]->rchild = T;\n			}\n		}\n		p[i] = T;	/*将新添加的节点添加到列表中*/\n	}\n	return head;\n}\n\n/*前序遍历二叉树*/\nint pre_Other_Traverse(BiTree* T)\n{\n	if (T == NULL)\n	{\n		return 0;\n	}\n	printf(\"%c\", T->data.a);\n	pre_Other_Traverse(T->lchild);\n	pre_Other_Traverse(T->rchild);\n	return OK;\n}\n\n/*前序遍历二叉树（非递归）*/\nint pre_Other_Traverse_Without_Recursion(BiTree* T)\n{\n	BiTree* p = T;	/*用于寻找当前节点位置*/\n	/*假栈的声明与定义*/\n	BiTree* fakestack[50];\n	int top = -1;\n	while (p != NULL || top != -1)\n	{\n		if (p != NULL)\n		{\n			printf(\"%c\", p->data.a);\n			/*右子树入栈*/\n			if (p->rchild != NULL)\n			{\n				fakestack[++top] = p->rchild;\n			}\n			p = p->lchild;\n		}\n		else\n		{\n			/*出栈*/\n			p = fakestack[top--];\n		}\n	}\n	return OK;\n}\n\n/*书上炫技的写法*/\nvoid CreateBiTree(BiTree** T)\n{\n	char ch;\n	scanf_s(\"%c\", &ch, 1);\n	if (ch == \'#\')\n		*T = NULL;\n	else\n	{\n		*T = (BiTree*)malloc(sizeof(BiTree));\n		if (!*T)\n			exit(-1);\n		(*T)->data.a = ch;\n		CreateBiTree(&(*T)->lchild);\n		CreateBiTree(&(*T)->rchild);\n	}\n}\n\n/*叶子节点个数*/\nint find_Leafnode_Numner(BiTree* T)\n{\n	if (T != NULL)\n	{\n		if (T->lchild == NULL && T->rchild == NULL)\n		{\n			num++;\n		}\n		find_Leafnode_Numner(T->lchild);\n		find_Leafnode_Numner(T->rchild);\n	}\n	return num;\n}\n\n/*寻找二叉树深度*/\nvoid find_Deep(BiTree* T,int level)\n{\n	if (T != NULL)\n	{\n		//printf(\"%c %d\\n\", T->data.a, level);\n		if (max < level)\n		{\n			/*使用max来记录最大个数*/\n			max = level;\n		}\n		find_Deep(T->lchild, level + 1);\n		find_Deep(T->rchild, level + 1);\n	}\n}\n\nint main()\n{\n	BiTree* a = NULL;\n	a = init_Binarytreenode(a);\n	find_Deep(a, 1);\n	printf(\"%d\", max);\n	return 0;\n}/*ABDG##H###CE#I##F##*/\n```',1,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2020-10-27 09:28:51','2020-11-29 11:45:13',0),(132,'哈夫曼树','### 声明及定义\n```c\ntypedef struct node\n{\n	int w, pa, lc, rc;\n	/*权重，双亲，左孩子，右孩子*/\n	DataType data;\n}hafuman;\n```\n使用数组来表示双亲或左右子树<br>\n初始状态\n| 数组下标 |权值 | 双亲 | 左孩子 | 右孩子 |\n|---|---|---|---|----|\n0|7|-1|-1|-1\n1|5|-1|-1|-1\n2|2|-1|-1|-1\n3|4|-1|-1|-1\n4|3|-1|-1|-1\n### 转化为哈夫曼树\n转化步骤：<br>\n1.寻找两个最小子树<br>\n2.相加后添加权值<br>\n3.修改原左右子树的双亲结点到当前结点<br>\n结束状态\n| 数组下标 |权值 | 双亲 | 左孩子 | 右孩子 |\n|---|---|---|---|----|\n0|7|7|-1|-1\n1|5|6|-1|-1\n2|2|5|-1|-1\n3|4|6|-1|-1\n4|3|5|-1|-1\n5|5|7|2|4\n6|9|8|3|1\n7|12|8|5|0\n8|21|-1|6|7\n\n```c\nvoid changto_Ha(hafuman H[])\n{\n	int k1, k2, m1, m2, i, j;\n	for (j = 5; j < 9; j++)\n	{\n		m1 = m2 = MAXINT;	/*寻找和记录权值*/\n		k1 = k2 = 0;	/*记录最小权值的下标*/\n		for (i = 0; i < j; i++)\n			if (H[i].w < m1 && H[i].pa == -1)	/*寻找两个最小的权值*/\n			{\n				m2 = m1; k2 = k1;\n				m1 = H[i].w; k1 = i;\n			}\n			else if (H[i].w < m2 && H[i].pa == -1)	/*权值比最小的大但小于第二个*/\n			{\n				m2 = H[i].w; k2 = i;\n			}\n		H[j].w = m1 + m2;\n		H[j].lc = k1; H[j].rc = k2; /*添加左右子树下标*/\n		H[k1].pa = H[k2].pa = j;    /*修改子树的双亲下标*/\n\n	}\n	for (i = 0; i < 9; i++)\n	{\n		printf(\"%d %d %d %d\\n\", H[i].w, H[i].pa, H[i].lc, H[i].rc);\n	}\n}\n```\n### 全部代码\n```c\n#pragma warning(disable:4996)\n#include<stdio.h>\n#define MAXINT 32567\ntypedef struct node\n{\n	int w, pa, lc, rc;\n	/*权重，双亲，左孩子，右孩子*/\n}hafuman;\nvoid changto_Ha(hafuman H[])\n{\n	int k1, k2, m1, m2, i, j;\n	for (j = 5; j < 9; j++)\n	{\n		m1 = m2 = MAXINT;	/*寻找和记录权值*/\n		k1 = k2 = 0;	/*记录最小权值的下标*/\n		for (i = 0; i < j; i++)\n			if (H[i].w < m1 && H[i].pa == -1)	/*寻找两个最小的权值*/\n			{\n				m2 = m1; k2 = k1;\n				m1 = H[i].w; k1 = i;\n			}\n			else if (H[i].w < m2 && H[i].pa == -1)	/*权值比最小的大但小于第二个*/\n			{\n				m2 = H[i].w; k2 = i;\n			}\n		H[j].w = m1 + m2;\n		H[j].lc = k1; H[j].rc = k2; H[k1].pa = H[k2].pa = j;\n\n	}\n	for (i = 0; i < 9; i++)\n	{\n		printf(\"%d %d %d %d\\n\", H[i].w, H[i].pa, H[i].lc, H[i].rc);\n	}\n}\nint main()\n{\n	hafuman H[9];\n	int i;\n	/*度为0的结点个数比度为1的结点个数多1*/\n	for (i = 0; i < 9; i++)\n	{\n		H[i].pa = H[i].lc = H[i].rc = -1;\n	}\n	for (i = 0; i < 5; i++)\n		scanf_s(\"%d\", &H[i].w);\n	changto_Ha(H);\n	return 0;\n}/*7 5 2 4 3*/\n```',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2019-11-12 09:44:49','2020-11-29 11:45:13',0),(133,'图','[TOC]\n### 声明及定义\n使用邻接矩阵输入图<br>\n顶点之间没有线段使用INFINITE代替\n```c\n#include<stdio.h>\n#include<stdlib.h>\n#include<limits.h>	/*最大限制头文件*/\n#include<stdbool.h>	/*布尔类型*/\n#define MAXVERTEX 100\n#define OK 0\n#define ERROR -1\n#define INFINITE 10000	/*无限大*/\n/*图（邻接矩阵）结构体*/\ntypedef struct {\n	char a;\n	int numIndegree, numOutdegree;\n}DataType;\ntypedef struct {\n	DataType data[MAXVERTEX];	/*顶点数组*/\n	int edge[MAXVERTEX][MAXVERTEX];	/*紧接矩阵*/\n	int numVertexes, numEdges;	/*顶点数量，边的数量*/\n}MGraph;\nbool visited[MAXVERTEX];	/*深度遍历与广度遍历标记*/\n```\n### 创建邻接矩阵\n1.初始化<br>\n2.输入顶点<br>\n3.输入边（如果是无向图为对称矩阵）\n```c\n/*创建邻接矩阵*/\nvoid create_MGraph(MGraph* G)\n{\n	int i, j, k, w;\n	printf(\"请输入顶点数量和边的数量：\\n\");\n	scanf_s(\"%d %d\", &(G->numVertexes), &(G->numEdges));\n	rewind(stdin);\n	for ( i = 0; i < G->numVertexes; i++)	/*输入数据*/\n	{\n		printf(\"输入顶点数据：\\n\");\n		scanf_s(\"%c\", &(G->data[i].a), 20);\n		G->data[i].numIndegree = G->data[i].numOutdegree = 0;\n	}\n	rewind(stdin);\n	/*初始化邻接矩阵*/\n	for (i = 0; i < G->numVertexes; i++)\n	{\n		for (j = 0; j < G->numVertexes; j++)\n		{\n			G->edge[i][j] = INFINITE;\n		}\n	}\n	/*输入边的数据*/\n	for (k = 0; k < G->numEdges; k++)\n	{\n		rewind(stdin);\n		printf(\"输入vi,vj的下标i，下标j，权值w\\n\");\n		scanf_s(\"%d %d %d\", &i, &j, &w);\n		G->edge[i][j] = w;\n		G->edge[j][i] = G->edge[i][j];	//矩阵对称\n	}\n	/*有向图*/\n	/*for (k = 0; k < G->numEdges; k++)\n	{\n		printf(\"输入vi,vj的下标i，下标j，权值w\\n\");\n		scanf_s(\"%d %d %d\", &i, &j, &w);\n		G->edge[i][j] = w;\n	}*/\n}\n```\n\n### 图的遍历\n#### 深度优先遍历\n相当于树的前序遍历\n\n深度优先遍历相当于在迷宫中确定一个方向，在走过的顶点中坐下标记继续遍历，当没有时在遍历的顶点后一层层返回\n\n1.初始化顶点标记数组<br>\n2.遍历数组<br>\n3.在顶点所处的行里查找是否有其他未遍历的结点与其连接<br>\n4.有连接的结点后（没有被遍历过）使用递归算法继续遍历新节点\n```c\n/*邻接矩阵深度优先递归遍历算法*/\nvoid deep_First_Search(MGraph* G, int i)\n{\n	int j;\n	visited[i] = true;\n	printf(\"%c \", G->data[i].a);\n	for (j = 0; j < G->numVertexes; j++)\n	{\n		if (G->edge[i][j] != INFINITE && !visited[j])\n		{\n			deep_First_Search(G, j);\n		}\n	}\n}\n\n/*邻接矩阵深度优先遍历*/\nvoid deep_First_Serch_Traverse(MGraph* G)\n{\n	int i;\n	for (i = 0; i < G->numVertexes; i++)\n	{\n		visited[i] = false;\n	}\n	for (i = 0; i < G->numVertexes; i++)\n	{\n		if (!visited[i])\n		{\n			/*调用递归遍历函数*/\n			deep_First_Search(G, i);\n		}\n	}\n	printf(\"\\n\");\n}\n```\n#### 广度优先遍历\n相当于树的层序遍历\n\n进行广度优先遍历需要用到队列函数\n\n1.初始化顶点标记数组<br>\n2.遍历数组<br>\n3.顶点没有被遍历过，输出顶点并将其入队<br>\n4.当队列中有内容时出队，搜寻出队元素有关联的结点将这些有关联的结点输出并入队<br>\n5.直到所有结点都被遍历<br>\n\n```c\n/*邻接矩阵广度优先遍历*/\nvoid breath_First_Serch_Traverse(MGraph* G,LinkQueue* Q)\n{\n	int i, j;\n	int tmpi;\n	for (i = 0; i < G->numVertexes; i++)	/*初始化判断数组*/\n	{\n		visited[i] = false;\n	}\n	init_LinkQueue(Q);\n	for (i = 0; i < G->numVertexes; i++)\n	{\n		if (!visited[i])\n		{\n			visited[i] = true;\n			printf(\"%c \", G->data[i].a);\n			en_Queue(Q, i);\n			while (is_Queue_Empty(Q))\n			{\n				tmpi = de_Queue(Q);\n				for (j = 0; j < G->numVertexes; j++)\n				{\n					if (G->edge[tmpi][j] != INFINITE && !visited[j])\n					{\n						visited[j] = true;\n						printf(\"%c \", G->data[j].a);\n						en_Queue(Q, j);\n					}\n				}\n			}\n		}\n	}\n	printf(\"\\n\");\n}\n```\n### 图的最短路径\n在图中搜索除了起始结点以外的通向其他结点的最短路径\n\n为了储存通向其他结点的最小路径需要使用一个Path数组<br>\nU为在最短路径中的结点<br>\nU-V为未确定的顶点<br>\n#### Path数组结构体\n```c\n/*最小路径（距离）结构体*/\ntypedef struct {\n	int length;	/*权值*/\n	int prevertex;	/*前结点下标*/\n}Path;\nPath dist[MAXVERTEX];\n```\n#### 初始化Path数组\n由于让第一个节点作为起始节点，所以dist[0].length = 0\ndist[0].prevertex = 0<br>\n使用邻接矩阵的对角线元素确定顶点在U(1)还是U-V(0)中（初始化对角线元素为0）<br>\n```c\n/*初始化路径数组*/\nvoid init_Path(MGraph* G, Path dist[])\n{\n	int i;\n	dist[0].prevertex = 0;\n	dist[0].length = 0;\n	/*初始化对角线*/\n	for (i = 0; i < G->numVertexes; i++)\n	{\n		G->edge[i][i] = 0;\n	}\n	/*使用对角线元素判断是否加入U中*/\n	G->edge[0][0] = 1;	/*加入集合U中*/\n	for (i = 1; i < G->numVertexes; i++)	/*初始化与起始节点相关的结点*/\n	{\n		dist[i].length = G->edge[0][i];\n		if (dist[i].length != INFINITE)\n		{\n			/*与起始结点直接相连*/\n			dist[i].prevertex = 0;\n		}\n		else\n		{\n			/*与起始结点非直接相连*/\n			dist[i].prevertex = -1;\n		}\n	}\n}\n```\n#### 寻找最小路径\n首先初始化储存最小路径数组<br>\n\n1.在V-U（未确定）中寻找权值最小的结点<br>\n2.权值修正：<br>\n&emsp;&emsp;使用最小路径寻找其他结点的权值，当初始结点到现处理结点权值+现处理结点到下个结点权值 < 最小路径数组对应结点权值，更改结点权值\n```c\nif (G->edge[j][j] == 0 && dist[j].length > dist[vertex].length + G->edge[vertex][j])\n{\n	dist[j].prevertex = vertex;\n	dist[j].length = dist[vertex].length + G->edge[vertex][j];\n}\n```\n3.遍历所有结点，不断在V-U中寻找权值最小的结点，添加到U（已确定）中\n\n```c\n/*Dijkstra寻找最小路径*/\nvoid dijkstra_Find_Shortest_Path(MGraph* G,Path dist[])\n{\n	int i, j;\n	int vertex;\n	int minweight;\n	init_Path(G, dist);\n	for (i = 1; i < G->numVertexes; i++)\n	{\n		vertex = 0;\n		minweight = INFINITE;\n		/*寻找U-V中的最段路径*/\n		for (j = 1; j < G->numVertexes; j++)\n		{\n			if (G->edge[j][j] == 0 && dist[j].length < minweight)\n			{\n				vertex = j;\n				minweight = dist[j].length;\n			}\n		}\n		/*在U-V中与初始起点不连通*/\n		if (vertex == 0)\n			break;\n		/*添加到U中*/\n		G->edge[vertex][vertex] = 1;\n		/*修正最短路径信息*/\n		for (j = 1; j < G->numVertexes; j++)	/*使用现结点检测后继结点*/\n		{\n			/*用现在的最小路径得到未来的最小路径*/\n			if (G->edge[j][j] == 0 && dist[j].length > dist[vertex].length + G->edge[vertex][j])\n			{\n				dist[j].prevertex = vertex;\n				dist[j].length = dist[vertex].length + G->edge[vertex][j];\n			}\n		}\n	}\n}\n```\n### 全部代码\n```c\n#pragma warning(disable:4996)\n#include<stdio.h>\n#include<stdlib.h>\n#include<stdbool.h>	/*布尔类型*/\n#define MAXVERTEX 100\n#define OK 0\n#define ERROR -1\n#define INFINITE 10000\n/*图（邻接矩阵）结构体*/\ntypedef struct {\n	char a;\n	int numIndegree, numOutdegree;\n}DataType;\ntypedef struct {\n	DataType data[MAXVERTEX];	/*顶点数组*/\n	int edge[MAXVERTEX][MAXVERTEX];	/*紧接矩阵*/\n	int numVertexes, numEdges;	/*顶点数量，边的数量*/\n}MGraph;\nbool visited[MAXVERTEX];	/*深度遍历与广度遍历标记*/\n\n/*队列（链式）所需结构体*/\ntypedef struct	/*数据*/\n{\n	char a;\n	int location;\n}QDataType;\nstruct Qnode	/*链式结构体*/\n{\n	QDataType data;\n	struct Qnode* next;\n};\ntypedef struct	/*链式队列结构体*/\n{\n	struct Qnode* front;\n	struct Qnode* real;\n}LinkQueue;\n\n/*最小路径（距离）结构体*/\ntypedef struct {\n	int length;	/*权值*/\n	int prevertex;	/*前结点下标*/\n}Path;\nPath dist[MAXVERTEX];\n\nint init_LinkQueue(LinkQueue* Q);\nint en_Queue(LinkQueue* Q, int location);\nint de_Queue(LinkQueue* Q);\nint is_Queue_Empty(LinkQueue* Q);\n\n/*创建邻接矩阵*/\nvoid create_MGraph(MGraph* G)\n{\n	int i, j, k, w;\n	printf(\"请输入顶点数量和边的数量：\\n\");\n	scanf_s(\"%d %d\", &(G->numVertexes), &(G->numEdges));\n	rewind(stdin);\n	for ( i = 0; i < G->numVertexes; i++)	/*输入数据*/\n	{\n		printf(\"输入顶点数据：\\n\");\n		scanf_s(\"%c\", &(G->data[i].a), 20);\n		G->data[i].numIndegree = G->data[i].numOutdegree = 0;\n	}\n	rewind(stdin);\n	/*初始化邻接矩阵*/\n	for (i = 0; i < G->numVertexes; i++)\n	{\n		for (j = 0; j < G->numVertexes; j++)\n		{\n			G->edge[i][j] = INFINITE;\n		}\n	}\n	/*输入边的数据*/\n	for (k = 0; k < G->numEdges; k++)\n	{\n		rewind(stdin);\n		printf(\"输入vi,vj的下标i，下标j，权值w\\n\");\n		scanf_s(\"%d %d %d\", &i, &j, &w);\n		G->edge[i][j] = w;\n		G->edge[j][i] = G->edge[i][j];	//矩阵对称\n	}\n	/*有向图*/\n	/*for (k = 0; k < G->numEdges; k++)\n	{\n		printf(\"输入vi,vj的下标i，下标j，权值w\\n\");\n		scanf_s(\"%d %d %d\", &i, &j, &w);\n		G->edge[i][j] = w;\n	}*/\n}\n\n/*输出邻接矩阵*/\nvoid print_Matrix(MGraph* G)\n{\n	int i, j;\n	for (i = 0; i < G->numVertexes; i++)\n	{\n		for (j = 0; j < G->numVertexes; j++)\n		{\n			printf(\"%d\\t\\t\\t\", G->edge[i][j]);\n		}\n		printf(\"\\n\");\n	}\n}\n\n/*邻接矩阵深度优先递归遍历算法*/\nvoid deep_First_Search(MGraph* G, int i)\n{\n	int j;\n	visited[i] = true;\n	printf(\"%c \", G->data[i].a);\n	for (j = 0; j < G->numVertexes; j++)\n	{\n		if (G->edge[i][j] != INFINITE && !visited[j])\n		{\n			deep_First_Search(G, j);\n		}\n	}\n}\n\n/*邻接矩阵深度优先遍历*/\nvoid deep_First_Serch_Traverse(MGraph* G)\n{\n	int i;\n	for (i = 0; i < G->numVertexes; i++)\n	{\n		visited[i] = false;\n	}\n	for (i = 0; i < G->numVertexes; i++)\n	{\n		if (!visited[i])\n		{\n			/*调用递归遍历函数*/\n			deep_First_Search(G, i);\n		}\n	}\n	printf(\"\\n\");\n}\n\n/*邻接矩阵广度优先遍历*/\nvoid breath_First_Serch_Traverse(MGraph* G,LinkQueue* Q)\n{\n	int i, j;\n	int tmpi;\n	for (i = 0; i < G->numVertexes; i++)	/*初始化判断数组*/\n	{\n		visited[i] = false;\n	}\n	init_LinkQueue(Q);\n	for (i = 0; i < G->numVertexes; i++)\n	{\n		if (!visited[i])\n		{\n			visited[i] = true;\n			printf(\"%c \", G->data[i].a);\n			en_Queue(Q, i);\n			while (is_Queue_Empty(Q))\n			{\n				tmpi = de_Queue(Q);\n				for (j = 0; j < G->numVertexes; j++)\n				{\n					if (G->edge[tmpi][j] != INFINITE && !visited[j])\n					{\n						visited[j] = true;\n						printf(\"%c \", G->data[j].a);\n						en_Queue(Q, j);\n					}\n				}\n			}\n		}\n	}\n	printf(\"\\n\");\n}\n\n/*初始化路径数组*/\nvoid init_Path(MGraph* G, Path dist[])\n{\n	int i;\n	dist[0].prevertex = 0;\n	dist[0].length = 0;\n	/*初始化对角线*/\n	for (i = 0; i < G->numVertexes; i++)\n	{\n		G->edge[i][i] = 0;\n	}\n	/*使用对角线元素判断是否加入U中*/\n	G->edge[0][0] = 1;	/*加入集合U中*/\n	for (i = 1; i < G->numVertexes; i++)	/*初始化与起始节点相关的结点*/\n	{\n		dist[i].length = G->edge[0][i];\n		if (dist[i].length != INFINITE)\n		{\n			/*与起始结点直接相连*/\n			dist[i].prevertex = 0;\n		}\n		else\n		{\n			/*与起始结点非直接相连*/\n			dist[i].prevertex = -1;\n		}\n	}\n}\n\n/*Dijkstra寻找最小路径*/\nvoid dijkstra_Find_Shortest_Path(MGraph* G,Path dist[])\n{\n	int i, j;\n	int vertex;\n	int minweight;\n	init_Path(G, dist);\n	for (i = 1; i < G->numVertexes; i++)\n	{\n		vertex = 0;\n		minweight = INFINITE;\n		/*寻找U-V中的最段路径*/\n		for (j = 1; j < G->numVertexes; j++)\n		{\n			if (G->edge[j][j] == 0 && dist[j].length < minweight)\n			{\n				vertex = j;\n				minweight = dist[j].length;\n			}\n		}\n		/*在U-V中与初始起点不连通*/\n		if (vertex == 0)\n			break;\n		/*添加到U中*/\n		G->edge[vertex][vertex] = 1;\n		/*修正最短路径信息*/\n		for (j = 1; j < G->numVertexes; j++)	/*使用现结点检测后继结点*/\n		{\n			/*用现在的最小路径得到未来的最小路径*/\n			if (G->edge[j][j] == 0 && dist[j].length > dist[vertex].length + G->edge[vertex][j])\n			{\n				dist[j].prevertex = vertex;\n				dist[j].length = dist[vertex].length + G->edge[vertex][j];\n			}\n		}\n	}\n}\n\n/*队列函数*/\n/*初始化*/\nint init_LinkQueue(LinkQueue* Q)\n{\n	struct Qnode* headnode = (struct Qnode*)malloc(sizeof(struct Qnode));\n	if (Q == NULL  || headnode == NULL)\n	{\n		printf(\"内存分配失败！\\n\");\n		exit(1);\n	}\n	headnode->next = NULL;\n	Q->front = headnode;\n	Q->real = headnode;\n	return OK;\n}\n\n/*入队*/\nint en_Queue(LinkQueue* Q,int location)\n{\n	struct Qnode* newnode = (struct Qnode*)malloc(sizeof(struct Qnode));\n	if (newnode == NULL)\n	{\n		printf(\"内存分配失败！\\n\");\n		exit(1);\n	}\n	newnode->data.location = location;\n	newnode->next = NULL;\n	Q->real->next = newnode;\n	Q->real = newnode;\n	return OK;\n}\n\n/*出队*/\nint de_Queue(LinkQueue* Q)\n{\n	struct Qnode* p;\n	int i;\n	if (Q->front == Q->real)\n	{\n		printf(\"队列为空！\\n\");\n		return ERROR;\n	}\n	p = Q->front->next;\n	i = p->data.location;\n	Q->front->next = p->next;\n	/*当出最后一个元素出队时*/\n	if (Q->real == p)\n	{\n		Q->front = Q->real;\n	}\n	return i;\n}\n\n/*判断队列*/\nint is_Queue_Empty(LinkQueue* Q)\n{\n	if (Q->front == Q->real)\n	{\n		return 0;\n	}\n	else\n	{\n		return 1;\n	}\n}\n\nint main()\n{\n	int i;\n	MGraph* a = (void*)malloc(sizeof(MGraph));\n	if (!a)exit(1);\n	create_MGraph(a);\n	print_Matrix(a);\n	LinkQueue* Q = (void*)malloc(sizeof(LinkQueue));\n	deep_First_Serch_Traverse(a);\n	breath_First_Serch_Traverse(a, Q);\n	dijkstra_Find_Shortest_Path(a, dist);\n	for (i = 0; i < a->numVertexes; i++)\n	{\n		printf(\"%d %d\\n\", dist[i].prevertex, dist[i].length);\n	}\n	return 0;\n}\n```',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2019-12-23 21:20:46','2020-11-29 11:45:13',0),(134,'字符串','### 字符串的声明\n```c\ntypedef struct string\n{\n	char world[MAXSIZE];	/*从0开始*/\n	int length;	/*记录长度*/\n}String;\n```\n### 朴素匹配模式\n此方法用于查找对应子串开头的位置，但是会出现重复的判断情况，所以有KMP的匹配模式，当有一部分相同时可以减少判断次数\n```c\n/*寻找子串位置（寻找一次）*/\nint find_Subletter_Index(String S, String T)\n{\n	int i, j, flag = 0;\n	int temp;\n	for (i = 0; i <= S.length - T.length; i++)	/*S*/\n	{\n		temp = i;	/*用于内部循环判断*/\n		for (j = 0; j <= T.length - 1; j++, temp++)	/*T*/\n		{\n		    /*若有不相等直接标记不相同并退出*/\n			if (S.world[temp] != T.world[j])\n			{\n				flag = 0;\n				break;\n			}\n			flag = 1;\n		}\n		if (flag)\n		{\n			/*\n			result[x++] = i + 1;\n			*/\n			return i + 1;	/*返回下标（非数组）*/\n		}\n	}\n	return 0;\n}\n```\n### 全部代码\n```c\n#pragma warning(disable:4996)\n#include<stdio.h>\n#define MAXSIZE 100\ntypedef struct string\n{\n	char world[MAXSIZE];	/*从0开始*/\n	int length;	/*记录长度*/\n}String;\n\n/*寻找子串位置（寻找一次）*/\nint find_Subletter_Index(String S, String T)\n{\n	int i, j, flag = 0;\n	int temp;\n	for (i = 0; i <= S.length - T.length; i++)	/*S*/\n	{\n		temp = i;	/*用于内部循环判断*/\n		for (j = 0; j <= T.length - 1; j++, temp++)	/*T*/\n		{\n			if (S.world[temp] != T.world[j])\n			{\n				flag = 0;\n				break;\n			}\n			flag = 1;\n		}\n		if (flag)\n		{\n			/*\n			result[x++] = i + 1;\n			*/\n			return i + 1;	/*返回下标（非数组）*/\n		}\n	}\n	return 0;\n}\n\n/*删除相同的子串*/\nint delete_Subletter(String* a, String* b)\n{\n	int i, j;\n	while ((i = find_Subletter_Index(*a, *b) - 1) != -1)\n	{\n		for (j = i + b->length; j <= a->length; j++)	/*这里把\'\\0\'一起移过去*/\n		{\n			a->world[j - b->length] = a->world[j];\n		}\n		a->length -= b->length;\n	}\n}\n\n/*显示所有子串*/\nint find_All_Sublettter(String a)\n{\n	int i, j, k;\n	for (i = 0; i < a.length; i++)\n	{\n		for (j = i; j < a.length; j++)\n		{\n			for (k = i; k <= j; k++)\n			{\n				printf(\"%c\", a.world[k]);\n			}\n			printf(\"\\n\");\n		}\n	}\n}\n\nint main()\n{\n	String a = { {\"goodgoogle\"},10 };\n	String b = { {\"google\"},6 };\n	String c = { {\"asbcjbcnbca\"},11 };\n	String d = { {\"bc\"},2 };\n	//printf(\"%d\\n\",find_Subletter_Index(a, b));\n	delete_Subletter(&c, &d);\n	puts(c.world);\n	find_All_Sublettter(b);\n	return 0;\n}\n```',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2019-10-08 19:22:23','2020-11-29 11:45:13',0),(135,'栈','### 线性栈\n栈也分为线性和链表\n```c\n#pragma warning(disable:4996)\n#include<stdio.h>\n#include<stdlib.h>\n#define MAXSIZE 100\n#define OK 1\n#define ERROR -1\ntypedef struct\n{\n	char a;\n}DataType;\ntypedef struct\n{\n	int top;\n	DataType data[MAXSIZE];\n}SqStack;\n\n/*初始化顺序栈*/\nSqStack* init_SequenceStack(void)\n{\n	SqStack* L = (SqStack*)malloc(sizeof(SqStack));\n	if (L == NULL)\n	{\n		printf(\"空间分配失败！\\n\");\n		exit(1);\n	}\n	L->top = -1;\n	return L;\n}\n\n/*入栈*/\nint push_Stack(SqStack* L,DataType x)\n{\n	if (L->top >= MAXSIZE - 1)\n	{\n		printf(\"Overflow\");\n		return ERROR;\n	}\n	L->top++;\n	L->data[L->top] = x;\n	return OK;\n}\n\n/*出栈*/\nDataType pop_Stack(SqStack* L)\n{\n	DataType result;\n	if (L->top <= -1)\n	{\n		printf(\"Underflow\");\n		exit(1);\n	}\n	result = L->data[L->top];\n	L->top--;\n	return result;\n}\n\n/*输入数据（调用push_Stack）*/\nDataType input_DataType(SqStack* L)\n{\n	DataType x;\n	char a;\n	printf(\"请输入字符：\\n\");\n	while ((a = getchar()) != \'\\n\')\n	{\n		x.a = a;\n		push_Stack(L, x);\n	}\n	return x;\n}\n\n/*输出栈*/\nint print_SequenceStack(SqStack* L)\n{\n	int tmptop = L->top;\n	while (tmptop != -1)\n	{\n		printf(\"%c\", L->data[tmptop].a);\n		tmptop--;\n	}\n	return OK;\n}\n\nint main()\n{\n	SqStack* a = init_SequenceStack();\n	input_DataType(a);\n	print_SequenceStack(a);\n	return 0;\n}\n```',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2019-10-14 17:34:24','2020-11-29 11:45:13',0),(136,'矩阵','### 原数组\n```math\n\\begin{bmatrix}\n0&12&9&0&0&0&0 \\\\   \n0&0&0&0&0&0&0 \\\\\n-3&0&0&0&0&14&0 \\\\\n0&0&24&0&0&0&0  \\\\\n0&18&0&0&0&0&0  \\\\\n15&0&0&-7&0&0&0  \\\\\n\\end{bmatrix}\n```\n### 三元组的定义\n```c\ntypedef struct position\n{\n	int i, j;	//行，列\n	int v;	//值\n}Datatype;\nstruct spmatrix\n{\n	/*采用数组计数方法*/\n	int row, col ,num;	/*描述整体（行，列，非零元素个数）*/\n	Datatype data[MAXSIZE];	/*每个元素的具体位置*/\n};\n```\n### 转换为三元组\n将数组转化为三元组用于节省存储空间，i行，j列，v值\n```c\n/*矩阵转化为三元组*/\nstruct spmatrix transform(int a[ROW][COL],int row,int col)\n{\n	struct spmatrix matrix = { row - 1,col - 1,0,{0} };\n	int i, j;\n	int k=0;\n	for (i = 0; i < row; i++)\n	{\n		for (j = 0; j < col; j++)\n		{\n			/*非零值时传入三元组*/\n			if (a[i][j] != 0)\n			{\n				matrix.data[k].i = i;\n				matrix.data[k].j = j;\n				matrix.data[k].v = a[i][j];\n				matrix.num++;\n				k++;\n			}\n		}\n	}\n	matrix.num--;\n	k = 0;\n	printf(\"%d\", matrix.num);\n	while (k <= matrix.num)\n	{\n		printf(\"%d | %d | %d\\n\", matrix.data[k].i, matrix.data[k].j, matrix.data[k].v);\n		k++;\n	}\n	return matrix;\n}\n```\n### 进行转置操作\n\n转置前| i | j | v |转置后| i | j | v\n:---:|:---:|:---:|:---:|:---:|:---:|:---:|:---:\n0 | 0 | 1 | 12| 0 | 0 | 2 | -3\n1 | 0 | 2 | 9 | 1 | 0 | 5 | 15\n2 | 2 | 0 | -3| 2 | 1 | 0 | 12\n3 | 2 | 5 | 14| 3 | 1 | 4 | 18\n4 | 3 | 2 | 24| 4 | 2 | 0 | 9\n5 | 4 | 1 | 18| 5 | 2 | 3 | 24\n6 | 5 | 0 | 15| 6 | 3 | 5 | -7\n7 | 5 | 3 | -7| 7 | 5 | 2 | 14\n转置的实现的核心思想为外层循环添加新的三元表，内层循环寻找原三元表中的列（按照列寻找），按照列从小到大的顺序寻找列，找到后行列交换\n```c\n/*矩阵转置*/\nstruct spmatrix exchange(struct spmatrix a, struct spmatrix b)\n{\n	int x, y;\n	int k = 0;\n	b.col = a.row;\n	b.row = a.col;\n	b.num = a.num;\n	for (x = 0; x <= b.num; x++)	/*外层控制转置后的三元组*/\n	{\n		for (y = 0; y <= b.num; y++)	/*内层控制转置前的三元组*/\n		{\n			/*进行交换*/\n			if (a.data[y].j == x)\n			{\n				b.data[k].i = a.data[y].j;\n				b.data[k].j = a.data[y].i;\n				b.data[k].v = a.data[y].v;\n				k++;\n			}\n		}\n	}\n	k = 0;\n	while (k <= a.num)\n	{\n		printf(\"%d | %d | %d\\n\", b.data[k].i, b.data[k].j, b.data[k].v);\n		k++;\n	}\n	return b;\n}\n```\n### 矩阵加法操作\n首先将矩阵转换为三元表，每一行元素进行比较，小的一行添加到新的三元表中，后进行自增操作，若相同因判断是否为零\n```c\n/*矩阵相加*/\nstruct spmatrix add_Matrix(int a[ROW][COL], int b[ROW][COL])\n{\n	struct spmatrix a1 = transform(a);\n	struct spmatrix b1 = transform(b);\n	struct spmatrix result = { ROW,COL,0,{0} };\n	int x = 0, y = 0, k = 0;\n	int renum;\n	while (1)\n	{\n		/*a1小于b1*/\n		if (a1.data[x].i < b1.data[y].i || (a1.data[x].i == b1.data[y].i && a1.data[x].j < b1.data[y].j))\n		{\n			result.data[k].i = a1.data[x].i;\n			result.data[k].j = a1.data[x].j;\n			result.data[k].v = a1.data[x].v;\n			result.num++;\n			k++;\n			x++;\n		}\n		/*a1大于b1*/\n		else if (a1.data[x].i > b1.data[y].i || (a1.data[x].i == b1.data[y].i && a1.data[x].j > b1.data[y].j))\n		{\n			result.data[k].i = b1.data[y].i;\n			result.data[k].j = b1.data[y].j;\n			result.data[k].v = b1.data[y].v;\n			result.num++;\n			k++;\n			y++;\n		}\n		/*相等*/\n		else if (a1.data[x].i == b1.data[y].i && a1.data[x].j == b1.data[y].j)\n		{\n			renum = a1.data[x].v + b1.data[y].v;\n			if (renum != 0)\n			{\n				result.data[k].i = a1.data[x].i;\n				result.data[k].j = a1.data[x].j;\n				result.data[k].v = renum;\n				result.num++;\n				k++;\n				x++;\n				y++;\n			}\n			else\n			{\n				x++;\n				y++;\n			}\n		}\n		/*结束循环的条件*/\n		if (x == a1.num || y == b1.num)\n		{\n			if (x < y)\n			{\n				result.data[k].i = a1.data[x].i;\n				result.data[k].j = a1.data[x].j;\n				result.data[k].v = a1.data[x].v;\n				result.num++;\n				k++;\n				x++;\n			}\n			if (x > y)\n			{\n				result.data[k].i = b1.data[y].i;\n				result.data[k].j = b1.data[y].j;\n				result.data[k].v = b1.data[y].v;\n				result.num++;\n				k++;\n				x++;\n			}\n			if (x == y)\n			{\n				return result;\n			}\n		}\n	}\n	/*k = 0;\n	while (k < result.num)\n	{\n		printf(\"%d | %d | %d\\n\", result.data[k].i, result.data[k].j, result.data[k].v);\n		k++;\n	}*/\n}\n```\n### 全部代码\n```C\n#pragma warning(disable:4996)\n#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n/*ROW与COL使用数组计数*/\n#define ROW 3\n#define COL 4\n#define MAXSIZE 10\n#define OK 1\ntypedef struct position\n{\n	int i, j;	//行，列\n	int v;	//值\n}Datatype;\nstruct spmatrix\n{\n	/*采用数组计数方法*/\n	int row, col ,num;	/*描述整体（行，列，非零元素个数）*/\n	Datatype data[MAXSIZE];	/*每个元素的具体位置*/\n};\n\n/*矩阵转化为三元组*/\nstruct spmatrix transform(int a[ROW][COL])\n{\n	struct spmatrix matrix = { ROW,COL,{0} };\n	int i, j;\n	int k=0;\n	for (i = 0; i < ROW; i++)\n	{\n		for (j = 0; j < COL; j++)\n		{\n			/*非零值时传入三元组*/\n			if (a[i][j] != 0)\n			{\n				matrix.data[k].i = i;\n				matrix.data[k].j = j;\n				matrix.data[k].v = a[i][j];\n				matrix.num++;\n				k++;\n			}\n		}\n	}\n	matrix.num--;\n	k = 0;\n	/*用于查看*/\n	/*while (k <= matrix.num)\n	{\n		printf(\"%d | %d | %d\\n\", matrix.data[k].i, matrix.data[k].j, matrix.data[k].v);\n		k++;\n	}*/\n	return matrix;\n}\n\n/*矩阵转置*/\nstruct spmatrix exchange(struct spmatrix a, struct spmatrix b)\n{\n	int x, y;\n	int k = 0;\n	b.col = a.row;\n	b.row = a.col;\n	b.num = a.num;\n	for (x = 0; x <= b.num; x++)	/*外层控制转置后的三元组*/\n	{\n		for (y = 0; y <= b.num; y++)	/*内层控制转置前的三元组*/\n		{\n			/*进行交换*/\n			if (a.data[y].j == x)\n			{\n				b.data[k].i = a.data[y].j;\n				b.data[k].j = a.data[y].i;\n				b.data[k].v = a.data[y].v;\n				k++;\n			}\n		}\n	}\n	k = 0;\n	while (k <= a.num)\n	{\n		printf(\"%d | %d | %d\\n\", b.data[k].i, b.data[k].j, b.data[k].v);\n		k++;\n	}\n	return b;\n}\n\n/*矩阵相加*/\nstruct spmatrix add_Matrix(int a[ROW][COL], int b[ROW][COL])\n{\n	struct spmatrix a1 = transform(a);\n	struct spmatrix b1 = transform(b);\n	struct spmatrix result = { ROW,COL,0,{0} };\n	int x = 0, y = 0, k = 0;\n	int renum;\n	while (1)\n	{\n		/*a1小于b1*/\n		if (a1.data[x].i < b1.data[y].i || (a1.data[x].i == b1.data[y].i && a1.data[x].j < b1.data[y].j))\n		{\n			result.data[k].i = a1.data[x].i;\n			result.data[k].j = a1.data[x].j;\n			result.data[k].v = a1.data[x].v;\n			result.num++;\n			k++;\n			x++;\n		}\n		/*a1大于b1*/\n		else if (a1.data[x].i > b1.data[y].i || (a1.data[x].i == b1.data[y].i && a1.data[x].j > b1.data[y].j))\n		{\n			result.data[k].i = b1.data[y].i;\n			result.data[k].j = b1.data[y].j;\n			result.data[k].v = b1.data[y].v;\n			result.num++;\n			k++;\n			y++;\n		}\n		/*相等*/\n		else if (a1.data[x].i == b1.data[y].i && a1.data[x].j == b1.data[y].j)\n		{\n			renum = a1.data[x].v + b1.data[y].v;\n			if (renum != 0)\n			{\n				result.data[k].i = a1.data[x].i;\n				result.data[k].j = a1.data[x].j;\n				result.data[k].v = renum;\n				result.num++;\n				k++;\n				x++;\n				y++;\n			}\n			else\n			{\n				x++;\n				y++;\n			}\n		}\n		/*结束循环的条件*/\n		if (x == a1.num || y == b1.num)\n		{\n			if (x < y)\n			{\n				result.data[k].i = a1.data[x].i;\n				result.data[k].j = a1.data[x].j;\n				result.data[k].v = a1.data[x].v;\n				result.num++;\n				k++;\n				x++;\n			}\n			if (x > y)\n			{\n				result.data[k].i = b1.data[y].i;\n				result.data[k].j = b1.data[y].j;\n				result.data[k].v = b1.data[y].v;\n				result.num++;\n				k++;\n				x++;\n			}\n			if (x == y)\n			{\n				break;//return result;\n			}\n		}\n	}\n	/*用于查看结果*/\n	k = 0;\n	while (k < result.num)\n	{\n		printf(\"%d | %d | %d\\n\", result.data[k].i, result.data[k].j, result.data[k].v);\n		k++;\n	}\n}\n\nint main()\n{\n	int array[6][7] = { \n	{0,12,9,0,0,0,0},\n	{0,0,0,0,0,0,0},\n	{-3,0,0,0,0,14,0},\n	{0,0,24,0,0,0,0},\n	{0,18,0,0,0,0,0},\n	{15,0,0,-7,0,0,0}\n	};\n	/*这里注意row与column采用直接计数方法6,7*/\n	int row = (sizeof(array) / sizeof(int)) / (sizeof(array[0]) / sizeof(int));\n	int col = sizeof(array[0]) / sizeof(int);\n	struct spmatrix a = { 6,7,7,{ {0,1,12},\n								{0,2,9},\n								{2,0,-3},\n								{2,5,14},\n								{3,2,24},\n								{4,1,18},\n								{5,0,15},\n								{5,3,-7} } };\n	struct spmatrix b = {0,0,0};\n	exchange(a, b);\n\n\n	int a1[3][4] = {\n	{1,0,0,1},\n	{2,-1,0,0},\n	{0,0,-3,2}\n	};\n	int b1[3][4] = {\n	{0,0,0,-1},\n	{3,1,0,0},\n	{0,1,4,-2}\n	};\n	add_Matrix(a1, b1);\n	return 0;\n}\n```',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2019-09-24 20:08:38','2020-11-29 11:45:13',0),(137,'线性表','```c\n#pragma warning(disable:4996)\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\ntypedef struct node\n{\n	int x;\n	char y;\n}DataType;\nstruct Seqlist\n{\n	int MAXNUM;	//线性表元素的最大个数\n	int n;	//线性表元素的个数\n	DataType element[20];	//结构体数组\n};\n\n/*创建空线性表*/\nstruct Seqlist* creat_Nullseqlist(int m)\n{\n	struct Seqlist* seqlist = (void*)malloc(sizeof(struct Seqlist) * m);	//申请线性表内存\n	if (seqlist == NULL)\n	{\n		printf(\"申请空间失败，退出程序!\\n\");\n		exit(1);\n	}\n	else\n	{\n		/*Seqlist初始化*/\n		seqlist->n = 0;\n		seqlist->MAXNUM = 10;	//最大10个成员\n		return seqlist;\n	}\n}\n\n/*插入数据到线性表中（前面添加）*/\nvoid preinsert_Data(struct Seqlist* L, int p, DataType x)	//创建的线性表，插入到的位置，插入的数据\n{\n	/*p的值不得等于0*/\n	int i;\n	if (L->n >= L->MAXNUM)	/*查看成员个数是否超出范围*/\n	{\n		printf(\"超出线性表的最大长度无法添加！\\n\");\n		return;\n	}\n	if (L->n == 0)	/*添加第一个成员时*/\n	{\n		L->element[p - 1] = x;\n	}\n	else\n	{\n		if (p > L->n || p <= 0)	/*检测插入位置是否合法*/\n		{\n			printf(\"插入位置不存在，请重新选择位置！\\n\");\n			return;\n		}\n		for (i = L->n - 1; i >= p - 1; i--)\n		{\n			L->element[i + 1] = L->element[i];\n		}\n		L->element[p - 1] = x;\n	}\n	L->n++;\n}\n\n/*插入数据到线性表中（后面添加）*/\nvoid postinsert_Data(struct Seqlist* L, int p, DataType x)\n{\n	/*不应该使用后插法添加第一个成员，会造成element[1]的结果*/\n	int i;\n	if (L->n >= L->MAXNUM)	/*查看元素个数是否超出范围*/\n	{\n		printf(\"超出线性表的最大长度无法添加！\\n\");\n	}\n	if (p > L->n || p <= 0)	/*检测插入位置是否合法*/\n	{\n		printf(\"插入位置不存在，请重新选择位置！\\n\");\n		return;\n	}\n	for (i = L->n - 1; i >= p; i--)\n	{\n		L->element[i + 1] = L->element[i];\n	}\n	L->element[p] = x;\n	L->n++;\n}\n\n/*删除线性表中的成员*/\nvoid delete_Data(struct Seqlist* L, int p)	//p为被删除成员的位置\n{\n	int i;\n	if (p > L->n - 1 || p <= 0)	/*检查插入位置是否合法*/\n	{\n		printf(\"插入位置不存在，请重新选择位置！\\n\");\n		return;\n	}\n	/*此处成功达成内存泄漏成就*/\n	for (i = p - 1; i < L->n - 1; i++)\n	{\n		L->element[i] = L->element[i + 1];\n	}\n	L->n--;\n}\n\n/*查找成员位置返回线性表下标*/\nint find_Data(struct Seqlist* L, DataType x)	//x为被查找的成员\n{\n	int i, j = 0;\n	DataType* temp = (void*)malloc(sizeof(x));\n	DataType* tempx = &x;\n	int result[30];\n	if (L->n != 0)	/*判断是否为空表*/\n	{\n		for (i = 0; i <= L->n - 1; i++)\n		{\n			*temp = L->element[i];\n			if (memcmp(temp, tempx, sizeof(temp)) == 0)\n			{\n				result[j++] = i + 1;\n			}\n		}\n	}\n	else\n	{\n		printf(\"线性表为空无法查找成员！\\n\");\n	}\n	/*输出结果数组*/\n	for (i = 0; i<j; i++)\n	{\n		printf(\"查找到的位置为：%d\\n\", result[i]);\n	}\n	free(temp);\n	free(tempx);\n	return result;\n\n}\n\n/*输出结果*/\nvoid print_Data(struct Seqlist* L)\n{\n	int i;\n	for (i = 0; i <= L->n - 1; i++)\n	{\n		printf(\"%d \", L->element[i]. x);\n	}\n}\n\nint main()\n{\n	struct Seqlist* a;\n	a = creat_Nullseqlist(3);\n	DataType a1 = { 1,\'a\' };\n	DataType a2 = { 2,\'b\' };\n	DataType a3 = { 3,\'b\' };\n	preinsert_Data(a, 1, a1);\n	preinsert_Data(a, 1, a2);\n	postinsert_Data(a, 1, a3);\n	delete_Data(a, 2);\n	find_Data(a, a1);\n	print_Data(a);\n	return 0;\n}\n```',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2019-09-05 21:18:45','2020-11-29 11:45:13',0),(138,'线索二叉树','### 线索二叉树的声明\n利用空左右子树储存前驱或后驱结点（需要左右标记进行判断）<br>\n使用enmu枚举类型Link = 0，Thread = 1\n```c\n/*Link==0表示指向左右孩子的指针*/\n/*Thread==1表示指向前驱或后继的线索 */\ntypedef enum { Link, Thread }PointerTag;\n/*声明定义链式二叉树*/\ntypedef struct\n{\n	char a;\n}DataType;\ntypedef struct binarytreenode\n{\n	DataType data;\n	struct binarytreenode* lchild;	/*左子树*/\n	struct binarytreenode* rchild;	/*右子树*/\n	PointerTag LTag;	/*左标记*/\n	PointerTag RTag;	/*右标记*/\n}BiTree;\nBiTree* pre;    /*线索化时作为前驱结点*/\n```\n### 线索化中序二叉树\n左手前驱，右手后继<br>\n对于当前处理的结点：<br>\n1.前驱使用左子树连接pre<br>\n2.后继使用pre连接当前结点\n```c\n/*中序遍历线索化二叉树*/\nBiTree* in_Order_Threading_Binarytree(BiTree* T)\n{\n	if (T != NULL)\n	{\n		in_Order_Threading_Binarytree(T->lchild);	/*线索化左子树*/\n		if (!T->lchild)	/*左子树为空*/\n		{\n			T->LTag = Thread;	/*令左标签为1*/\n			T->lchild = pre;	/*令左子树指向前驱结点*/\n		}\n		if (pre != NULL && !pre->rchild)	/*前驱结点右子树为空*/\n		{\n			pre->RTag = Thread;	/*令右标签为1*/\n			pre->rchild = T;	/*令前驱结点右子树指向后继*/\n		}\n		pre = T;\n		in_Order_Threading_Binarytree(T->rchild);	/*线索化右子树*/\n	}\n}\n```\n### 遍历中序线索化二叉树\n1.首先寻找左子树<br>\n2.右子树无非两种情况<br>\n    (1)RTag == Thread<br>\n    向后移动后，输出<br>\n    (2)RTag == Link<br>\n    向后移动后，判断有无左子树\n```c\n/*中序遍历输出线索化二叉树*/\nint in_Order_Traverse_Threaded_Binarytree(BiTree* T)\n{\n	BiTree* p = T;\n	while (p)\n	{\n		while (p->LTag == Link)	/*当左标记为0时*/\n		{\n			p = p->lchild;\n		}\n		printf(\"%c\", p->data.a);\n		while (p->RTag == Thread)	/*因为没有头节点所以先不动*/\n		{\n			p = p->rchild;\n			printf(\"%c\", p->data.a);\n		}\n		p = p->rchild;\n	}\n	return OK;\n}\n```\n### 全部代码\n```c\n#pragma warning(disable:4996)\n#include<stdio.h>\n#include<stdlib.h>\n#include<malloc.h>\n#define OK 0\n#define ERROR -1\n#define MAXSIZE 50\n/*Link==0表示指向左右孩子的指针*/\n/*Thread==1表示指向前驱或后继的线索 */\ntypedef enum { Link, Thread }PointerTag;\n/*声明定义链式二叉树*/\ntypedef struct\n{\n	char a;\n}DataType;\ntypedef struct binarytreenode\n{\n	DataType data;\n	struct binarytreenode* lchild;	/*左子树*/\n	struct binarytreenode* rchild;	/*右子树*/\n	PointerTag LTag;	/*左标记*/\n	PointerTag RTag;	/*右标记*/\n}BiTree;\nBiTree* pre;\n\n/*初始化二叉树（前序遍历）*/\nBiTree* init_Binarytreenode(BiTree* T)\n{\n	DataType x;\n	printf(\"请输入字符：\\n\");\n	scanf_s(\"%c\", &x.a, 1);	/*scanf有返回值*/\n	if (x.a != \'#\')\n	{\n		T = (BiTree*)malloc(sizeof(BiTree));\n		if (T == NULL)\n		{\n			printf(\"内存分配失败！\\n\");\n			exit(1);\n		}\n		T->data = x;\n		T->LTag = Link;\n		T->RTag = Link;\n		T->lchild = NULL;\n		T->rchild = NULL;\n		T->lchild = init_Binarytreenode(T->lchild);\n		T->rchild = init_Binarytreenode(T->rchild);\n	}\n	return T;\n}\n\n/*中序遍历线索化二叉树*/\nBiTree* in_Order_Threading_Binarytree(BiTree* T)\n{\n	if (T != NULL)\n	{\n		in_Order_Threading_Binarytree(T->lchild);	/*线索化左子树*/\n		if (!T->lchild)	/*左子树为空*/\n		{\n			T->LTag = Thread;	/*令左标签为1*/\n			T->lchild = pre;	/*令左子树指向前驱结点*/\n		}\n		if (pre != NULL && !pre->rchild)	/*前驱结点右子树为空*/\n		{\n			pre->RTag = Thread;	/*令右标签为1*/\n			pre->rchild = T;	/*令前驱结点右子树指向后继*/\n		}\n		pre = T;\n		in_Order_Threading_Binarytree(T->rchild);	/*线索化右子树*/\n	}\n}\n\n/*中序遍历输出线索化二叉树*/\nint in_Order_Traverse_Threaded_Binarytree(BiTree* T)\n{\n	BiTree* p = T;\n	while (p)\n	{\n		while (p->LTag == Link)	/*当左标记为0时*/\n		{\n			p = p->lchild;\n		}\n		printf(\"%c\", p->data.a);\n		while (p->RTag == Thread)	/*因为没有头节点所以先不动*/\n		{\n			p = p->rchild;\n			printf(\"%c\", p->data.a);\n		}\n		p = p->rchild;\n	}\n	return OK;\n}\n\nint main()\n{\n	BiTree* a = NULL;\n	a = init_Binarytreenode(a);\n	in_Order_Threading_Binarytree(a);\n    in_Order_Traverse_Threaded_Binarytree(a);\n	return 0;\n}/*ABDG##H###CE#I##F##*/\n /*ABDH##I##EJ###CF##G##*/\n ```',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2019-11-05 08:46:23','2020-11-29 11:45:13',0),(139,'链式队列','### 链式队列的声明\nNode用于创建链表<br>\nfront和rear指向单个节点<br>\n当front == NULL 时代表队列为空\n```c\n/*声明定义链式队列*/\ntypedef struct\n{\n	char a;\n}DataType;\ntypedef struct node\n{\n	DataType data;\n	struct node* next;\n}Node;\ntypedef struct\n{\n	Node* front;	/*队头指针*/\n	Node* rear;		/*队尾指针*/\n}LinkQueue;\n```\n### 入队\n入队的时候要分为两种情况：1.空 2.非空<br>\nfront和rear只是作为结构体指针存在，单纯指向单个节点<br>\n当只有一个节点front和rear同时指向节点\n```c\n/*入队*/\nint enQueue(LinkQueue* Q, DataType x)\n{\n	Node* newnode = (Node*)malloc(sizeof(Node));\n	if (newnode == NULL)\n	{\n		printf(\"内存分配失败！\\n\");\n		exit(1);\n	}\n	if (Q->front == NULL)	/*第一次添加元素*/\n	{\n		Q->front = newnode;\n		Q->rear = newnode;\n		newnode->data = x;\n		newnode->next = NULL;\n	}\n	/*后续添加元素*/\n	else\n	{\n		newnode->data = x;\n		newnode->next = NULL;\n		Q->rear->next = newnode;\n		Q->rear = newnode;\n		return OK;\n	}\n}\n```\n### 出队\n当出最后一个元素的时候注意，应该将队列恢复初始化的状态\n```c\n/*出队*/\nDataType deQueue(LinkQueue* Q)\n{\n	if (Q->front == NULL)\n	{\n		printf(\"队列为空！\\n\");\n		exit(1);\n	}\n	DataType x;\n	Node* p = Q->front;	/*第一个元素的指针*/\n	x = p->data;	/*获取数据*/\n	Q->front = p->next;	/*删除第一个元素*/\n	/*当出队的是最后一个元素时p->next = NULL*/\n	/*回到初始化的状态*/\n	if (Q->front == NULL)\n	{\n		Q->rear = NULL;\n	}\n	free(p);\n	return x;\n}\n```\n### 全部代码\n```c\n#pragma warning(disable:4996)\n#include<stdio.h>\n#include<stdlib.h>\n#include<malloc.h>\n#define OK 0\n#define ERROR -1\n#define MAXSIZE 50\n/*声明定义链式队列*/\ntypedef struct\n{\n	char a;\n}DataType;\ntypedef struct node\n{\n	DataType data;\n	struct node* next;\n}Node;\ntypedef struct\n{\n	Node* front;	/*队头指针*/\n	Node* rear;		/*队尾指针*/\n}LinkQueue;\n\n/*初始化链式队列*/\nLinkQueue* init_Linkqueue()\n{\n	LinkQueue* Q = (LinkQueue*)malloc(sizeof(LinkQueue));\n	if (Q == NULL)\n	{\n		printf(\"内存分配失败！\\n\");\n		exit(1);\n	}\n	Q->front = NULL;\n	Q->rear = NULL;\n}\n\n/*入队*/\nint enQueue(LinkQueue* Q, DataType x)\n{\n	Node* newnode = (Node*)malloc(sizeof(Node));\n	if (newnode == NULL)\n	{\n		printf(\"内存分配失败！\\n\");\n		exit(1);\n	}\n	if (Q->front == NULL)	/*第一次添加元素*/\n	{\n		Q->front = newnode;\n		Q->rear = newnode;\n		newnode->data = x;\n		newnode->next = NULL;\n	}\n	/*后续添加元素*/\n	else\n	{\n		newnode->data = x;\n		newnode->next = NULL;\n		Q->rear->next = newnode;\n		Q->rear = newnode;\n		return OK;\n	}\n}\n\n/*出队*/\nDataType deQueue(LinkQueue* Q)\n{\n	if (Q->front == NULL)\n	{\n		printf(\"队列为空！\\n\");\n		exit(1);\n	}\n	DataType x;\n	Node* p = Q->front;	/*第一个元素的指针*/\n	x = p->data;	/*获取数据*/\n	Q->front = p->next;	/*删除第一个元素*/\n	/*当出队的是最后一个元素时p->next = NULL*/\n	/*回到初始化的状态*/\n	if (Q->front == NULL)\n	{\n		Q->rear = NULL;\n	}\n	free(p);\n	return x;\n}\n\n/*输入数据（调用enQueue）*/\nDataType input_DataType(LinkQueue* Q)\n{\n	DataType x;\n	char a;\n	printf(\"请输入字符：\\n\");\n	while ((a = getchar()) != \'\\n\')\n	{\n		x.a = a;\n		enQueue(Q, x);\n	}\n	return x;\n}\n\n/*输出队列*/\nint print_Linkqueue(LinkQueue* Q)\n{\n	Node* p = Q->front;\n	if (Q->front == NULL)\n	{\n		printf(\"空队列！\\n\");\n	}\n	while (p != NULL)\n	{\n		printf(\"%c\", p->data.a);\n		p = p->next;\n	}\n	return OK;\n}\n\nint main()\n{\n	LinkQueue* a = init_Linkqueue();\n	input_DataType(a);\n	deQueue(a);\n	print_Linkqueue(a);\n	return 0;\n}\n```',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2019-10-18 23:46:39','2020-11-29 11:45:13',0),(140,'链表','```c\n/*------------------------XXX管理------------------------*/\n#pragma warning(disable:4996)\n#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#define ERROR -1\n#define OK 1\ntypedef struct stu \n{\n	int number;\n	char name[10];\n}DataType;\nstruct Node\n{\n	DataType element;\n	struct Node* nextnode;	//下一节点\n};\n/*函数声明*/\nstruct Node* create_Link(void);															/*创建林克表（Linked Lists）*/\nvoid pre_insert_Data(struct Node* L, struct Node* p, DataType x);						/*插入数据（DataType）*/\nint pre_add_Data(struct Node* L);														/*添加数据（头插）*/\nint post_add_Data(struct Node* L);														/*添加数据（尾插）*/\nDataType input_Data(void);																/*添加数据项数据（函数内调用）*/\nstruct Node* find_Data(struct Node* L, DataType x);										/*查找数据*/\nint findeddata_opration_Interface(struct Node* L, struct Node* location);				/*数据操作界面*/\nint delete_Data(struct Node* L, struct Node* location);									/*删除链表节点*/\nint print_Linklist(struct Node* L);														/*输出链表（全部）*/\n\n\n/*创建林克表（Linked Lists）*/\nstruct Node* create_Link(void)\n{\n	/*创建头指针*/\n	struct Node* head = (void*)malloc(sizeof(struct Node));\n	/*创建头节点*/\n	struct Node* firstNode = (void*)malloc(sizeof(struct Node));\n	if (firstNode == NULL)\n	{\n		printf(\"内存分配失败!\");\n		exit(1);\n	}\n	head->nextnode = firstNode;\n	firstNode->nextnode = NULL;\n	return head;\n}\n\n/*插入数据（DataType）*/\nvoid pre_insert_Data(struct Node* L,struct Node* p,DataType x)\n{\n\n}\n\n/*添加数据（头插）*/\nint pre_add_Data(struct Node* L)\n{\n	/*申请新节点内存*/\n	struct Node* newnode = (struct Node*)malloc(sizeof(struct Node));\n	if (newnode == NULL)\n	{\n		printf(\"内存分配失败!\");\n		exit(1);\n	}\n	/*申请数据项内存*/\n	DataType* newdata = (DataType*)malloc(sizeof(DataType));\n	if (newdata == NULL)\n	{\n		printf(\"内存分配失败!\");\n		exit(1);\n	}\n	*newdata = input_Data();\n	newnode->element = *newdata;\n	/*在头节点后面添加节点*/\n	struct Node* location;\n	location = L->nextnode;	//头节点\n	/*插入操作*/\n	newnode->nextnode = location->nextnode;	\n	location->nextnode = newnode;\n	return OK;\n}\n\n/*添加数据（尾插）*/\nint post_add_Data(struct Node* L)\n{\n	/*申请新节点内存*/\n	struct Node* newnode = (struct Node*)malloc(sizeof(struct Node));\n	if (newnode == NULL)\n	{\n		printf(\"内存分配失败!\");\n		exit(1);\n	}\n	/*申请数据项内存*/\n	DataType* newdata = (DataType*)malloc(sizeof(DataType));\n	if (newdata == NULL)\n	{\n		printf(\"内存分配失败!\");\n		exit(1);\n	}\n	*newdata = input_Data();\n	newnode->element = *newdata;\n	/*在NULL之前添加节点*/\n	struct Node* location;\n	/*插入操作*/\n	location = L->nextnode;	//头节点\n	while (location->nextnode != NULL)\n	{\n		location = location->nextnode;\n	}\n	location->nextnode = newnode;\n	newnode->nextnode = NULL;\n\n}\n\n/*添加数据项数据（函数内调用）*/\nDataType input_Data(void)\n{\n	DataType x;\n	printf(\"请输入编号：\\n\");\n	scanf_s(\"%d\", &x.number, 4);\n	getchar();	/*清除输入的回车*/\n	printf(\"请输入姓名：\\n\");\n	gets(x.name);\n	return x;\n}\n\n/*查找数据*/\nstruct Node* find_Data(struct Node* L,DataType x)\n{\n	int p;\n	struct Node* location;\n	location = L->nextnode;	//头节点\n	location = location->nextnode;	//第一个数据节点或NULL\n	for (p = 0; location->nextnode != NULL; p++)\n	{\n		if (location->element.number == x.number)\n		{\n			printf(\"找到数据！\\n\");\n			return location;\n		}\n	}\n	printf(\"未找到相符数据！\\n\");\n}\n\n/*数据操作界面*/\nint findeddata_opration_Interface(struct Node* L,struct Node* location)\n{\n	while (1)\n	{\n		int choice = 0;\n		char choice2 = \'t\';\n		/*界面*/\n		printf(\"------查看请选择1------\\n\");\n		printf(\"------删除请选择2------\\n\");\n		scanf_s(\"%d\", &choice, 4);\n		getchar();\n		/*选择*/\n		if (choice == 1)\n		{\n			printf(\"数据查看...\\n\");\n			printf(\"编号：%d\\n\", location->element.number);\n			printf(\"姓名：\");\n			puts(location->element.name);\n			return OK;\n		}\n		if (choice == 2)\n		{\n			printf(\"是否确定删除数据?(y/n)\\n\");\n			choice2 = getchar();\n			if (choice2 == \'y\' || choice2 == \'Y\')\n			{\n				delete_Data(L, location);\n				return 1;\n			}\n			if (choice2 == \'n\' || choice2 == \'N\')\n			{\n				printf(\"那就重新选择操作!\\n\");\n				printf(\"\\n\");\n				continue;\n			}\n			else\n			{\n				printf(\"无效的选择!\\n\");\n				continue;\n			}\n		}\n		else\n		{\n			printf(\"无效的选择!\\n\");\n			continue;\n		}\n	}\n}\n\n/*删除链表节点*/\nint delete_Data(struct Node* L,struct Node* location)\n{\n	struct Node* temp;\n	temp = L->nextnode;\n	printf(\"正在删除...\\n\");\n	for (int i = 0; temp->nextnode != location; i++)	/*寻找location前面一个节点*/\n	{\n		temp = temp->nextnode;\n	}\n	/*删除操作*/\n	temp->nextnode = location->nextnode;\n	free(location);\n	printf(\"已删除节点!\\n\");\n	return OK;\n}\n\n/*输出链表（全部）*/\nint print_Linklist(struct Node* L)\n{\n	struct Node* location;\n	location = L->nextnode;\n	while (location->nextnode != NULL)\n	{\n		location = location->nextnode;\n		printf(\"编号：%d\\n\",location->element.number);\n		printf(\"姓名：\");\n		puts(location->element.name);\n	}\n	return OK;\n}\n\nint main()\n{\n	struct Node* linklist;\n	linklist = create_Link();\n	post_add_Data(linklist);\n	post_add_Data(linklist);\n	print_Linklist(linklist);\n	findeddata_opration_Interface(linklist, linklist);\n	return 0;\n}\n```\n#### python实现\n一直没什么思路，突然看视频才知道了怎么写<br>\n首先还是用类封装节点和链表<br>\n头指针指向第一个节点（面向对象中就是继承了Node()实例化之后，对象的属性）<br>\n```pyhton\nclass Node(object):\n    \"\"\"单个节点\"\"\"\n\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\n\nclass LinkList(object):\n    \"\"\"链表类\"\"\"\n\n    def __init__(self, node=None):\n        # 继承node中的所有属性\n        # 头指针指向第一个节点\n        self._head = node\n\n    def is_empty(self):\n        return self._head is None\n\n    def length(self):\n        cur = self._head\n        count = 0\n        while cur is not None:\n            count += 1\n            cur = cur.next\n        return count\n\n    def add(self, data):\n        \"\"\"头插入\"\"\"\n        node = Node(data)\n        if self._head is None:\n            self._head = node\n        else:\n            node.next = self._head\n            self._head = node\n\n    def append(self, data):\n        \"\"\"尾插入\"\"\"\n        node = Node(data)\n\n        if self._head is None:\n            self._head = node\n        else:\n            cur = self._head\n            while cur.next is not None:\n                cur = cur.next\n            cur.next = node\n\n    def travel(self):\n        cur = self._head\n        while cur is not None:\n            print(cur.data)\n            cur = cur.next\n\n    def search(self, find_data):\n        result_list = []\n        cur = self._head\n        while cur is not None:\n            if cur.data == find_data:\n                result_list.append(cur)\n            cur = cur.next\n            # 返回对象列表\n        return result_list\n\n    def delete(self, find_data):\n        cur = self._head\n        prev = self._head\n        if self._head is None:\n            return None\n        while True:\n            # 没有头节点要分开处理\n            if self._head.data == find_data:\n                self._head = self._head.next\n            else:\n                break\n        while cur is not None:\n            if cur.data == find_data:\n                prev.next = cur.next\n            prev = cur\n            cur = cur.next\n\n    def clear(self):\n        self._head = None\n\n\nif __name__ == \"__main__\":\n    linklist = LinkList()\n    print(linklist.is_empty())\n    linklist.append(1)\n    linklist.append(1)\n    linklist.append(2)\n    linklist.append(3)\n    linklist.append(4)\n    # print(linklist.length())\n    linklist.delete(1)\n    linklist.travel()\n    print(linklist.search(1))\n\n```',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2019-12-16 22:29:05','2020-11-29 11:45:13',0),(141,'队列','### 线性队列的声明\n由于普通队列某些操作后对空间利用率不高，这里使用循环线性队列\n```c\n/*声明定义线性队列*/\ntypedef struct\n{\n	char a;\n}DataType;\ntypedef struct\n{\n	DataType data[MAXSIZE];\n	int front;\n	int rear;\n}SqQueue;\n```\n### 初始化\n当队列为空时：Q->front == Q->real\n#### 循环的奥秘\n```c\n判断：(Q->rear + 1) % MAXSIZE == Q->front\n求队列中元素个数：(Q->rear - Q->front + MAXSIZE) % MAXSIZE\n后指针后移：Q->rear = (Q->rear + 1) % MAXSIZE\n```\n```c\n/*初始化线性队列*/\nSqQueue* init_SequenQueue(void)\n{\n	SqQueue* Q = (SqQueue*)malloc(sizeof(SqQueue));\n	if (Q == NULL)\n	{\n		printf(\"内存分配失败！\\n\");\n		exit(1);\n	}\n	Q->front = 0;\n	Q->rear = 0;\n	return Q;\n}\n```\n### 全部代码\n```c\n#pragma warning(disable:4996)\n#include<stdio.h>\n#include<stdlib.h>\n#include<malloc.h>\n#define OK 0\n#define ERROR -1\n#define MAXSIZE 50\n/*声明定义线性队列*/\ntypedef struct\n{\n	char a;\n}DataType;\ntypedef struct\n{\n	DataType data[MAXSIZE];\n	int front;\n	int rear;\n}SqQueue;\n\n/*初始化线性队列*/\nSqQueue* init_SequenQueue(void)\n{\n	SqQueue* Q = (SqQueue*)malloc(sizeof(SqQueue));\n	if (Q == NULL)\n	{\n		printf(\"内存分配失败！\\n\");\n		exit(1);\n	}\n	Q->front = 0;\n	Q->rear = 0;\n	return Q;\n}\n\n/*入队*/\nint enQueue(SqQueue* Q,DataType x)\n{\n	/*判断是否为满队列*/\n	if (((Q->rear + 1) % MAXSIZE) == Q->front)	/*这里使用rear和front相差一来确定为满队列*/\n	{\n		printf(\"达到最大个数，无法添加！\\n\");\n		return ERROR;\n	}\n	Q->data[Q->rear] = x;\n	Q->rear = (Q->rear + 1) % MAXSIZE;	/*后指针后移*/\n}\n\n/*出队*/\nDataType deQueue(SqQueue* Q)\n{\n	DataType x;\n	if (Q->front == Q->rear)\n	{\n		printf(\"空队列！\\n\");\n		exit(1);\n	}\n	x = Q->data[Q->front];\n	Q->front = (Q->front + 1) % MAXSIZE;	/*前指针后移*/\n	return x;\n}\n\n/*队列元素的个数*/\nint length_SequenQueue(SqQueue* Q)\n{\n	return (Q->rear - Q->front + MAXSIZE) % MAXSIZE;\n}\n\n/*输入数据（调用enQueue）*/\nDataType input_DataType(SqQueue* Q)\n{\n	DataType x;\n	char a;\n	printf(\"请输入字符：\\n\");\n	while ((a = getchar()) != \'\\n\')\n	{\n		x.a = a;\n		enQueue(Q, x);\n	}\n	return x;\n}\n\n/*输出队列*/\nint print_SequenQueue(SqQueue* Q)\n{\n	int tmpfront = Q->front;\n	/*判断是否输出完成*/\n	while ((tmpfront % MAXSIZE) != Q->rear)\n	{\n		printf(\"%c\", Q->data[tmpfront].a);\n		tmpfront = (tmpfront + 1) % MAXSIZE;\n	}\n	return OK;\n}\n\nint main()\n{\n	SqQueue* a = init_SequenQueue();\n	input_DataType(a);\n	print_SequenQueue(a);\n	return 0;\n}\n```',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2019-10-17 20:09:10','2020-11-29 11:45:13',0),(142,'静态链表','在某些没有指针的语言中使用结构体数组的方法实现指针的操作，但由于本身作为数组所以被称为静态链表\n### 静态链表的定义\n![image](https://note.youdao.com/yws/api/personal/file/6CA29AECC1A446AE898A08A6DEDC72A9?method=download&shareKey=ec8002bb0fbe03274ce15eb2da625b9f)\n在某些没有指针的语言中使用结构体数组的方法实现指针的操作，但由于本身作为数组所以被称为静态链表<br>\n我们在创建一个静态链表时应该使用结构体数组，通过结构体数组实现类链表的操作\n```c\n#define MAXSIZE 1000\ntypedef struct data\n{\n	char* a;\n}DataType;\nstruct staticlinklist\n{\n	DataType data;	/*记录数据*/\n	int cur;	/*记录下一个元素的位置*/\n};\n/*main函数中：struct saticlinklist a[MAXSIZE];*/\n```\n### 静态链表的初始化\n将每一个元素与下一个元素处理完成\n```c\n/*初始化静态链表*/\nstruct staticlinklist init_Staticlinklist(struct staticlinklist space[MAXSIZE])\n{\n	int i;\n	/*将所有位置初始化*/\n	for (i = 0; i < MAXSIZE - 1; i++)\n	{\n		space[i].cur = i + 1;\n	}\n	space[MAXSIZE - 1].cur = 0;\n}\n```\n### 插入数据\n![image](https://note.youdao.com/yws/api/personal/file/B095104EFB9546D98E31C6F49B3827E4?method=download&shareKey=e8e7073a771e6ca146a53b2425837349)\n1.首先确定可用空间的位置，传入数据<br>\n2.确定之前元素位置，更改下一元素位置信息<br>\n3.更改前元素下一元素位置信息\n```c\n/*寻找可使用的空间（）*/\nint malloc_Staticlinklist(struct staticlinklist space[MAXSIZE])\n{\n	/*找到第一个空闲空间*/\n	int i = space[0].cur;\n	if (space[0].cur != 0)\n	{\n		space[0].cur = space[i].cur;	/*下一步为插入数据，更改空闲空间位置信息*/\n	}\n	return i;\n}\n/*插入数据*/\n/*在L中第i个元素之前插入数据X*/\nint insert_Data(struct staticlinklist L[MAXSIZE], int i, DataType x)\n{\n	int j, k, l;\n	k = MAXSIZE - 1;\n	if (i<1 || i>MAXSIZE - 1)\n	{\n		return ERROR;\n	}\n	j = malloc_Staticlinklist(L);	/*获取空闲位置下标*/\n	if (j != 0)\n	{\n		L[j].data = x;\n		for (l = 1; l <= i - 1; l++)	/*找到第i个元素之前元素的位置*/\n		{\n			k = L[k].cur;\n		}\n		L[j].cur = L[k].cur;	/*传入前一个元素记录下个元素的位置信息*/\n		L[k].cur = j;	/*更改前元素的位置信息*/\n		return OK;\n	}\n	return ERROR;\n}\n```\n### 全部代码\n```c\n#pragma warning(disable:4996)\n#include<stdio.h>\n#define OK 1\n#define ERROR -1\n#define MAXSIZE 1000\ntypedef struct data\n{\n	char* a;\n}DataType;\nstruct staticlinklist\n{\n	DataType data;	/*记录数据*/\n	int cur;	/*记录下一个元素的位置*/\n};\n\nstruct staticlinklist init_Staticlinklist(struct staticlinklist space[MAXSIZE]);	/*初始化静态链表*/\nint malloc_Staticlinklist(struct staticlinklist space[MAXSIZE]);					/*寻找可使用的空间（insert_Data内调用）*/\nint insert_Data(struct staticlinklist L[MAXSIZE], int i, DataType x);				/*在L中第i个元素之前插入数据X*/\nint sequential_Write_Staticlinklist(struct staticlinklist L[MAXSIZE], DataType x);	/*顺序写入数据*/\nint sequential_Print_Staticlinklis(struct staticlinklist L[MAXSIZE]);				/*按储存结构顺序显示所有元素*/\nint print_Staticlinklis(struct staticlinklist L[MAXSIZE]);							/*显示所有元素*/\nint delete_Staticlinklis(struct staticlinklist L[MAXSIZE], int i);					/*删除在L中的第i个元素*/\nint free_Staticlinklist(struct staticlinklist L[MAXSIZE], int k);					/*“回收空间”*/\n\n/*初始化静态链表*/\nstruct staticlinklist init_Staticlinklist(struct staticlinklist space[MAXSIZE])\n{\n	int i;\n	/*将所有位置初始化*/\n	for (i = 0; i < MAXSIZE - 1; i++)\n	{\n		space[i].cur = i + 1;\n	}\n	space[MAXSIZE - 1].cur = 0;\n}\n\n/*寻找可使用的空间（）*/\nint malloc_Staticlinklist(struct staticlinklist space[MAXSIZE])\n{\n	/*找到第一个空闲空间*/\n	int i = space[0].cur;\n	if (space[0].cur != 0)\n	{\n		space[0].cur = space[i].cur;	/*下一步为插入数据，更改空闲空间位置信息*/\n	}\n	return i;\n}\n\n/*插入数据*/\n/*在L中第i个元素之前插入数据X*/\nint insert_Data(struct staticlinklist L[MAXSIZE], int i, DataType x)\n{\n	int j, k, l;\n	k = MAXSIZE - 1;\n	if (i<1 || i>MAXSIZE - 1)\n	{\n		return ERROR;\n	}\n	j = malloc_Staticlinklist(L);	/*获取空闲位置下标*/\n	if (j != 0)\n	{\n		L[j].data = x;\n		for (l = 1; l <= i - 1; l++)	/*找到第i个元素之前元素的位置*/\n		{\n			k = L[k].cur;\n		}\n		L[j].cur = L[k].cur;	/*传入前一个元素记录下个元素的位置信息*/\n		L[k].cur = j;	/*更改前元素的位置信息*/\n		return OK;\n	}\n	return ERROR;\n}\n\n/*顺序写入数据*/\nint sequential_Write_Staticlinklist(struct staticlinklist L[MAXSIZE],DataType x)\n{\n	/*当为空时*/\n	if (L[MAXSIZE - 1].cur == 0)\n	{\n		L[1].data = x;\n		L[MAXSIZE - 1].cur = 1;\n		L[0].cur = 2;\n		return OK;\n	}\n	int i;\n	/*寻找空闲位置*/\n	i = L[0].cur;\n	L[i].data = x;\n	/*重新确定空闲位置*/\n	L[0].cur = L[i].cur;\n	return OK;\n}\n\n/*按储存结构顺序显示所有元素*/\nint sequential_Print_Staticlinklis(struct staticlinklist L[MAXSIZE])\n{\n	int i = 1;\n	for (i; i < L[0].cur; i++)\n	{\n		putchar(L[i].data.a);\n	}\n	return OK;\n}\n\n/*显示所有元素*/\nint print_Staticlinklis(struct staticlinklist L[MAXSIZE])\n{\n	int p = L[MAXSIZE - 1].cur;\n	int i = 0;\n	/*这里实在想不出什么办法控制循环*/\n	while (i < 5)\n	{\n		putchar(L[p].data.a);\n		p = L[p].cur;\n		i++;\n	}\n	return OK;\n}\n\n/*删除静态链表中的元素*/\n/*删除在L中的第i个元素*/\nint delete_Staticlinklis(struct staticlinklist L[MAXSIZE], int i)\n{\n	int k = MAXSIZE - 1, j;\n	if (i<1 || i>MAXSIZE - 1)\n	{\n		return ERROR;\n	}\n	/*找到前一个元素位置*/\n	for (j = 1; j <= i - 1; j++)\n	{\n		k = L[k].cur;	/*k从头节点开始*/\n	}\n	j = L[k].cur;	//被删除元素的下标\n	L[k].cur = L[j].cur;	/*更改前一个元素的下一个元素位置*/\n	free_Staticlinklist(L, j);\n}\n\n/*“回收空间”*/\nint free_Staticlinklist(struct staticlinklist space[MAXSIZE], int k)\n{\n	space[k].cur = space[0].cur;	/*将新的空间放入，原新空间之前*/\n	space[0].cur = k;	/*重新表示剩余空间位置*/\n}\n\nint main()\n{\n	struct staticlinklist a[MAXSIZE];\n	DataType x = { \'a\' }; DataType x1 = { \'b\' }; DataType x2 = { \'c\' }; DataType x3 = { \'d\' };\n	init_Staticlinklist(a);\n	sequential_Write_Staticlinklist(a, x);\n	sequential_Write_Staticlinklist(a, x1);\n	sequential_Write_Staticlinklist(a, x2);\n	sequential_Write_Staticlinklist(a, x3);\n	insert_Data(a, 2, x);\n	delete_Staticlinklis(a, 2);\n	print_Staticlinklis(a);\n	return 0;\n}\n```',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2019-10-05 12:03:35','2020-11-29 11:45:13',0),(143,'1-10累加','```asm\nCDOE SEGMENT\nASSUME CS:CDOE\nSTART : MOV AL,0\n        MOV CX,10\n        MOV BL,1\nLOOPSEG : ADD AL,BL\n          INC BL\n          LOOP LOOPSEG\n          \n          MOV CL,AL\n          MOV DL,AL\n          MOV BL,10\n          DIV BL\n	      ADD AL,48\n          MOV DL,AL\n\n          MOV AH,02H\n          INT 21H     \n\n          MOV AX,0\n          MOV AL,CL\n          MOV BL,10\n          DIV BL\n          ADD AH,48\n          MOV DL,AH\n\n          MOV AH,02H\n          INT 21H  \n\n          MOV AH,4CH\n          INT 21H\nCDOE ENDS\nEND START\n```',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2019-11-21 17:17:09','2020-11-29 11:45:13',0),(144,'20个数字累加','```asm\ndata segment\nbuf dw 20 dup(?)    ;重复定义20个数字使用dw\nsum dw (?)  ;最后的结果\ndata ends\n\ncode segment\nassume ds:data,cs:code\nstart:\n    mov ax,data\n    mov ds,ax\n    mov ax,0\n    mov cx,20   ;控制循环次数\n    mov bx,buf\nlop:\n    add ax,[bx]\n    add bx,2    ;dw所以地址加2\n    loop lop\n    mov [sum],ax\n    mov ah,4ch\n    int 21h\ncode ends\nend start\n```',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2019-12-17 21:46:54','2020-11-29 11:45:13',0),(145,'大写变小写','```asm\ndata segment\nbuf db 65,66,67,68\nbuf1 db 4 dup(?)\ndata ends\n\ncode segment\nassume ds:data,cs:code  ;datasegment,codesegment\nstart:\n    mov ax,data\n    mov ds,ax   ;data传入ds\n    lea si,buf ;转递有效地址\n    lea di,buf1\n    mov cx,4    ;控制循环次数\nlop:\n    mov al,[si] ;取地址中的值\n    add al,32\n    mov [di],al ;转换后放入新的地址\n    inc si\n    inc di\n    loop lop\n    mov ah,4ch\n    int 21h\ncode ends\nend start\n```',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2019-12-17 21:45:57','2020-11-29 11:45:13',0),(146,'二分查找','二分查找数据必须有顺序的进行排列\n```c\n#pragma warning(disable:4996)\n#include<stdio.h>\n#include<stdlib.h>\n#define SIZEOFARRAY 8\nint bin_Serach(int numarray[], int x)\n{\n	int low, high, mid;\n	low = 0;\n	high = SIZEOFARRAY;\n	while (low <= high)\n	{\n		mid = (low + high) / 2;\n		if (numarray[mid] == x)\n		{\n			return mid;\n		}\n		else if (x < numarray[mid])\n		{\n			high = mid - 1;\n		}\n		else\n		{\n			low = mid + 1;\n		}\n	}\n	printf(\"查找失败！\\n\");\n	return -1;\n}\n\nint main()\n{\n	int numarray[8] = { 1,3,5,7,9,11,12,13 };\n	printf(\"%d\\n\", bin_Serach(numarray, 13));\n	return 0;\n}\n```',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2019-11-19 09:21:32','2020-11-29 11:45:13',0),(147,'冒泡排序','```c\n#include<stdio.h>\n#include<math.h>\nvoid func(int a[],int count)//传递数组和元素个数\n{\n	int i = 0, j;\n	int temp, temp2;\n	temp2 = count;\n	for (i = 0; i < count - 1; i++)\n	{\n		for (j = 0; j < temp2 - 1; j++)\n		{\n			if (a[count - 1 - j] < a[count - 2 - j])\n			{\n				temp = a[count - 2 - j];\n				a[count - 2 - j] = a[count - 1 - j];\n				a[count - 1 - j] = temp;\n			}\n\n		}\n		temp2--;//减少无用的判断次数\n	}\n}\nint main()\n{\n	int i, count;\n	int a[] = { 4,3,2,1 }, *p;\n	count = sizeof(a) / sizeof(int);//通常数组计算元素个数的方法\n	p = a;\n	func(p,count);\n	for (i = 0; i < count; i++)\n	{\n		printf(\"%d \", a[i]);\n	}\n}\n```\n字母的冒泡排序\n其实没什么区别\n```c\n#pragma warning(disable:4996)\n#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n\nfun(char t[])\n{\n	char c;\n	int i, j;\n	/*冒泡排序*/\n	for (i = strlen(t); i; i--)\n	{\n		for (j = 0; j < strlen(t) - 1; j++)	/*这里的次数应十分注意*/\n		{\n			/*如果次数达到strlen(t)，那么寻找元素会来到t[j+1]而里面的值为\'\\0\'，所以元素个数会不断减少*/\n			if (t[j] > t[j + 1])\n			{\n				c = t[j];\n				t[j] = t[j + 1];\n				t[j + 1] = c;\n			}\n			//puts(t);\n		}\n		//puts(t);\n	}\n}\n\nmain()\n{\n	int s[81];\n	gets(s);\n	fun(s);\n	puts(s);\n}\n```',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2019-09-21 16:30:10','2020-11-29 11:45:13',0),(148,'回文算法','```python\r\n\"\"\"196问题\"\"\"\r\nnum = int(input(\'请输入数字：\'))\r\nn = 0\r\nwhile n < 200:  # 控制循环次数防止有哪个沙雕输入196\r\n    # 进行回文判断\r\n    a = str(num)\r\n    count = 0\r\n    flag = 0\r\n\r\n    for i in a:\r\n        count += 1\r\n    temp = count // 2\r\n    for i in range(count):\r\n        if i >= temp:\r\n            flag = 1\r\n            break\r\n        if a[i] != a[count - 1 - i]:\r\n            flag = 0\r\n            break\r\n    # 输出结果\r\n    if flag == 1:\r\n        print(\'结果为：%d\' % num)\r\n        break\r\n    # 进行神奇加法操作\r\n    else:\r\n        a_reverse = str()\r\n        for each in range(count):\r\n            a_reverse += a[count - each - 1]\r\n            num = int(a) + int(a_reverse)\r\n        print(\'%s + %s = %s\' % (a, a_reverse, str(num)))\r\n    n += 1\r\n```',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2019-08-04 18:34:43','2020-11-29 11:45:13',0),(149,'快速排序','### 时间复杂度\n最差时间复杂度:\n```math\nO(N^2)\n```\n平均时间复杂度：\n```math\nO(NlogN)\n```\n1.确定基准数<br>\n2.分别从左右两侧寻找比基准数小的和比基准数大的<br>\n3.交换两数的位置<br>\n4.当i == j时交换基准数与a[i]的位置<br>\n5.使用递归继续快速排序左右数列\n\n为什么从j开始找而不是从i开始？\n\n当i与j相等时，由于基准数在最左边（从小到大排列）右面要进行与基准数的交换，我们要的是较小的哪个数，而不是较大的那个数，如果先从i开始寻找i与j会停在比基准数大的数字上\n\n### 代码\n```c\n#pragma warning(disable:4996)\n#include<stdio.h>\n#include<stdlib.h>\nint a[10] = { 20,30,42,25,75,11,55,33,22,57 };\nint quick_sort(int left, int right)\n{\n	int i, j, benchnum, t;\n	if (left > right)\n	{\n		return;\n	}\n	benchnum = a[left];	/*基准数*/\n	i = left;\n	j = right;\n	while (i != j)\n	{\n		while (i < j && a[j] >= benchnum)\n		{\n			j--;//从右向左找第一个小于x的数\n		}\n\n		while (i < j && a[i] <= benchnum)\n		{\n			i++;//从左向右找第一个大于x的数\n		}\n		if (i < j)\n		{\n			t = a[i];\n			a[i] = a[j];\n			a[j] = t;\n		}\n	}\n	a[left] = a[i];\n	a[i] = benchnum;\n	quick_sort(left, i - 1);/*递归排序左边*/\n	quick_sort(i + 1, right); /*递归排序右边*/\n}\n\nint main()\n{\n	int i = 0;\n	quick_sort(0, 9);\n	for (i = 0; i < 10; i++)\n	{\n		printf(\"%d \", a[i]);\n	}\n}\n```',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2019-11-26 15:23:25','2020-11-29 11:45:13',0),(150,'斐波那契与尾递归','尾递归顾名思义与正常递归相比，不需要在最后时刻不停往前返回，而是可以直接使用最后一次调用函数的结果，效率比普通递归更高\n```c\n#include<stdio.h>\n#include<math.h>\nint func(int n,int x,int y)//尾递归\n{\n	if (n <= 1)\n	{\n		return x;\n	}\n	return func(n - 1, y, x + y);//尾调用\n}\nint main()\n{\n	printf(\"%d\\n\", func(6, 1, 1));\n}\n```\n普通递归没有使用尾调用（要求最后一步只能调用这个函数）\n```c\n#include<stdio.h>\n#include<math.h>\nint func(int n)//递归\n{\n	if (n == 1 || n==2)\n	{\n		return 1;\n	}\n	return func(n - 1) + func(n - 2);\n}\nint main()\n{\n	printf(\"%d\", func(6));\n}\n```\npython实现：\n```python\ndef func(n):  # 斐波那契数列递归求解\n    if n < 1:\n        print(\'数据错误！\')\n    else:\n        if n > 2:\n            return func(n - 2) + func(n - 1)\n        if n == 1 or n == 2:\n            return 1\n\n\nprint(func(12))\n\n\ndef func2(n, x, y):  # 斐波那契数列尾递归求解\n    if n < 1:\n        print(\'数据错误！\')\n    else:\n        if n <= 1:\n            return x\n        return func2(n - 1, y, x + y)\n\n\nprint(func2(12, 1, 1))\n\n\ndef func3(n):  # 斐波那契数列迭代求解\n    n1 = 1\n    n2 = 1\n    n3 = 1\n    if n < 1:\n        print(\'数据错误！\')\n    while (n - 2) > 0:\n        n3 = n1 + n2\n        n1 = n2\n        n2 = n3\n        n -= 1\n    return n3\n\n\nprint(func3(12))\n```',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2019-08-01 17:26:35','2020-11-29 11:45:13',0),(151,'求素数','```c\n#include<stdio.h>\n#include<math.h>\nvoid func(int x)//核心思想\n{\n	int flag = 1, i;\n	if (x == 2)\n	{\n		flag = 1;\n	}\n	for (i = 2; i <= sqrt(x); i++)\n	{\n		if (x % i == 0)\n		{\n			flag = 0;\n			break;\n		}\n	}\n	if (flag == 1)\n	{\n		printf(\"质数\");\n	}\n	else\n	{\n		printf(\"和数\");\n	}\n}\nvoid func2()//输出100以内的质数\n{\n	int x = 2;\n	while (x < 100)\n	{\n		int flag = 1, i;\n		if (x == 2)\n		{\n			flag = 1;\n		}\n		for (i = 2; i <= sqrt(x); i++)\n		{\n			if (x % i == 0)\n			{\n				flag = 0;\n				break;\n			}\n		}\n		if (flag == 1)\n		{\n			printf(\"%d\\n\", x);\n		}\n		x++;\n	}\n}\nint main()\n{\n	func(9);\n	func2();\n}\n```\n简单的函数写法\n```c\nint isprime(int num)\n{\n    int m;\n    for (m = 2;m < num;m++)\n    {\n        if (n%m == 0)\n            return 0;\n    }\n    return 1;\n}',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2019-09-21 17:12:29','2020-11-29 11:45:13',0),(152,'辗转相除法求最大公因数','```c\r\n#include<stdio.h>\r\nint find(int m, int n)//欧几里得算法（辗转相除法）\r\n{\r\n	int temp, r;\r\n	if (n < m)//交换\r\n	{\r\n		temp = m;\r\n		m = n;\r\n		n = temp;\r\n	}\r\n	while (n > 0)\r\n	{\r\n		r = m % n;\r\n		m = n;\r\n		n = r;\r\n	}\r\n	return m;\r\n}\r\nint main()\r\n{\r\n	printf(\"最大公约数：%d\\n\", find(8, 3));\r\n	printf(\"最小公倍数：%d\\n\", ((8 * 3) / find(8, 3)));//m*n = 最大公约数*最小公倍数\r\n}\r\n```',0,'d7885613210d4274bbb00834965b7155','RoderickXiang',NULL,'2019-07-30 22:27:57','2020-11-29 11:45:13',0),(153,'图片测试','![image](https://img-blog.csdnimg.cn/20190927095808388.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Jpbmd5dTk4NzU=,size_16,color_FFFFFF,t_70)',42,'305dac0a9a1541f493d5083dd892f536','测试用户',NULL,'2020-12-13 20:54:15','2020-12-13 20:54:15',0),(154,'图片测试👀','![](/image-article/image_c7746bbe62fc42c2890e501ade59fcab.png)\r\n又是不想救公主的一天呢~~😁',194,'305dac0a9a1541f493d5083dd892f536','测试用户',NULL,'2020-12-15 14:29:02','2020-12-15 14:29:02',0);
/*!40000 ALTER TABLE `blog_article` ENABLE KEYS */;

--
-- Table structure for table `blog_article_category`
--

DROP TABLE IF EXISTS `blog_article_category`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `blog_article_category` (
  `id` int NOT NULL AUTO_INCREMENT,
  `category_name` char(100) NOT NULL COMMENT '分类名称',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT='文章分类，相当于tag';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `blog_article_category`
--

/*!40000 ALTER TABLE `blog_article_category` DISABLE KEYS */;
INSERT INTO `blog_article_category` VALUES (1,'Java'),(2,'MySql');
/*!40000 ALTER TABLE `blog_article_category` ENABLE KEYS */;

--
-- Table structure for table `blog_comment`
--

DROP TABLE IF EXISTS `blog_comment`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `blog_comment` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `article_id` bigint NOT NULL COMMENT '文章id',
  `content` text NOT NULL COMMENT '评论内容',
  `user_uid` char(50) NOT NULL COMMENT '写评论的uid',
  `user_username` char(100) NOT NULL COMMENT '用户名',
  `user_avatar` char(200) DEFAULT NULL COMMENT '用户头像',
  `parent_comment_id` bigint DEFAULT NULL COMMENT '被回复的消息的id',
  `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '评论时间',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT='评论';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `blog_comment`
--

/*!40000 ALTER TABLE `blog_comment` DISABLE KEYS */;
/*!40000 ALTER TABLE `blog_comment` ENABLE KEYS */;

--
-- Table structure for table `blog_user`
--

DROP TABLE IF EXISTS `blog_user`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `blog_user` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `uid` char(50) NOT NULL COMMENT '用户uid--进行查找',
  `username` char(100) NOT NULL COMMENT '用户名',
  `password` char(100) NOT NULL COMMENT '已加密的密码',
  `avatar` char(200) DEFAULT NULL COMMENT '用户的头像地址',
  `role_id` int DEFAULT NULL COMMENT '用户的角色，对应角色表--role',
  `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `modified_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '修改时间',
  `is_deleted` int NOT NULL DEFAULT '0' COMMENT '逻辑删除',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=13 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT='用户';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `blog_user`
--

/*!40000 ALTER TABLE `blog_user` DISABLE KEYS */;
INSERT INTO `blog_user` VALUES (1,'d7885613210d4274bbb00834965b7155','RoderickXiang','$2a$10$VyUzkHcSIJffC7Ee58nbJ.fzHbeWVfa7/Sd7lxwJzJVJwE6kLdVZG',NULL,1,'2020-11-19 17:57:34','2020-11-19 17:57:34',0),(2,'43b6b60a943e4bb2a51527113e0818a7','天汉','$2a$10$E0/3FTKMe5N0dsFPCe4AgORLXsuO180Sb1cnHZFxPf4VZtdCYxUBW',NULL,1,'2020-12-08 22:43:59','2020-12-08 22:43:59',0),(11,'305dac0a9a1541f493d5083dd892f536','测试用户','$2a$10$X2I2FE99wN7ypwIbiY5gL.OhZJCRHCX330TppSs7y19x1/ZYz0tAW','/avatar/avatar_6ff4b49d307045feace8c1f72efb1e99.jpg',1,'2020-12-08 23:26:58','2020-12-08 23:26:58',0),(12,'488ca9e5d5f2492ba9f1d68ab96adf45','晨曦路上','$2a$10$ib/rVAA9mBAlf2/zQasatehEI31/VhOhH.wa3NMi1Uqv/ze8rhVxy',NULL,1,'2020-12-10 21:09:12','2020-12-10 21:09:12',0);
/*!40000 ALTER TABLE `blog_user` ENABLE KEYS */;

--
-- Table structure for table `blog_user_info`
--

DROP TABLE IF EXISTS `blog_user_info`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `blog_user_info` (
  `uid` char(50) NOT NULL COMMENT '与blog_user中的uid对应',
  `gender` int DEFAULT '0' COMMENT '0-保密 1-男 2-女',
  `birthday` date DEFAULT NULL COMMENT '生日',
  `email` char(50) DEFAULT NULL COMMENT '邮箱',
  `mobile` char(50) DEFAULT NULL COMMENT '手机号',
  `signature` varchar(200) DEFAULT NULL COMMENT '个性签名',
  `github` varchar(200) DEFAULT NULL,
  `website` varchar(200) DEFAULT NULL COMMENT '个人网站',
  PRIMARY KEY (`uid`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT='用户详细信息';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `blog_user_info`
--

/*!40000 ALTER TABLE `blog_user_info` DISABLE KEYS */;
INSERT INTO `blog_user_info` VALUES ('305dac0a9a1541f493d5083dd892f536',1,'1999-10-16','xxxx@xx.com','+86180999999','Just sudo it!','github','www.pron.com'),('43b6b60a943e4bb2a51527113e0818a7',0,NULL,NULL,NULL,NULL,NULL,NULL),('488ca9e5d5f2492ba9f1d68ab96adf45',1,'1998-02-25',NULL,NULL,'CSGO大队长',NULL,''),('d7885613210d4274bbb00834965b7155',0,NULL,'3097934536@qq.com','18070421795','一只咸鱼~~',NULL,NULL);
/*!40000 ALTER TABLE `blog_user_info` ENABLE KEYS */;

--
-- Table structure for table `blog_user_role`
--

DROP TABLE IF EXISTS `blog_user_role`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `blog_user_role` (
  `id` int NOT NULL AUTO_INCREMENT,
  `user_role` char(50) NOT NULL COMMENT '角色名',
  `description` varchar(500) DEFAULT NULL COMMENT '角色的描述信息',
  `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT='用户角色表';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `blog_user_role`
--

/*!40000 ALTER TABLE `blog_user_role` DISABLE KEYS */;
INSERT INTO `blog_user_role` VALUES (1,'NORMAL','普通用户','2020-11-22 21:40:39');
/*!40000 ALTER TABLE `blog_user_role` ENABLE KEYS */;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2021-01-15 12:21:06
